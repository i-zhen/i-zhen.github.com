<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Z.Y. ☯ Cosmos</title>
  
  <subtitle>Powered by Disqus, scientific surfing for access</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://izhen.me/"/>
  <updated>2020-01-29T03:15:08.916Z</updated>
  <id>http://izhen.me/</id>
  
  <author>
    <name>LambdaHOLiC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工作3年会遇到什么事</title>
    <link href="http://izhen.me/2020/01/25/work3years/"/>
    <id>http://izhen.me/2020/01/25/work3years/</id>
    <published>2020-01-25T14:51:45.000Z</published>
    <updated>2020-01-29T03:15:08.916Z</updated>
    
    <content type="html"><![CDATA[<p>大年初一，起草一篇总结性质的博文，太久没有写类似的文章了，感觉提笔忘语。这篇文章是想记录一下我从2017年工作至今的工作感想的，严格说到4月份才满3年，不过四舍五入也就算了。3年对于一名程序员来讲刚刚摆脱了菜鸟，是步入资深前的中间状态，还是比较资浅的，有代码总量积累的问题（到不是说一定要代码多，基本量要有保证），有遇到的情况是否充足的问题，还有各种与工程本身没太大关系的事情。因为换过一次工作，先后两个工作都有相当涉密的成分，所以技术细节不便多讲。主要是说说我自己的一些流水账吧。</p><a id="more"></a><h3 id="从毕业找工作开始"><a href="#从毕业找工作开始" class="headerlink" title="从毕业找工作开始"></a>从毕业找工作开始</h3><p>我本科是学习软件工程的，现在学校貌似没这个学院了，可以理解为为了扩招计算机科学人才而创的一个专业，教学大纲、<a href="https://izhen.me/2014/04/20/2014-04-20-asc-2014-pre/">专业活动</a>与计算机科学无异。研究生远渡重洋去到了<a href="https://izhen.me/2015/03/10/graduate/">英国的爱丁堡</a>攻读人工智能，并额外接触了大量程序语言理论的内容。最开始很想找到一份用函数式编程语言的工作。</p><p>撰写了<a href="https://resume.izhen.me" target="_blank" rel="noopener">简历</a>后开始海投很多的小众工作，也大都石沉大海，幻想初步破灭了。所以转战通用的场景，最终去到了<code>Citigroup</code>的投行部做Web开发。工作的寻找有很多的挑选条件，比如薪酬、工作内容、发展性等等。这些东西网上已经有很多了，我这里着重说说个性化的内容：</p><ul><li>因为老家天津的雾霾在15、16年极度严重，染上了支气管炎，吃了一周抗生素。通过调查判断，5年内无法治理干净。于是决定南下寻找工作，也就是出于个人身体健康的目的。而直到今年，2020年，冬季的北京、天津依旧有大规模雾霾的问题</li><li>或许是被西方世界洗了脑，或者是留学期间确实比较刻苦，总熬夜学习、赶作业、赶论文，所以工作不想再重复那种痛苦的过去了。绝对拒绝996，所以只考虑外资企业，主要是美资。Work-Life-Balance这一点Citi是不错的</li><li>个人更喜欢离老家不要太远，所谓父母在不远游，虽然天津和上海并不算太近，但是比华南地区还是近不少的</li><li>还有些不太刚性的需求：工作内容多元；处在更现代化的地区；有地中海风格的气候；等等</li></ul><p>可能到此会被觉得我「小毛病真多」，哈哈哈，无所谓的，其实每个人都或多或少在不同侧面有「小毛病」，只是我碰巧在这些方面有考虑而别人没有而已。不信，找个最亲近、最信赖的朋友或家人帮你分析分析，无论是生活上还是工作上。可别小看这些貌似鸡毛蒜皮的小事，因为也许将来的某一天正是这些小事困扰你呢，可谓人之常情，要懂得自己的人性。</p><p>而上述罗列的条件不全是满足的。</p><h2 id="Citi时代"><a href="#Citi时代" class="headerlink" title="Citi时代"></a>Citi时代</h2><h3 id="菜鸟的态度"><a href="#菜鸟的态度" class="headerlink" title="菜鸟的态度"></a>菜鸟的态度</h3><p>有上进心的菜鸟在刚开始工作的时候都是铆足马力的，我是没有经过入职培训直接接手工作的，被当成了半个社招的员工。偶尔会有加班的情况，但也遇到了几乎所有新人都会遇到的问题。</p><p>一开始我还是不太适应的，先从最简单的环境部署开始，出于安全考虑Citi的任何需要设置环境的地方都要用一个CMP系统提交order，我疯狂的安装了很多软件后才开始正式的工作。</p><p>第一行代码是写JUnit单元测试，这也是我在第一个岗位上占用相当大时间做的事情。借此机会也学习了Mock、H2 DB等单元测试和集成测试常用的技术。刚步入工作，我对项目的印象就是规模大，惊叹项目的复杂度，也犯了很多马虎的错误，比如在本地可以跑但是部署后不能运行的问题。而且刚工作我不太明白工作中有这么多需要记住的事情，导致我总是请教旁边的大哥，弄得人家挺不耐烦。</p><p>所以饭得一口一口吃，一步登天是不可能的，即便现在回过头看我们的项目不算大，但是也非一朝一夕可以掌握的。特别是刚拿到BRD的时候，根本看不懂上面所诉说的。即便偶尔请教我们自己的BA也是一样。</p><p>某段时间甚至还产生了「都不知道自己到底是强还是弱，百无一用是书生。学校的东西能让我受益，但是至少目前不是特别见效」这样的想法。也有我的问题我自己的理解和交流确实也不是特别到位。而这样类似的问题我之后也遇到过不少，现在看来或许大部分可以通过有效的交流改善。</p><p>大概过了3个月，接到部门大老板的指示，让我在兼顾工作的同时参与人工智能的科研项目。直到最后我才明白这意味着什么，有时候不是看上去那么简单。我决定好好搞AI，便在这个项目组做了大约三个月。期间加班不断，忙忙碌碌挺充实的。</p><p>虽然半年不到的时间，对于一个菜鸟工程师所应学习的东西我都尽了力，技术上必要掌握的、人际上该如何沟通，生活上怎样合理安排时间适应不同于学生时代的快节奏。期间还是有所抱怨，对工作内容也好，对于人事也罢，总的来说能从大家身上学习到不同的东西，比如责任心、合规、对新技术的追求、好学等等。也让我明白社会与学校的诸多不同，或许这就是成长吧。一边抱怨着，一边感谢着。</p><h3 id="裁员"><a href="#裁员" class="headerlink" title="裁员"></a>裁员</h3><p>到了8月份，噩耗来临，整个部门要被裁掉，我说不上是恐惧还是无所谓的感觉。也因此让我头一次体会到了危机感：永远要保持自己不被淘汰掉的价值，技术人员就要好好夯实基础。Citi对新人还是比较好的，被安排到另一个部门继续工作。</p><p>虽然工作时间不长，经历还是不少的。</p><h3 id="转组"><a href="#转组" class="headerlink" title="转组"></a>转组</h3><p>人生中第一次内转，依旧是开发Java，同时也要写一点JS了，不用于上一份工作的是这次的组非常的Critical，随时会有On Call的可能，因为涉及到数额巨大的转账，因此对于鲁棒性要求非常高。</p><p>在这里我专心做业务组的活，项目的规模、技术压力远超上一个组。比如我们在前一个组每次部署只要一个至多两个包，而且release的压力不大。但是在新组，每个月都有release，而且一次部署10个包很常见。</p><p>在这里，我第一次完整的实现了一个前后端的业务模块，尽管模块很小。但就是这样的小模块也会出现很多对于需求理解不到位而做错的情况，所以不要小看任何一件事，进步都是一点一滴的。大多数时间我做的事情也很杂，能感觉到项目的代码结构和技术架构都很出色，很多基础的组件都是完全自主开发的。为了能胜任工作，会抽空看书、钻研代码库，借由这个机会学会了很多常见设计模式，Workflow的实现，反射和多线程、DI、AOP、控制反转等内容。但是这个组的东西更杂乱，除了编码，我还要负责轮流进行Support，持续集成的任务。</p><p>更重要的是作为工程师，学会了很多技术，比如消息机制，我们自己实现Workflow，POJO automated test，AOP技术，封装JDBC，Java 8的函数式特性等。在后来的工作中，我做的Reconciliation协议和反序列化模块都是对这些知识的运用。一开始我曾怀疑自己的所学，但是随着工作深入发现良好的知识体系越来越重要。不断学习总不会错。</p><h3 id="生活与梦想"><a href="#生活与梦想" class="headerlink" title="生活与梦想"></a>生活与梦想</h3><p>换做10年前，我从没有想到过自己会考虑在上海定居。2018年的4月份，托福于留学归国人才的政策，我拿到了上海户口。差不多这个时候我们组的Leader，看起来会在花旗终老的人选择离职。虽然诧异但是也让我逐渐意识到工作的性质：又不是为国效力，我们需要做到的是尊重市场规律，我不太想继续做CRUD Boy了，就算我年轻气盛吧，觉得Web后台这个领域很容易望到天花板。一年可能太快，但我还是想做一做跟语言相关的工作。然后一边准备着，一般寻找机会，终于在入秋时收到了来自华为2012编译器与编程语言实验室的Offer。</p><p>我打了脸，去了一家可能更甚于996的公司。</p><h3 id="转变"><a href="#转变" class="headerlink" title="转变"></a>转变</h3><p>在Citi的一年半我转变很大，就拿接受了华为的Offer来说，我竟然接受了一家996公司。</p><p>我从一开始的厌倦应试，不愿意刻意准备面试，到被迫开始看面经。从毕业后就幻想再也不用考试，到明白人生永远都有测试，有时只是变换了形式。从不赞赏996，到明白中国当下的环境，要想活少钱多就加倍努力，努力到可以跳过这个阶段为止。而且财务自由不是打工可以获得的，但是打工这个阶段不是一般人家可以越过的。</p><p>对自己的技术更能看清其实际意义，不再只做看起来酷的事情，我可以等到时机成熟的时候将酷的事情发扬光大。没有完美的企业，也不存在完全一无是处的公司。</p><p>生活中，为了办户口也花费了相当的时间，深感比移民还难。混社会这一年半，更能放下身段做不起眼的事情。更明白先珍惜自己的付出是首要的，做好对的起自己努力的事情。</p><p>总的来说，整体还是向好的方向变化的，无谓的抱怨减少了，切合实际思考针对性的建设性的能力加强了。更能随机应变，比如在面对失败的时候，如何调整心态，活在当下。也更懂得处理人际关系，傻白甜不是做给老板同事看的，专横跋扈也更不能解决问题。或许工作的本质就是无聊，那如果这样的话应该以怎样的心态去努力呢。</p><p>雷军说过：</p><ol><li>重点是如何选择，不要怕选错，选错是必然，关键是提高选对的成功率</li><li>顺势而为，站在风口上猪都会飞</li></ol><h3 id="第一份工作的经验"><a href="#第一份工作的经验" class="headerlink" title="第一份工作的经验"></a>第一份工作的经验</h3><ol><li>业务逻辑就是对所有细节的熟知，这个有一定技巧体系。即便不会反转二叉树，也能把业务逻辑分析得头头是道</li><li>好的老板不会一昧的画大饼，肯定先要体现经济利好。画大饼没有太大的实际意义，我大饼画的比你好</li><li>能做好本分工作不代表适合创业创新。工作能力的强弱也不与其为人处事的社会经验成正比</li><li>如果你温柔待人，便能得到相应的回馈。越优秀的人，所给予的反馈也越好，跟优秀的人在一起</li></ol><h2 id="华为时代"><a href="#华为时代" class="headerlink" title="华为时代"></a>华为时代</h2><h3 id="意想不到"><a href="#意想不到" class="headerlink" title="意想不到"></a>意想不到</h3><p>意想不到自己打了脸，选择了一份996的工作。言归正传，这份996的工作一是实现了自己可以在编程语言编译器领域做事的小小梦想；二是所谓工程师，工程技术的能力一定要足够扎实，我想在先前实现业务逻辑工作的基础上更进一步了。希望可以去做技术性更强、更基础、更底层、更能锻炼自己的工作。</p><p>我于2018年11月26日加入华为，第一周是在东莞南方工厂的华为大学进行入职培训，培训期间每天早上都要进行军训，然后上一天的课，最后一天进行签约，华为在第一个月就会给员工先发一笔工资，根据入职的早晚会发半个月或一个月的数额，后来也遇到公司各种理由发个奖金的情况，比如当月双倍工资，比如20亿奖励等等。给钱多名不虚传。</p><p>也在这里收货了一份美好的爱情，😊。</p><h3 id="前端项目组"><a href="#前端项目组" class="headerlink" title="前端项目组"></a>前端项目组</h3><p>培训过后我就回到了上海，此时已然是冬天，上海已经冷了。我被分配到了Maple前端组做编译器前端。Mentor很nice，指导到位，有些跟项目无关的技术培训课也是允许我去听的。隔年春天我搬到了外租的办公室，开始渐渐步入正轨，着手处理第一个项目，实现invoke-custom的Maple指令，其间最大的困难就是很少人对其有真正的了解，是我从论文中，从官方文档，从mailing list中一点一滴把细节抠出来拼好的。对于项目的难度预估也出现了偏差，好在最后顶住了压力交付给到了测试。</p><p>19年下半年初期开发一个前端Parser，自己设计简单的语法，无第三方库纯自研的。因为语法简单，不借助外部开源工具也不算难写，总体下来不到2000行代码。本来想试验用C++实现Parser Combinator，奈何无尽的CPS回调地狱，实现与调试的成本高，总的来说性价比过低，最终还是写了传统的解析器。期间也做了点开源整改的内容。</p><h3 id="出差攻关"><a href="#出差攻关" class="headerlink" title="出差攻关"></a>出差攻关</h3><p>在华为出差不是新鲜事，但这个通知是在19年10月份某一周的周五，通知我时还不知道具体出发日期。转天周六我被拉到一个群里说是下周一报道。于是我在周六最后关头交接了全部的项目，并于周六晚上和周日一天收拾打包了全部行李。因为据说要来年3、4月份才回来，只好退租了房子，并把家当寄放在朋友家里。</p><p>然后风风火火飞到了攻关地(具体地点保密)。</p><p>在这里，基本上集结了实验室的精锐。大家都是计算机行业摸爬滚打过的，跟谁都有点聊头。一个刚刚入职的博士专门搞程序分析的，我们聊过抽象解释。好多专家都是来自各行各业，什么都懂一些。在饭局上大家还谈到了ACM算法竞赛，以前从没有跟同事聊过算法，其实实际工程中会有需求，华为最近也重视，全部工程师都要通过内部的算法测试。这么多学术界精英，也让我有了不断强化自己，不断学习进步的动力。</p><h3 id="加班"><a href="#加班" class="headerlink" title="加班"></a>加班</h3><p>19年12月，体检结果不容乐观，小毛病不断。因为出差劳累，甚至还通宵赶发布，拼死拼活解决了几十个issue发现还有很多。愈发觉得正式上版本的时候不暴雷是不可能的。更关键的是如果我累垮了，损失的是自己。所以每天晚上都去园区的健身房跑步，走椭圆机。周末偶尔也会打个篮球锻炼身体。</p><p>20年1月，如期赶上项目<a href="https://plugins.jetbrains.com/plugin/13220-hms-toolkit/" target="_blank" rel="noopener">上线</a>，做的是自动代码生成的技术。月底正常回家过年。</p><p>可能是加班太久，天天搞攻关，没有自己学习的时间，逐渐背离了可持续发展方针，正处在职业上升阶段，不学无术。这就是996机制的弊端之一吧。反观996，很多时候是Boss的错误决定导致的，这话听起来不负责任，可是很多时候加班确实没必要，改个方针，或者面临法务风险就要推到重来。也有非常多不是那么核心的杂活占用了80%的时间。我确实不想一整天都干活，特别是很杂的活，写着大部分人都有能力做、甚至比我做得更好的工作，因为真的太像是个工具人了。可是在团队内不得不承担很多责任，也如此才能有机会接触核心工作。</p><p>日常工作也总是会抱怨点公司的不人性之处。可还是一边抱怨，一边感谢着。现在对于工作的理解更多了，应了那句话，没有十全十美。华为的平台是真的广阔，有些事情非得是有了一定资源才能做的。比方说一个小而精的移动互联网初创公司，大抵是没有太大余力和必要去造很多的轮子。更没必要去专门开发一款通用语言的编译器(也有小团队专门开发新语言的，比如Hexa，Imandra.ai)。反观养得起研究所的巨头企业，就有很多这样的预研项目，非常适合热爱技术的人才。所以多的不说，就是鱼和熊掌的问题。</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>在Citi时期，每年15天年假，精神生活非常丰富。不论是Bilibili举办的演唱会，还是F1的车赛，亦或是初音未来，能去的都去了一场没落下。甚至还有自己的时间发展一项业余爱好，充充电什么的。而换工作后，一开始的的确确不适应，负能量逐渐多了起来。积累的压力多了，业余活动少了，精神上的放松也少了。可以说一夜回到解放前。</p><p>时间的压缩，不但在身体上透支，也在精神层面失调。对于自我的思索少了很多，每天就像个行尸走肉，名副其实的小螺丝。也竭尽全力的挤出来时间跟着公司大佬的脚步多学一点，业余摄摄影，偶尔外出上海转一转。</p><p>直到现在我都没有明白什么才算是规律的作息。我也达成2019全年都没有请调休假的纪录。不仅如此就连周六日都没有完整休息过，感觉周末不上班已经算休假了，甚至会遇到公假上班的情况，这一年过得可真累。</p><h3 id="寄语"><a href="#寄语" class="headerlink" title="寄语"></a>寄语</h3><p>所有言论仅代表个人观点。希望在工作满5年的时候，再回过头看。技术、为人都能更上一层楼。也不要这么累了，平衡生活工作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大年初一，起草一篇总结性质的博文，太久没有写类似的文章了，感觉提笔忘语。这篇文章是想记录一下我从2017年工作至今的工作感想的，严格说到4月份才满3年，不过四舍五入也就算了。3年对于一名程序员来讲刚刚摆脱了菜鸟，是步入资深前的中间状态，还是比较资浅的，有代码总量积累的问题（到不是说一定要代码多，基本量要有保证），有遇到的情况是否充足的问题，还有各种与工程本身没太大关系的事情。因为换过一次工作，先后两个工作都有相当涉密的成分，所以技术细节不便多讲。主要是说说我自己的一些流水账吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="毕业" scheme="http://izhen.me/tags/%E6%AF%95%E4%B8%9A/"/>
    
      <category term="初级程序员" scheme="http://izhen.me/tags/%E5%88%9D%E7%BA%A7%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="编程" scheme="http://izhen.me/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="架构" scheme="http://izhen.me/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="修Bug" scheme="http://izhen.me/tags/%E4%BF%AEBug/"/>
    
      <category term="长期出差" scheme="http://izhen.me/tags/%E9%95%BF%E6%9C%9F%E5%87%BA%E5%B7%AE/"/>
    
  </entry>
  
  <entry>
    <title>工作3年会遇到什么技术</title>
    <link href="http://izhen.me/2020/01/25/junior_engineer/"/>
    <id>http://izhen.me/2020/01/25/junior_engineer/</id>
    <published>2020-01-25T12:51:45.000Z</published>
    <updated>2020-01-29T04:30:07.119Z</updated>
    
    <content type="html"><![CDATA[<p>工程师与程序录入员的区别就是工程师不仅仅只做编码工作。当然编码是最基础的，除此外还有诸如部署、Support、解决方案提供等「杂活」。曾经我觉得除了编码都是不务正业浪费时间，现在我开始慢慢的去改变这一观点并慢慢去做好很多细节。举个例子，我刚来工作的时候，连Eclipse也用不好，毕竟学生时代用Vim什么的就足够了。</p><p>我在刚刚工作时一直希望能够得到一篇弥补象牙塔与真正工业界之间GAP的指导，奈何都不是我特别需要的，所以这里撰文一篇，记录我自己的一些技术所需。因为业务涉密，所以不列举具体业务内容。</p><a id="more"></a><h2 id="Web项目"><a href="#Web项目" class="headerlink" title="Web项目"></a>Web项目</h2><h3 id="文档，环境"><a href="#文档，环境" class="headerlink" title="文档，环境"></a>文档，环境</h3><ol><li>文档阅读。业务和工程架构都在这里面了，看着眼花的UML图，多多少少是抗拒的。而且行文质量不高的文档很难给予更多的帮助</li><li>环境部署。Java的部署比较麻烦，也可能仅仅是学生项目的部署简单</li></ol><h3 id="基础技术细节"><a href="#基础技术细节" class="headerlink" title="基础技术细节"></a>基础技术细节</h3><ol><li>我自己也做过Web项目，我写的项目前端和后端是在一起的。然后现代工业界是彻底分离的，不仅仅是编码层面的分离。根本就是两个服务器，前端启一个，后端启一个。然后设计成RESTful的API。</li><li>知道了单元测试（测方法）、集成测试（测功能）和端对端测试（前端到后端的贯穿）是什么，也是工作中才接触这些的。</li><li>发邮件有主动请求的，有很多库可以render邮件的内容。另一种是AOP，切面编程。可以用Java的动态代理实现，也可以借助Spring这些框架的功能配置一下。</li><li>工作流JBPM，我们可以先配置一个Workflow，然后用Java编写ActionHandler，其实我刚工作前3个月都不是特别清楚这个有什么用。其实Workflow比较复杂的时候JBPM可以帮助我们更标准化的管理工作流，就是按照一定程序执行业务</li><li>写过Hibernate、JPA、JDBC，最后都是用JDBC自己设计的。之所以用JDBC是为了支持的更General一些，这是因为Hibernate每个表都有一个对应的Class，ORM的初衷也是如此。这样添加新的表就必须有新的Class，不利于扩展。用JDBC实现Common方法后就可以避免这些问题</li><li>Java的包管理Maven是用XML配置的，其实当下更通用的是Json</li><li>Angular JS是HTML与JS(TS)混编，Ext JS则是纯JS。HTML做数据绑定和布局，JS写逻辑</li><li>多个包（独立项目）在Java中可以相互依赖，或者说相互依赖功能都是独立的Jar包</li><li>Eclipse的快捷键需要记住常用的</li><li>javaDoc如果有什么问题，可以用参数Skip掉，不过这个仅适用于Maven项目</li><li>JVM不负责回收直接内存；非堆内存：有很大的数据要存，生命周期又很长。适合频繁的IO操作，比如网络并发。(ByteBuffer，allocateDirect)</li><li>数据库分页很重要</li><li>Eclipse直接启动有时候不容易成功，需要update一下，或者做Clean Project，对于Tomcat Server也要clean</li><li>针对项目，tomcat可能要修改Augument</li><li>Java项目中会有类似名字为app.properties保存数据库连接</li><li>Websphere和Jenkins: <ol><li>Jenkins中对要Deploy的Project进行Build然后下载</li><li>在WebSphere中Applications-&gt;All Applications -&gt; Manage Modules -&gt; update WAR包</li><li>一路点next</li><li>在WebSphere中start并且refresh</li></ol></li><li>JS有Strict mode，比如说只有声明后的变量才能够使用</li><li>JPA创建时需要强制类型转换（泛型）</li><li>java.lang.NoClassDefFoundError一般可能是jar包结构产生的变化</li><li>JPA用的是建造者模式</li><li>type.equals(“one”)要写成 “one”.equals(type)</li><li>SLF4J是日志专用API</li><li>遇到java.lang.ClassNotFoundException:<ol><li>properties</li><li>Deployment Assembly</li><li>Add - java BuildPath entities</li><li>Maven Dependencies</li></ol></li><li>Java的PDF generation:<ol><li>Apache FOP: standard XSL-FO file format</li><li>JAXB: Java Architecture for XML Binding</li><li>XSLT transform</li><li>Marshalling - Convert a Java object into a XML file</li><li>Unmarshalling - Convert XML content into a Java Object</li><li>JxlsHelper.getInstance().processTemplate(is, os, context)</li></ol></li><li>利用Java的反射可以实现一种test方式专门test POJO，不需要再手动去写很多test cases，而是根据方法的入参类型全自动测试</li><li>写unit test的时候，为了提高private方法的覆盖率，写了反射：用字符串获取方法</li><li>JDBC相关：<ol><li>组件：<ol><li>创建连接：Driven Manage / Java.sql.DriveManager</li><li>JDBC数据源：javax.sql.DataSource</li><li>java.sql.Connection，执行CRUD(增删改查)，基于java.sql.Statement；java.sql.PreparedStatement（多次执行后者高效）。查询返回多行数据 ResultSet</li></ol></li><li>数据库连接：<code>Class.forName(“com.mysql.jdbc.Driver”);</code><br><code>connection con = DriverManager.get(“jdbc: mysql://localhost/“ + ”user=&amp;pass=“);</code></li><li>类型：用封装后的</li><li>驱动程序：<br><code>DriverManage.registerDriver(new org.hsqldb.jdbc.JDBCDriver());</code><br><code>Class.forName(&quot;org.hsqldb.jdbc.JDBCDriver”)</code></li></ol></li><li>存储过程，不同的数据库有点小区别，比较像多条SQL放在一起</li><li>多个Bean对应一个Class时，在XML文件中要用primary key指定一个具体的</li><li>Service Integration: managing multiple suppliers of services AND integrating them to provide a SINGLE business-facing IT organization</li><li>如何check DB连接：<ol><li>在SSH上检查Log，定时执行一些命令运行server</li><li>看DB中的数据，有没有新的数据生成:有下游tracking表，对应也有上游</li><li>看GUI</li></ol></li></ol><h3 id="业务理解"><a href="#业务理解" class="headerlink" title="业务理解"></a>业务理解</h3><p>熟悉业务通常是先看代码，如果完全没有文档也缺乏日志，那么就需要老人带着讲解，不然复杂的逻辑很难看明白。<br>数据库的字段也是需要熟悉的，因为这些字段都是根据业务需要设定的。<br>剩下的就是要充分体会Business到Engineering的转化，无他，唯手熟尔。</p><h3 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h3><p>machine mode (solution space) <code>&lt;-</code> mapping <code>-&gt;</code> model of problem(problem space)</p><ol><li>Everything is an object</li><li>A program is a bunch of objects telling each other what to do by sending messages</li><li>Each object has its own memory made up of other objects</li><li>Every object has a type</li><li>All objects of a particular type can receive the same messages</li><li>An object has an interface</li><li>Is-a VS is-like-a relationships</li></ol><h3 id="JMS相关"><a href="#JMS相关" class="headerlink" title="JMS相关"></a>JMS相关</h3><ol><li>JMS provider: 实现了JMS接口并提供管理和控制功能<br>JMS Client: 用 java 写的一些程序和组件，它们产生和使用消息<br>Messages: JMS client 之间传递的消息的对象<br>Administered objects: 由使用JMS clients的人生成的预先设置好的JMS对象。有两种这样的对象：destination和connection factories</li><li>P2P，每个message只有一个使用者sender和receiver没有时间依赖。每个消息必须由一个使用者成功处理发布、订阅：每个message可以有多个使用者publisher和subscribers在时间上有依赖关系。一个订阅了某一topic的客户，只能使用在它生产订阅之后发布的message，并且subscriber必须一致保持活动状态。</li><li>Messaging本身异步：<ol><li>同步 sub/rec 可以通过调用rec方法实时地从destination提取message</li><li>异步：客户可以为某一个使用者注册一个listener，message listener和event listener</li></ol></li><li>ConnectionFactory: 连接工厂，用来创建连接</li><li>Connection: JMS client到JMS provider连接</li><li>Destination: 消息目的地</li><li>Session: 一个发\收线程</li><li>MessageProducer: 由Session对象创建的用来发送消息的对象</li><li>JMS模型:<ol><li>消息头、属性、消息体</li><li>消息头：消息识别、路由</li><li>属性：<ol><li>应用自己的属性</li><li>消息头中原有一些可选的属性</li><li>JMS Provider需要用到的属性</li></ol></li><li>消息体</li></ol></li><li>同步是client主动收消息</li><li>异步是消息到达时，主动通知客户端。用MessageListener</li><li>P2P模型基于队列；PUB/SUB模型：如何向一个内容节点发布和订阅消息。</li></ol><h3 id="Java-Web后台基本设计模式"><a href="#Java-Web后台基本设计模式" class="headerlink" title="Java Web后台基本设计模式"></a>Java Web后台基本设计模式</h3><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><ol><li><p>JavaBeans: 《Thinking in Java》中指出：JavaBeans本质是一种命名规则，比如 (1) getXxx(), setXxx()，如果是Boolean那么还可以是 isXxx()。(2) Bean中的普通方法不必遵循以上命名规则，不过必须是public的。应用：MVC中的M；《Thinking in Java》：IDE构建工具能够使用反射机制来动态地向组件查询，以找出组件具有的属性和支持事件。组件要有“能够被IDE构建工具侦测其属性和事件”的能力。Java加入反射机制的原因之一就是为了支持JavaBean，Bean可以打包、导入。</p></li><li><p>AOP：面向切面编程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut</span>=<span class="string">"execution(public* *ServiceImpl.*(..))"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">advice-ref</span>=<span class="string">"xxxAdvice"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">order</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>可以指定在探测到满足pointcut条件时，同时要做出什么样的动作。</p><ol start="3"><li>PO(Persistent object): 就是在持久层中直接映射column，@SqlTable(name = “xxx”)</li><li>DAO(Data Access Object): CRUD</li><li>VO(Value Object): 通常就是前端显示的Model，比如xxxEntity</li><li>DTO(Data transfer object): 负责数据传递作用，比如一张表有100个字段，我仅仅需要10个，用DTO而不是PO</li><li>O/R Mapping: Object Relational Mapping</li><li>POJO: Spring提出来的简单的java对象</li><li>Daemon Thread: A daemon thread is a thread that does not prevent the JVM from exiting when the program finishes but the thread is still running. e.g. Garbage Collection</li></ol><h4 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h4><ol><li>Facade模式:<ul><li>首先，Web后台的入口，一般作为Controller部分，通常都是绑定GET、POST方法实现的。可以用Spring之类的Framework亦或是Servlet直接实现。</li><li>这里，即使是后台也有一个类似于“界面”的对象。可以用FACADE(外观)模式(DP 4.5)来实现，其意图即：为子系统中一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li><li>在AbstractFacade中负责生成静态的工厂，工厂提供DAO和Service的构建功能。</li></ul></li><li>Abstract Factory模式:<ul><li>意图：提供一个创建一系列相关或相互依赖对象的<strong>接口</strong>，而无需指定它们具体的类。</li><li>适用性：<ul><li>一个系统要独立于它的产品的创建、组合和表示时</li><li>一个系统要由多个产品系列中的一个来配置时</li><li>当你要强调一系列相关的产品对象的设计以便进行联合使用时</li><li>当你提供一个产品类库，而只想显示它们的接口而不是实现时</li></ul></li><li>实现：<ol><li>将工厂作为Singleton，多个工厂用一个静态的HashMap保存。</li><li>每个Kit仅声明一个创建产品的Interface，真正创建产品的是由ConcreteProduct子类实现的。最常用的是为每一个产品定义一个工厂方法。</li></ol></li></ul></li><li>Dynamic Proxy:<ul><li>工厂可能有多个，每一个工厂的都有很多getXxxService()等功能。我们如果想实现扩展性，比如指定怎样初始化，需不需要做缓存等等，就不能对抽象工厂Hard code。这个时候我们可以交给代理完成，而如果所有的工厂中的产品都满足一致性（初始化都一样），那么我们可以实现动态代理，这样的话当抽象工厂扩展的时候，我们就不必要去将每一个新加入的产品都做很多重复的操作（比如指定初始化方式）</li><li>核心代码：</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">T factory = (T) Proxy.newProxyInstanc</span><br><span class="line">    (ClassUtil.getDefaultClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> Class[] &#123; factoryInterface &#125;,  <span class="comment">//Class&lt;T&gt; factoryInterface</span></span><br><span class="line">    <span class="keyword">new</span> InvocationHandler());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * FactoryInvocationHandler中要实现 InvocationHandler，最重要的就是设定</span></span><br><span class="line"><span class="comment"> * getXxxService()的invoke模式。InvocationHandler实现invoke方法，主要是具体的代理过程</span></span><br><span class="line"><span class="comment"> * 比如Factory Method的具体代理操作</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>动态代理是一种设计模式，主要用来解决任务分派（对象加载）问题，Java自身支持这种机制，使用反射实现。AOP可以用动态代理实现。</p><h4 id="Class加载顺序"><a href="#Class加载顺序" class="headerlink" title="Class加载顺序"></a>Class加载顺序</h4><ol><li>Bootstrap Class Loader: 根，C++实现。JVM启动时 $JAVA_HOME中JRE所有的class</li><li>Extension Class Loader: 加载一些扩展功能</li><li>System Class Loader: 启动参数中指定的jar包，也叫AppClassLoader</li><li>User-Defined Class Loader: 用户继承java的Class Loader后自定义的Loader，在动态代理中可能会自定义Loader</li></ol><h3 id="Spring构建Workflow框架"><a href="#Spring构建Workflow框架" class="headerlink" title="Spring构建Workflow框架"></a>Spring构建Workflow框架</h3><p><strong>关键字</strong>：Spring IoC\DI，消息队列</p><p>我们在基本的业务逻辑中会处理一些Workflow，用Spring和消息队列可以实现异步的Workflow。Spring框架的核心是IoC容器。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><strong>控制反转</strong>(IoC)一种思想，的目的是解耦合(很多设计模式都是这个目的)。基本思想是借助“第三方”实现具有依赖关系的对象之间的解耦。</li></ul><p>也就是说假设有四个对象，A B C D，原本他们是自己控制相互之间的耦合。现在借助IoC，之前的glue code都不需要写了，而是全部将对象之间的控制权交给IoC。</p><p>会有什么变化？</p><ol><li>没有IoC之前，如果A依赖B，那么A在运行在某一点的时候，必须主动创建对象B，或者调用已经创建的B。这时候B的控制权都在B自己手上而A没有，会导致耦合。</li><li>引入IoC之后，这种情况就改变了，当A运行到需要B的时候，因为少了之前的直接联系，IoC容器会主动创建一个对象B注入到对象A需要的地方。</li></ol><p>对象A获得对象B的过程由主动行为变为了被动行为，控制权颠倒，因此成为Inverting of Control。</p><ul><li><strong>依赖注入</strong>(DI)一种设计模式，是将实例变量传入到一个对象中去。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Language</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line">    Haskell haskell;</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Language</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        haskell = <span class="keyword">new</span> Haskell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Language类中用的了Haskell对象，Language类对Haskell有一个依赖。</p><ol><li>如果Haskell的生成方式有变化我们需要修改Haskell的代码。<code>new Haskell(String name)</code></li><li>测试的时候也比较麻烦，比如mock</li></ol><p>改成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Language</span><span class="params">(Haskell haskell)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.haskell = haskell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就可以做依赖注入了。</p><p>Spring中IoC框架使用依赖注入作为实现控制反转的方式，但是控制反转的实现方法不单一种，还有比如说：ServiceLocator。因此这两类东西不能够等同。</p><h4 id="Workflow的实现"><a href="#Workflow的实现" class="headerlink" title="Workflow的实现"></a>Workflow的实现</h4><p>其实Workflow本身的实现就可以借助Spring依赖注入，参考<em>javaworld - use spring to create a simple workflow engine</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>  = <span class="string">''</span> <span class="attr">class</span> = <span class="string">''</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"name"</span> <span class="attr">value</span> = <span class="string">"xxx"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"activities"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span> = <span class="string">"activity1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span> = <span class="string">"activity2"</span>/&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span> = <span class="string">"activity3"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span> = <span class="string">"activity4"</span>/&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"defaultErrorHandler"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span> = <span class="string">"defaultErrorHandler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"processContextClass"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>…<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Activity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doActivities</span><span class="params">()</span></span>;                 <span class="comment">//这里处理workflow</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doActivities</span><span class="params">(Object seedData)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActivities</span><span class="params">(List activities)</span></span>; <span class="comment">//这里会被依赖注入上面四个activity</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">setDefaultErrorHandler</span><span class="params">(…)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息队列通信"><a href="#消息队列通信" class="headerlink" title="消息队列通信"></a>消息队列通信</h4><p>使用消息队列进行通信可以极大的扩充workflow的能力。同样通过Spring的IoC容器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">"…"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"name"</span> <span class="attr">value</span> = <span class="string">"…"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"queueName"</span> <span class="attr">value</span> = <span class="string">"…"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也就是每一个activity都是通过queue去进行通信。可以设计为当前的activity执行完毕后才进入下一个，然后开启多条线程等待message的到来后进入下一个处理阶段。</p><h4 id="消息队列通信实现"><a href="#消息队列通信实现" class="headerlink" title="消息队列通信实现"></a>消息队列通信实现</h4><p>有一个入口启动startProcessing()，startProcessing的功能是初始化，和启动监听入口。初始化主要功能就是注册消息队列。</p><p>监听入口的启动，通常是一个无限循环，这个循环不断的轮询消息队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop;</span><br><span class="line"></span><br><span class="line"><span class="comment">//field for multi-threading</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> keepAlive = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">        Message message = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            message = processor.getMessage();</span><br><span class="line">            <span class="keyword">if</span>(message != <span class="keyword">null</span>)&#123;</span><br><span class="line">                processor.processMessage(message);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//sleep for a second</span></span><br><span class="line">            &#125; <span class="keyword">catch</span>(…)&#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!keepAlive)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多线程监听"><a href="#多线程监听" class="headerlink" title="多线程监听"></a>多线程监听</h4><p>这个跟IoC的关系就不是特别大了，主要是消息队列通信多线程的优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">multiThreadProcessing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    executor = Executors.newScheduledThreadPool(threadCount, <span class="keyword">new</span> MessageProcessorThreadFactory());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        executor.scheduleAtFixedRate(</span><br><span class="line">                    <span class="keyword">new</span> MessageProcessThread(),</span><br><span class="line">                    initialDelay,</span><br><span class="line">                    schedulePeriodInSeconds,</span><br><span class="line">                    TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProcessThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        listener();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProcessorThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> AtomicInteger currentThreadCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable command)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(command, getName() + <span class="string">"-"</span> + currentThreadCount.addAndGet(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他更多的架构相关内容，参考<a href="https://izhen.me/2018/12/18/starbucks/">这里</a>。</p><h2 id="编译器相关"><a href="#编译器相关" class="headerlink" title="编译器相关"></a>编译器相关</h2><h3 id="文档，环境-1"><a href="#文档，环境-1" class="headerlink" title="文档，环境"></a>文档，环境</h3><p>国内做编译器的相比于Web要匮乏太多，没有很多现成的内容。尤其是华为的编译器又非常的特殊，有一套自己的中间表达。源语言也不是通用的高级语言。</p><ol><li>论文、官方接口文档、Mailing list。多看一手资料</li><li>C++项目的环境一般都是本地编译并本地执行，部署方式不同于Web项目</li></ol><h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><p>这里能说的要说多非常多，因为编译器的规模都巨大，也需要大量<strong>造轮子</strong>。但是呢要说少也少，因为很多技术太过于专了，说不说也罢。主要工作语言从Java转到了C++，从API工程师变成了从零开始徒手撸。</p><ol><li>设计模式与Web项目会有很大不同，这里访问者模式、建造者模式更常用</li><li>因为属于Infrastructure领域，很多<a href="https://izhen.me/2019/04/22/invoke-dynamic/">特性</a>是从零自主实现的，没有现成的第三方类库。实现一个新的特性就是从原始论文翻译成代码的。项目已经<a href="https://www.openarkcompiler.cn/home" target="_blank" rel="noopener">开源</a>了，可以去下载来看看</li><li>比Web的业务逻辑更纯粹，面临的问题更偏向纯技术纯理论，束手束脚的条条框框少</li><li>编译器领域的很多开发与学术界联系密切，一般一个成熟的小组的主力军都是博士、教授、资深技术专家组成</li><li>研究的内容更多，所以会有很多理论计算机的内容，这与Web开发有比较大的差异。相比于我上一份工作，这里更强调的是核心算法实现、解决痛点问题、顶层的设计等，做的东西更大</li><li>Citi的技术分享更多的是员工自己分享经验，能在工程细节上得到不错的启发；在华为更多请行业专家和教授讲解学术性的内容，离工程细节远</li><li>对比Web开发，能感觉到在国内这个领域远不如Web开发成熟。相当的内容都是摸着石头过河，没有特别繁琐的框架规则，都是直击问题要害，也容易造成代码不讲究，到处乱飞的现象，不知道是工作领域的原因还是国内外公司的差异。感觉代码的正规化不如上一家公司，但是技术含量要高很多</li><li>前中后端、解释器、Runtime之间的技术差异很大。当前我是在前端工作，对于语法、类型分析和IR的接触较多，对于垃圾回收、优化和后端的接触较少</li><li>闭包、lambda、匿名内部类的概念会有运用；Java 8中含有Single Abstract Method的lambda语法糖</li><li>Java 8之后，引入Stream API，list comprehension实现在stream抽象内</li><li>工作涉密，不方便在公共场所交流细节</li><li>编译器高手 == 字符串拼接大师（哈哈，开个玩笑）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工程师与程序录入员的区别就是工程师不仅仅只做编码工作。当然编码是最基础的，除此外还有诸如部署、Support、解决方案提供等「杂活」。曾经我觉得除了编码都是不务正业浪费时间，现在我开始慢慢的去改变这一观点并慢慢去做好很多细节。举个例子，我刚来工作的时候，连Eclipse也用不好，毕竟学生时代用Vim什么的就足够了。&lt;/p&gt;
&lt;p&gt;我在刚刚工作时一直希望能够得到一篇弥补象牙塔与真正工业界之间GAP的指导，奈何都不是我特别需要的，所以这里撰文一篇，记录我自己的一些技术所需。因为业务涉密，所以不列举具体业务内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="Java" scheme="http://izhen.me/tags/Java/"/>
    
      <category term="JavaScript" scheme="http://izhen.me/tags/JavaScript/"/>
    
      <category term="Framework" scheme="http://izhen.me/tags/Framework/"/>
    
      <category term="Infra" scheme="http://izhen.me/tags/Infra/"/>
    
      <category term="菜鸟工程师" scheme="http://izhen.me/tags/%E8%8F%9C%E9%B8%9F%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 72 - Edit Distance</title>
    <link href="http://izhen.me/2019/11/10/dp_edit_dis/"/>
    <id>http://izhen.me/2019/11/10/dp_edit_dis/</id>
    <published>2019-11-09T16:03:00.000Z</published>
    <updated>2019-11-10T10:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>我自打工作后从来没有在工作中用到过竞赛算法，直到我参与了编译器开发后一些辅助性质的工作中使上了动态规划，其一就是针对某种字符串做相似度检验时随手写了个LCS，另外一个就是编辑距离了。</p><a id="more"></a><h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>思想跟LCS很想，只不过要处理下述三种情况，具体参考程序源码：</p><ol><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ol><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def minDistance(self, word1: str, word2: str) -&gt; int:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word1 <span class="keyword">or</span> <span class="keyword">not</span> word2:</span><br><span class="line">            <span class="keyword">return</span> len(word1) + len(word2)</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">-1</span> <span class="keyword">for</span> _ in range(len(word2))] <span class="keyword">for</span> _ in range(len(word1))]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i in range(len(word1)):</span><br><span class="line">            <span class="keyword">for</span> j in range(len(word2)):</span><br><span class="line">                a1 = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (word1[i] != word2[j]) \</span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span> <span class="keyword">else</span> i + j + (word1[i] != word2[j])</span><br><span class="line">                a2 = dp[i - <span class="number">1</span>][j] + <span class="number">1</span> <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">else</span> j + <span class="number">2</span></span><br><span class="line">                a3 = dp[i][j - <span class="number">1</span>] + <span class="number">1</span> <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">else</span> i + <span class="number">2</span></span><br><span class="line">                dp[i][j] = min(a1, a2, a3) </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[len(word1) - <span class="number">1</span>][len(word2) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我自打工作后从来没有在工作中用到过竞赛算法，直到我参与了编译器开发后一些辅助性质的工作中使上了动态规划，其一就是针对某种字符串做相似度检验时随手写了个LCS，另外一个就是编辑距离了。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="DP" scheme="http://izhen.me/tags/DP/"/>
    
      <category term="动态规划" scheme="http://izhen.me/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="编辑距离" scheme="http://izhen.me/tags/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>图上的动态规划</title>
    <link href="http://izhen.me/2019/11/10/dp_graph/"/>
    <id>http://izhen.me/2019/11/10/dp_graph/</id>
    <published>2019-11-09T16:02:00.000Z</published>
    <updated>2019-11-10T10:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>陶陶假期的时候独自去天津玩，出发前他想制定一个旅行计划。假设天津有N个景点，陶陶给每个景点定义了一个开心值Si，也就是说当他游玩这个景点后他的总开心值会加Si，同时，游玩第i个景点会花费Ci的时间。由于没有基友陪，所以他想在限定的时间T内，从起始点S，有选择的游览一些景点，最后到达终点E。当然他想让这次旅行所得的开心值最大。</p><a id="more"></a><p>注意，陶陶可以为了走近路而只是路过一些景点，不去游玩（包括S和E）。而且他有一个怪癖就是要去玩的下一个景点的开心值一定要大于之前玩的景点（例如他游玩景点i获得的开心值为10，那么他游玩的下一个景点的开心值必须大于10）。此外，景点间的路是双向的，路上也要耗费时间，而且各个点之间可能不止一条路，陶陶当然会走最短了啦。</p><p>输入<br>每组测试数据格式如下：<br>第一行包括5个整数：N M T S E。N代表景点的数量1&lt;N&lt;100，M代表道路的数量0&lt;M&lt;1000，T代表时间限制0&lt;T&lt;=300，S代表起点，E代表终点，0&lt;=S,E&lt;N。<br>第二行包括N个整数Ci（0&lt;=Ci&lt;=T）,表示游玩景点i所要花费的时间。<br>第三行包括N个整数Si（0&lt;=Si&lt;100）,表示游玩景点i可以得到的开心值。<br>接下来M行，每行包括3个整数u,v,w,表示在u和v间有一条双向路，在路上要耗费w的时间(0&lt;=u,v&lt;N,0&lt;=w&lt;=T)。<br>输出<br>输出一个整数，表示这次旅行可以获得的最大开心值。当然，如果不能再T时间内到达E，只需要输出”0”（没有引号）。</p><h5 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h5><p>输入样例 1<br>4 4 22 0 3<br>1 1 1 1<br>5 7 9 12<br>0 1 10<br>1 3 10<br>0 2 10<br>2 3 10<br>输出样例 1<br>21</p><h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>状态转移方程f[i][j]表示当在第i号景点happy并且还剩j个时间的最大幸福度。<br>因为可以从任何可达的景点走过来，所以在处理状态的时候非常容易brainfuck。<br>本题的实现思想就是状态转移，但是形式上采用队列。每当访问到景点e的时候就更新结果，可以不在终点happy。</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(a,b) (a &lt; b ? a : b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) (a &gt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">105</span>][<span class="number">105</span>], cost[<span class="number">105</span>], value[<span class="number">105</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, time, lastValue, value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, t, s, e;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; t &gt;&gt; s &gt;&gt; e;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; cost[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; value[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">          <span class="keyword">if</span> (i != j) <span class="built_in">map</span>[i][j] = t + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a, b, c;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">      <span class="built_in">map</span>[a][b] = MIN(<span class="built_in">map</span>[a][b], c);</span><br><span class="line">      <span class="built_in">map</span>[b][a] = <span class="built_in">map</span>[a][b];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// floyd</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] &gt; <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j])</span><br><span class="line">                  <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">map</span>[s][e] &gt; t) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">      Node temp;</span><br><span class="line">      temp.pos = s, temp.time = t, temp.lastValue = <span class="number">-1</span>, temp.value = <span class="number">0</span>;</span><br><span class="line">      q.push(temp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">          Node head = q.front();</span><br><span class="line">          q.pop();</span><br><span class="line">          <span class="keyword">int</span> pos = head.pos;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">              <span class="keyword">if</span>(i == e &amp;&amp; (head.time - <span class="built_in">map</span>[pos][i] &gt;= <span class="number">0</span>)) ans = MAX(ans, head.value);</span><br><span class="line">              <span class="keyword">if</span> (value[i] &gt; head.lastValue) &#123;</span><br><span class="line">                  Node temp;</span><br><span class="line">                  <span class="keyword">int</span> time = head.time - <span class="built_in">map</span>[pos][i] - cost[i];</span><br><span class="line">                  <span class="keyword">if</span> (time &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                      temp.pos = i;</span><br><span class="line">                      temp.lastValue = value[i];</span><br><span class="line">                      temp.value = head.value + value[i];</span><br><span class="line">                      temp.time = time;</span><br><span class="line">                      q.push(temp);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;陶陶假期的时候独自去天津玩，出发前他想制定一个旅行计划。假设天津有N个景点，陶陶给每个景点定义了一个开心值Si，也就是说当他游玩这个景点后他的总开心值会加Si，同时，游玩第i个景点会花费Ci的时间。由于没有基友陪，所以他想在限定的时间T内，从起始点S，有选择的游览一些景点，最后到达终点E。当然他想让这次旅行所得的开心值最大。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="DP" scheme="http://izhen.me/tags/DP/"/>
    
      <category term="动态规划" scheme="http://izhen.me/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="图" scheme="http://izhen.me/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>斜率优化动态规划</title>
    <link href="http://izhen.me/2019/11/10/dp_xielvyouhua/"/>
    <id>http://izhen.me/2019/11/10/dp_xielvyouhua/</id>
    <published>2019-11-09T16:01:00.000Z</published>
    <updated>2019-11-10T10:37:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一条直线上有n处地方，从左到右依次编号为1, 2, …, n，每处地方都有一定量的煤，每处地方的单位量煤运送单位距离都需要一定的费用，例如在1处有数量为a的煤，单位量的煤运送单位距离的费用是b，那么把这么多煤一共运送c的距离所需要的费用为a<em>b</em>c。现在需要把这n处地方的煤送往加工中心处理，为了使得路径单一，所有地方的煤只能向右边（编号较大的地方的方向）运送，已知第n处的地方已经存在了一个加工中心。为了减少煤运送的费用，在这条路径上最多可以添加k个加工中心，使得总运费最少。问最小的运费是多少？(CEOI 2004改编)</p><a id="more"></a><p>输入<br>输入数据一共包括4行，第1行输入n和k(2&lt;=n&lt;=10000, 1&lt;=k&lt;=min(200, n-1))，表示n处地方，最多添加k个加工中心。第2行输入n个正整数，表示每个地方的煤总量，第3行输入n个正整数，表示每个地方单位数量单位距离运送的费用。第4行输入n-1个正整数，表示从左到右相邻两个地方的距离。除n以外，所有的数字都&lt;=300。<br>输出<br>输出一行一个整数，表示最小的运费。</p><h5 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h5><p>输入样例 1<br>3 1<br>1 2 3<br>3 2 1<br>2 2<br>输出样例 1<br>6</p><h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>首先我们想到这是一道DP题目，方程为：dp[k][n] = min{0 &lt;= i &lt; n} (dp[k - 1][i] + delta(i + 1, n)) 其中delta(i + 1, n)表示为从i + 1到n的所有树木运送到第n号节点的耗费总和。加工厂肯定建在节点上最节约。</p><p>但是这样做面对较大数据会超时，所以我们需要优化。优化的推导模式参考<a href="https://www.jianshu.com/p/f9fb15246e14" target="_blank" rel="noopener">这里</a>。</p><p>这里能够发现一个单调递增的规律，也就是转移方程对于树木运送代价具有单调性，因而可以采用斜率优化。</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(a, b) (a &lt; b ? a : b) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> k, n, value[<span class="number">10005</span>], dist[<span class="number">10005</span>], f[<span class="number">10005</span>][<span class="number">205</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">DeltaY</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> s, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f[p][o] - f[p][<span class="number">0</span>] + value[p] * dist[p]) - (f[s][o] - f[s][<span class="number">0</span>] + value[s] * dist[s]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">DeltaX</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value[p] - value[s];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; value[i];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; value[<span class="number">10004</span>];</span><br><span class="line">     value[i] = value[<span class="number">10004</span>] * value[i] + value[i - <span class="number">1</span>];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; dist[i];</span><br><span class="line">     dist[i] += dist[i - <span class="number">1</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">         f[i][<span class="number">0</span>] += (value[j] - value[j - <span class="number">1</span>]) * (dist[i] - dist[j]);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= k + <span class="number">1</span>; s++) &#123;</span><br><span class="line">     <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q(n + <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= n; i++) &#123;</span><br><span class="line">         <span class="keyword">int</span> o = s - <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(head &lt; tail &amp;&amp; DeltaY(q[head + <span class="number">1</span>], q[head], o) &lt;= DeltaX(q[head + <span class="number">1</span>], q[head]) * dist[i])</span><br><span class="line">             head++;</span><br><span class="line">         f[i][s] = f[q[head]][o] + f[i][<span class="number">0</span>] - f[q[head]][<span class="number">0</span>] - value[q[head]] * (dist[i] - dist[q[head]]);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span>(head &lt; tail &amp;&amp; DeltaY(i, q[tail], o) * DeltaX(q[tail], q[tail - <span class="number">1</span>]) &lt;= DeltaY(q[tail], q[tail - <span class="number">1</span>], o) * DeltaX(i, q[tail]))</span><br><span class="line">             tail--;</span><br><span class="line"></span><br><span class="line">         q[++tail] = i;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; f[n][k] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在一条直线上有n处地方，从左到右依次编号为1, 2, …, n，每处地方都有一定量的煤，每处地方的单位量煤运送单位距离都需要一定的费用，例如在1处有数量为a的煤，单位量的煤运送单位距离的费用是b，那么把这么多煤一共运送c的距离所需要的费用为a&lt;em&gt;b&lt;/em&gt;c。现在需要把这n处地方的煤送往加工中心处理，为了使得路径单一，所有地方的煤只能向右边（编号较大的地方的方向）运送，已知第n处的地方已经存在了一个加工中心。为了减少煤运送的费用，在这条路径上最多可以添加k个加工中心，使得总运费最少。问最小的运费是多少？(CEOI 2004改编)&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="DP" scheme="http://izhen.me/tags/DP/"/>
    
      <category term="动态规划" scheme="http://izhen.me/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="斜率优化" scheme="http://izhen.me/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++ STL中平衡树在算法题目的应用</title>
    <link href="http://izhen.me/2019/11/10/stl_balancetree/"/>
    <id>http://izhen.me/2019/11/10/stl_balancetree/</id>
    <published>2019-11-09T16:00:01.000Z</published>
    <updated>2019-11-10T10:50:35.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述•其一"><a href="#题目描述•其一" class="headerlink" title="题目描述•其一"></a>题目描述•其一</h4><p>给定一个长度为n的数组s，数组s的子串s[i,j]表示s[i],s[i+1],s[i+2]……s[j]。求最大长度的子串，该子串必须满足：m1&lt;=max(s[i],s[i+1]……s[j])-min(s[i],s[i+1]……s[j])&lt;=m2。如果最大长度的子串有多个，请找出子串和最大的那个。对于子串[i,j]，子串和指的是sum(s)=s[i]+s[i+1]+s[i+2]+……s[j]，子串长度指的是length=j-i+1。如果没有子串满足，请输出”0 0”。</p><a id="more"></a><h5 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h5><p>第一行为三个整数n, m1, m2。第二行为n个整数，从左到右依次为s[1],s[2]……s[n]<br>输入样例 1<br>3 0 0<br>1 1 1<br>输出样例 1<br>3 3</p><h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>假设，我们已经有一组数字，我们继续添加数字时：当前这组数字的max-min要么增大，要么不变。而删除数字时，要么变小，要么不变（想想为什么）。可以用双指针来完成这个搜索的操作。</p><p>算法具体实现时，我们只要让l从1循环到n，r不断的向右跑以满足要求就可以了。求一堆数的最小最大值，并可以进行插入删除操作。这一部分用任意一种二叉搜索树就可以完成，比如红黑树。</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (a &gt; b ? a : b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(a, b) (a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> n, m1, m2, num[<span class="number">100005</span>], sum[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">long</span> a, b;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">long</span>, less&lt;<span class="keyword">long</span>&gt;&gt; subarr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        sum[i] = num[i] + sum[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subarr.insert(num[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (l &lt;= n &amp;&amp; r &lt;= n &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">long</span> ans = *(--subarr.end()) - *subarr.begin();</span><br><span class="line">        <span class="keyword">if</span> (m1 &lt;= ans &amp;&amp; ans &lt;= m2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; a) &#123;</span><br><span class="line">                a = r - l + <span class="number">1</span>;</span><br><span class="line">                b = sum[r] - sum[l - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r - l + <span class="number">1</span> == a) &#123;</span><br><span class="line">                b = MAX(b, sum[r] - sum[l - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            subarr.insert(num[++r]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ans &gt; m2) &#123;</span><br><span class="line">            subarr.erase(subarr.find(num[l++]));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; m1) &#123;</span><br><span class="line">            subarr.insert(num[++r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">' '</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目描述•其二"><a href="#题目描述•其二" class="headerlink" title="题目描述•其二"></a>题目描述•其二</h4><p>设B = {b1, b2, …, bn} 和 W = {w1, w2, …, wn}分别为平面上黑点和白点的两个集合。一黑点bi = (xi, yi) 与一白点wj = (xj, yj) 匹配当且仅当 xi &lt;= xj 和 yi &lt;= yj 同时成立，每个点最多只能用于一次匹配，请找出黑白点之间的最大匹配数目。</p><ul><li>黑点和白点各自的数量均不超过100000;</li><li>平面为(0, 0)到(10000, 10000)的矩形中的整数点</li><li>黑点白点坐标可能相同，B集合、W集合中也可能包含相同的元素</li></ul><p>输入的第一行包括一个整数T (1 &lt;= T &lt;= 10)，表示有T组测试数据.<br>对于每组测试数据：<br>第一行两个整数，n(黑点个数) m(白点个数)，0 &lt; n, m &lt;= 100000<br>接下来n行每行有两个整数并用空格隔开：<br>黑点的横坐标x 黑点的纵坐标y<br>再接下来m行每行有两个整数同样用空格隔开：<br>白点的横坐标x 白点的纵坐标y</p><p>输出<br>对于每组测试数据，输出一行一个整数，表示最大匹配数。</p><h5 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h5><p>输入样例 1<br>2<br>2 2<br>1 0<br>0 1<br>1 1<br>0 0<br>1 1<br>1 1<br>0 0<br>输出样例 1<br>1<br>0</p><h4 id="题目解答-1"><a href="#题目解答-1" class="headerlink" title="题目解答"></a>题目解答</h4><p><strong>思路上可能有点贪心的思想</strong>，假设问题是一维的，对所有黑点白点做离散化，然后从小到大扫描。因为白点总要大于等于黑点才可以匹配，所以每当我们扫描到一个白点时，将离他最近的黑点匹配到一起。</p><p>二维的情况就需要维护一个查找，这个查找每次能将Y轴最近的黑点与白点匹配。</p><p>离散化的时候注意x轴坐标相等就排序Y轴，x与y均相等，要把白点坐标排在后面。</p><h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">bool</span> black;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> f = a.x &lt; b.x;</span><br><span class="line">        <span class="keyword">if</span> (a.x == b.x) &#123;</span><br><span class="line">            f = a.y &lt; b.y;</span><br><span class="line">            <span class="keyword">if</span> (a.y == b.y) &#123;</span><br><span class="line">                f = a.black;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; tree;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; bw(n + m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Node d;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; d.x &gt;&gt; d.y;</span><br><span class="line">            d.black = <span class="literal">true</span>;</span><br><span class="line">            bw[i] = d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Node d;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; d.x &gt;&gt; d.y;</span><br><span class="line">            d.black = <span class="literal">false</span>;</span><br><span class="line">            bw[n + i] = d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(bw.begin(), bw.end(), Node());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m;i++) &#123;</span><br><span class="line">            Node &amp;d = bw[i];</span><br><span class="line">            <span class="keyword">if</span> (d.black) &#123;</span><br><span class="line">                tree.insert(d.y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator lower = tree.lower_bound(d.y);</span><br><span class="line">                <span class="keyword">if</span>(lower != tree.end() &amp;&amp; *lower &lt;= d.y) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    tree.erase(lower);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述•其一&quot;&gt;&lt;a href=&quot;#题目描述•其一&quot; class=&quot;headerlink&quot; title=&quot;题目描述•其一&quot;&gt;&lt;/a&gt;题目描述•其一&lt;/h4&gt;&lt;p&gt;给定一个长度为n的数组s，数组s的子串s[i,j]表示s[i],s[i+1],s[i+2]……s[j]。求最大长度的子串，该子串必须满足：m1&amp;lt;=max(s[i],s[i+1]……s[j])-min(s[i],s[i+1]……s[j])&amp;lt;=m2。如果最大长度的子串有多个，请找出子串和最大的那个。对于子串[i,j]，子串和指的是sum(s)=s[i]+s[i+1]+s[i+2]+……s[j]，子串长度指的是length=j-i+1。如果没有子串满足，请输出”0 0”。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="平衡树" scheme="http://izhen.me/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="STL" scheme="http://izhen.me/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>LRU Cache 与 LFU Cache</title>
    <link href="http://izhen.me/2019/09/01/lru_lfu/"/>
    <id>http://izhen.me/2019/09/01/lru_lfu/</id>
    <published>2019-08-31T16:21:00.000Z</published>
    <updated>2019-09-01T08:23:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>浅谈一下缓存中的LRU与LFU策略，针对<code>get(key)</code>和<code>put(key,value)</code>两个接口实现任何操作时间复杂度O(1)的数据结构。</p><a id="more"></a><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>我们维护一个队列，这个队列永远把最近插入/使用的放在顶端，最小最近使用的放在底端。对于put方法要么更新已有的值，要么新加入一个值，无论更新还是新插入都要放在顶端，如果当前队列已满并且还需要插入新值，则删除底端的值后再插入新的值。对于get方法，要么没找到返回-1，要么返回查询结果，并把这个值放在顶端。</p><p>上述策略可以满足LRU，但是如何保证操作都是O(1)呢？我们比较耗时的操作是在挪动value的位置，比如更新一个value后，要将其放在队列的顶端。如果是一般的Array存储，那么时间复杂度是O(n)，所以我们选择双向链表。但是这样一来查找的复杂度就变成O(n)了，我们只需要用hashmap辅助，hashmap的value记录每个链表结点的引用即可。</p><p>这样删除的时候，直接删除尾指针指向的结点，并删除hashmap中的pair。在挪动结点的时候是不必更新hashmap的，因为hashmap存储的是引用而非绝对位置。</p><p><img src="/image/lru.jpg" alt="图示为key是3, 4, 8的情况"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Leetcode 146</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key: int, value: int)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.pre = <span class="keyword">None</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.cap = capacity</span><br><span class="line">        self.linkedMap = &#123;&#125;</span><br><span class="line">        self.head = Node(<span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line">        self.tail = Node(<span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.pre = self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.linkedMap:</span><br><span class="line">            node = self.linkedMap[key]</span><br><span class="line">            self._remove(node)</span><br><span class="line">            self._add(node)</span><br><span class="line">            <span class="keyword">return</span> node.value</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.linkedMap:</span><br><span class="line">            self._remove(self.linkedMap[key])</span><br><span class="line">        <span class="keyword">elif</span> len(self.linkedMap) + <span class="number">1</span> &gt; self.cap:</span><br><span class="line">            self._remove(self.tail.pre)</span><br><span class="line">        self._add(Node(key, value))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_remove</span><span class="params">(self, node: Node)</span>:</span></span><br><span class="line">        node.pre.next = node.next</span><br><span class="line">        node.next.pre = node.pre</span><br><span class="line">        self.linkedMap.pop(node.key)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add</span><span class="params">(self, node: Node)</span>:</span></span><br><span class="line">        node.next = self.head.next</span><br><span class="line">        node.pre = self.head</span><br><span class="line">        self.head.next.pre = node</span><br><span class="line">        self.head.next = node</span><br><span class="line">        self.linkedMap[node.key] = node</span><br></pre></td></tr></table></figure><h4 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h4><p>与LRU一样要用双向链表存储结点，针对每一个频率都用一个单独的链表存储，不同的频率链表之间按顺序首尾相连，逻辑上可以看作链表的链表。新加入的value都要放入频率为1的链表的表头，这是初始情况。当更新一个结点时，比如频率3的被get了一次，那么要把他从频率3的链表拿出来放入频率4的链表的表头，这样put和get的更新操作都是O(1)的复杂度。</p><p>删除的时候，我们都从频率最小的链表的末尾开始删除，也就是tail指针始终指向当前频率最小的链表的末尾，tail指针的维护时间复杂度也是O(1)的。（为了实现方便，我这部分不是严格O(1)的）</p><p>同样用hashmap保存key到node的映射，这一点和LRU是一致的。</p><p><img src="/image/lfu.jpg" alt="图示为存在1,2,3三种频率的情况"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Leetcode 460</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k, v)</span>:</span></span><br><span class="line">        self.key = k</span><br><span class="line">        self.value = v</span><br><span class="line">        self.freq = <span class="number">0</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.cap = capacity</span><br><span class="line">        self.freqHead = &#123;&#125;</span><br><span class="line">        self.freqTail = &#123;&#125;</span><br><span class="line">        self.keyMap = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.keyMap:</span><br><span class="line">            node = self.keyMap[key]</span><br><span class="line">            ans = node.value</span><br><span class="line">            self._update(node)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_print</span><span class="params">(self, tail)</span>:</span></span><br><span class="line">        x = []</span><br><span class="line">        <span class="keyword">while</span> tail:</span><br><span class="line">            x.append(tail.value)</span><br><span class="line">            tail = tail.prev</span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.cap == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.keyMap:</span><br><span class="line">            self.keyMap[key].value = value</span><br><span class="line">            self._update(self.keyMap[key])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> len(self.keyMap) == self.cap:</span><br><span class="line">            self._removeTail()</span><br><span class="line">    </span><br><span class="line">        node = Node(key, value)</span><br><span class="line">        node.freq = <span class="number">1</span></span><br><span class="line">        self._addFreq(node.freq, node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        key, value, freq = node.key, node.value, node.freq</span><br><span class="line">        self._remove(node)</span><br><span class="line">        self._addFreq(freq + <span class="number">1</span>, Node(key, value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_removeTail</span><span class="params">(self)</span>:</span> <span class="comment"># 这部分我偷懒了，可以优化到严格的O(1)操作</span></span><br><span class="line">        tail = self.freqTail[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> tail <span class="keyword">and</span> tail.key == <span class="number">-1</span>:</span><br><span class="line">            tail = tail.prev</span><br><span class="line">        self._remove(tail)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_addFreq</span><span class="params">(self, freq, node)</span>:</span></span><br><span class="line">        head = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> freq <span class="keyword">in</span> self.freqHead:</span><br><span class="line">            head = self.freqHead[freq]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head = Node(<span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line">            tail = Node(<span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line">            head.next = tail</span><br><span class="line">            tail.prev = head</span><br><span class="line">            <span class="keyword">if</span> freq &gt; <span class="number">1</span>:</span><br><span class="line">                tail.next = self.freqHead[freq - <span class="number">1</span>]</span><br><span class="line">                tail.next.prev = tail</span><br><span class="line">            self.freqHead[freq] = head</span><br><span class="line">            self.freqTail[freq] = tail</span><br><span class="line">        self._add(node, head)</span><br><span class="line">        node.freq = freq</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_remove</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        node.prev.next = node.next</span><br><span class="line">        node.next.prev = node.prev</span><br><span class="line">        self.keyMap.pop(node.key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add</span><span class="params">(self, node, head)</span>:</span></span><br><span class="line">        node.next = head.next</span><br><span class="line">        node.prev = head</span><br><span class="line">        head.next.prev = node</span><br><span class="line">        head.next = node</span><br><span class="line">        self.keyMap[node.key] = node</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>某单一类型的数据结构不足以支撑当前的需求时，可以使用多种数据结构组合完成任务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浅谈一下缓存中的LRU与LFU策略，针对&lt;code&gt;get(key)&lt;/code&gt;和&lt;code&gt;put(key,value)&lt;/code&gt;两个接口实现任何操作时间复杂度O(1)的数据结构。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="hashmap" scheme="http://izhen.me/tags/hashmap/"/>
    
      <category term="linked list" scheme="http://izhen.me/tags/linked-list/"/>
    
      <category term="dict" scheme="http://izhen.me/tags/dict/"/>
    
      <category term="lru" scheme="http://izhen.me/tags/lru/"/>
    
      <category term="lfu" scheme="http://izhen.me/tags/lfu/"/>
    
      <category term="cahce" scheme="http://izhen.me/tags/cahce/"/>
    
  </entry>
  
  <entry>
    <title>我的故事 -- 创建小组篇</title>
    <link href="http://izhen.me/2019/08/24/mystory2/"/>
    <id>http://izhen.me/2019/08/24/mystory2/</id>
    <published>2019-08-23T16:21:00.000Z</published>
    <updated>2019-08-23T14:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>一组织小伙伴们一同玩耍的带头者。</p><p>一第一次创建小组起始于小学。那时的数学老师鼓励我们志同道合的朋友在一起学习进步。我以学习数学、计算机为目的拉进来很多人。有点像组阁，还为每个人安插了头衔。时至今日，我连自己的头衔都忘了，却依稀记得那时一位数学很好的同学被安排为网络管理员，有一回我去图书大厦还碰到他买关于网管的书籍：）</p><a id="more"></a><p>这个小组在一起做的事情嘛，我记不太清楚了。只是有一回我因为读《福尔摩斯》受到了启发，便开始设计凯撒密码，用了一些自己发明的字符，设计好后还要求组内成员背诵。结果大家都开玩笑的说：在这一点上不志同道合了(^_^)。依稀记得用的是红色的笔，白色的纸条……</p><p>那时小学订阅《中国少年报》、《小哥白尼》、《迪斯尼》、《儿童文学》之类的杂志，最爱《中少报》的游戏栏目，特别是拿到了暑假合刊时先翻阅里面的游戏栏目。CS、樱花大战、GBA都是童年梦想。当自己有机会玩这些游戏时，比如大富翁4，CS1.6，红警，帝国时代2，恰恰都是和小组内的这些个小伙伴一起创造了共同回忆。</p><p>因为那时对宇宙星空的兴趣，第一个小组名为「天狼星」</p><p><img src="/image/tianlangxing.JPG" alt="天狼星小组"></p><p>小学毕业后《掌机迷》、《掌机王》和对PSP的憧憬也都是在这些小伙伴的陪伴下慢慢品味的。</p><p>一上了初中，我这个爱好依旧，于是和玩得最好的几个朋友加上「老大」组建了「四人帮」。也就是平常关系好，这个四人帮没太大影响力。</p><p>上信息技术课的时候，我把这个四人帮扩大了，同时像小学一样有个名字「奇幻天龙」。我们一起做各种有创意的作品，一部PPT，一部海报都收获了微小的奖励。课后也会同组内成员一起搭838路公交车回家，路上不忘顺手买一本《大众软件》。</p><p>后来影响越来越大，我们逐渐扩张到十个人，名为「十人帮」。在那个还未曾听说过社团的年代，这或许就是代表了。对于初中生来说这个团体有点大，我还专门设计了一份全部由信息学奥赛初赛题组成填空选择的试卷作为入会门槛。</p><p><img src="/image/test.JPG" alt="测试题目"></p><p>十个人，十种毒品作为代号，我只记得自己是海洛因，老大是大麻。排位是根据生日大小来的，老大只是称呼并不是这个团队的老大。平常吃饭要排队去食堂，吃完了饭回教室还要喊一句，「我们十人帮回来了」!有一回上语文课，老师恰好叫到了我和帮内成员回答问题，有位同学说，怎么都是十人帮的。语文老师听见了，惊讶的问，咱们班还有帮会？我赶忙解释，就是个同好会，名字取成了这样而已^_^</p><p>俗话说，天下大势分久必合，合久必分。也许是班级内其他势力兴起，又或者这个团体没太多实事，最终难逃土崩瓦解的命运。日后，也成就了史上规模最大，延续时间最长，最具影响力的帮会。</p><p>解散后，我和另外两位原团员组成了金刚铁三角继续活动。他们也成为了我日后最好的朋友。</p><p>一高中班里学霸多，大家都忙于在课业上用功。也有和我一样偶尔忙里偷闲的类型，所以我把我设计的一套组织架构给他看后得到了很积极的回应。这套架构也是对于初中的改进，加入了等级体系，有点像海军的军衔。但是我这里貌似叫「5级青龙」、「3级白虎」之类的中二名字，因为恰巧同期迷上了古代四象。</p><p>那句「你要是建组，我绝对加入」最终也成为了遗憾。</p><p>一大学，最后一个实质意义上的小组<a href="http://blog.sina.com.cn/u/2536528482" target="_blank" rel="noopener">5thPlanet</a>，为创新大赛筹建的。还记得我们几个小伙伴奋战通宵，到处发传单进行用户体验调查，也到处吃闭门羹的凄凉，在KFC吃饭还差点被赶走的落魄XD。上台进行Demo时还穿上了正装，只可惜演讲不是很成功，所以我们没能将这个项目继续下去。也不失为一段有趣的体验吧～</p><p>团队名称：5thPlanet<br>队长：甄羿<br>团队成员：赵一然 钟王偲 段沛宸 李亦卿</p><p>首席设计师：甄羿<br>首席技术官：钟王偲<br>首席媒体架构官：赵一然<br>首席运营官：李亦卿<br>首席推销官：段沛宸</p><p>简要介绍及引言：我们团队全部来自大一，虽然都是新手，可是却对未来的交互有自己的见解。首先更加贴近人类的生活习惯，手势更优于「命令行」（命令行在其他某些方面很重要），语音更加方便。而且未来的交互不应只局限于UI层面，我想人人对于未来交互的构想一定能想得都很酷。可是更深层次的，我们或许更需要一个「二级」系统来管理这些「交互」。简单说好比我们有了一个自我可以成长的得力助手。这便是我们创意的初衷，也是渴望得到的最终目的。因为我们交互的对象如果没有「智商」，就好比一辆没有发动机的汽车。越是超前的智能交互则越要侧重于这一点。Kinect是一个很好的载体，在此基础上，总有想不到的实现，而且应用的模式，操作系统的功能将不再是用户初始安装的那样一直不变，试想你可以培养一个你的助手。这些请参考创意简介和技术可行性分析。同时欢迎关注我们——5thplanet.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一组织小伙伴们一同玩耍的带头者。&lt;/p&gt;
&lt;p&gt;一第一次创建小组起始于小学。那时的数学老师鼓励我们志同道合的朋友在一起学习进步。我以学习数学、计算机为目的拉进来很多人。有点像组阁，还为每个人安插了头衔。时至今日，我连自己的头衔都忘了，却依稀记得那时一位数学很好的同学被安排为网络管理员，有一回我去图书大厦还碰到他买关于网管的书籍：）&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="小学" scheme="http://izhen.me/tags/%E5%B0%8F%E5%AD%A6/"/>
    
      <category term="游戏" scheme="http://izhen.me/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="兴趣小组" scheme="http://izhen.me/tags/%E5%85%B4%E8%B6%A3%E5%B0%8F%E7%BB%84/"/>
    
      <category term="中学" scheme="http://izhen.me/tags/%E4%B8%AD%E5%AD%A6/"/>
    
      <category term="大学" scheme="http://izhen.me/tags/%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>我的故事 -- 竞赛篇</title>
    <link href="http://izhen.me/2019/08/23/mystory1/"/>
    <id>http://izhen.me/2019/08/23/mystory1/</id>
    <published>2019-08-22T16:21:00.000Z</published>
    <updated>2019-08-23T14:48:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>––曲折道路上的追梦者，仅部分片段。</p><p>––孩童时期是一个非常普通的竹篱茅舍的毛小子，爱好玩耍，不懂读书。最喜欢夏天穿着短裤光着小脚在牵牛花的陪伴下，走向田野，附和着成荫绿树的影子，在乡间的小溪边荡漾。摇曳着清风的线条，我能抓住的不只是蜻蜓和蚂蚱，还是那未到的盛夏，偶尔下着小雨，土地就会变成了贪玩孩子的梦想泥潭。我很喜欢清风，尤其是夏天出来乘凉，刮过的沁人心脾的夜风，毕竟抬头就是银河，一望无际的夜空，美丽的闪烁着的星体和月亮。我是那么的喜欢星空，感觉在浩瀚无垠的宇宙面前，一切都升华了，所以小时候我第一个梦想就是天文学家……</p><a id="more"></a><p>––我是一个非常爱幻想的孩子，当时还没有如现在发达的社交网络，不懂得这是现在流行于动漫圈子的「中二」，那时，即便是在90年代中期，家中有幸存在一台比我岁数还大的个人计算机，也是我第一次看到了电脑的样子。</p><p>––孕育在大自然中的我，上了小学后就搬北方某直辖市的楼房里。这时的我不再有那种天下繁星，遍地绿树与土地都属于我的直觉。感觉变了点，这时候的打闹就是我与小伙伴们在小区里的转悠，全都那么平常。然而四年级的暑假，一切都不同了。我得到了第一本计算机的图书，从此计算机对于我来说不再是游戏机，那是一本讲述如何制作PPT的书，学完那本书后，我还自学了网页制作，当时的网页制作三剑客Fireworks、Dreamweaver、Flash。到处寻找免费的资源，免费的域名，免费的邮箱，免费的个人虚拟主机空间。这些资源一切都是为了我组建的第一个兴趣小组储备的。</p><p><img src="/image/xiaoxue.JPG" alt="现在上面的链接都失效了"></p><p>––我的宇宙不再是繁星点点，变成了一部实实在在的计算机，天文学家也不再是我的梦想，目标比尔盖茨！（科学家是孩童时期的天真烂漫，现在已凋零）</p><p>––后来遇到了我的启蒙之师，王强老师——一位非常风趣幽默的老师：)。学习上手简单，现在看简直就是古董的Quick Basic语言。第一个写出来的实用程序是四则运算计算器，之后正式接触了程序设计竞赛，便与计算机结下了不解之缘，2004年。每周四都会在放学后在机房学习一个小时，老师会因我们的表现决定我们课后可以玩什么游戏～（小游戏、中等游戏、大型游戏），有一回刚刚开始学习用字符串矩阵打印图形，老师要求将自己的姓氏输出到屏幕，因为我的姓笔划稍微复杂，所以在我完成后老师很满意的让我玩大型游戏～。最喜欢的两个地方，一个是图书大厦，另一个就是游戏商店。买了无数的正版游戏，也阅读了很多计算机类的图书，对着一本书照猫画虎的用VB写了一个简单的MP3播放器，没有设计，功能也不完善，不过自己还是挺高兴。偶尔还会鼓捣鼓捣Linux，知道了这个世界上的系统不是只有Windows。当时沉迷得不能自拔，甚至语文课留的作文我都写一些老师看的迷糊的技术，一而再再而三，作文的分数一直就不高，那时的计算机充满了趣味。然而时过境迁，英才豪杰辈出，对于当代热爱学习先进技术的孩子来说这都不算什么。</p><p>––六年级，参加天津市小学生编程竞赛，获得二等奖。也因此得到了校长推荐实验中学小升初冬令营的资格，在冬令营我表现突出，考试成绩名列前茅，最终与实验中学签约保送英语特长班。</p><p>––升上初中后，我由Basic转到了Pascal，那时的消息还是闭塞，我觉得我在大学之前的学校生涯中还是初中过得最自在。我无忧无虑，从不担心未来，正所谓活在当下。那时Facebook还没成名，Web 2.0 的时代也尚未兴盛，16岁天才Blake Ross刚刚发明Firefox不过几年。所以我所学习的计算机多半就是自娱自乐，初中没把走竞赛这条路放在心上，甚至也根本没有往这里考虑过。要说那时的我点了什么技能点的话，就是组建了我在步入社会前最自豪的兴趣团队。但是团队里真正喜欢计算机的恐怕只有我一个人，也只有我一个人选择了这条道路。</p><p>––初三，托福于平时的努力加最终的运气，物理和计算机奥林匹克竞赛双料一等奖，学校高中部的理科实验一班向我伸出了橄榄枝。</p><p>––升到高中后，因为是竞赛实验班，我选了数学、物理和计算机三科进修，但是因为精力有限，最终还是集中精力搞自己最喜欢的计算机。高一第一学期的NOIP比赛，我突击了一个星期侥幸压线拿到一等，也收获了班里第一个大学保送资格，OIer的人生就此开始了，梦想在全国大赛的领奖台上摘金夺银。当时我就有一种理念：全面发展是非常重要的，不会把全部时间都用在功课上，有余力做一些兴趣使然的事情，所以希望在高中也能够贯彻到底。可是，高中时代的班主任不认同计算机竞赛，属于不务正业。得不到老师的支持也没什么办法（如果老师可以支持某项竞赛，那么学相关竞赛的学生可以多获得一点课余时间，比如中午可以去机房训练之类的），只能平时多挤挤牙膏了。实验班的教学是奥赛难度的，课业压力很大，逆向的阻碍和烦躁的思绪加上本来就少的课余时间，使得在计算机竞赛上的投入不能很好的集中精力。那段日子我睡眠质量很差，总是觉得一天24小时实在不够用。记得暑假里某一天，我苦苦思索一道难题无解，便睡下了，梦里，找到了一种特殊的模式可以很笨的实现出来，早上6点我就爬了起来，在电脑桌前伏案到次日凌晨4点，22个小时，一点都不觉得累，最终看到屏幕上绿色的「Accepted」字样，满脑子充斥着幸福的多巴胺～。「一名OIer的精神是，在无数次的Wrong Anwser之后仍能坚定的按下F5（执行程序）」。渐渐的心理上已经有一点将OI作为精神寄托的感觉了，每每心情低落的时刻，拿出算法书我就能平静下来，感觉世界都安静了，只留下我与数以万行的代码。像不像吸血鬼也会制造自己的眷属一样呢（笑）？实在是迫切的想做出成绩，高二，省选惨败，代表队当时派出了7人出征，我排名第9，与全国大赛失之交臂。OIer的生涯止步于此。</p><p>也就在那时，我开始怀疑人生，小聪明可不是大智慧。训练的过程锻炼了我为追求事物所应具备的执着、坚韧，除此以外或许还缺些什么吧，将来的某一天一定要找到。</p><p>竞赛决不是捷径，它只是另一种艰辛的生活方式。<br>得到与失去，只有时间会去评判；成功与失败，只有历史能去仲裁。<br>我不会永远成功，正如我不会永远失败一样。（OI圈名言）</p><p>「胜利和败北都要品尝，经历了四处碰壁的辛酸，痛苦伤心的回忆，才能真正独当一面，就算痛哭流涕也没关系」</p><p>我仍然不后悔我的选择，竞赛的确是一条艰辛的道路。恰在高中时期社交网络开始发展，估计那时的信息不对称的削弱，看到了很多菊苣们的励志经历后太过自我膨胀了吧。我自己也开了博客，在博客上发一些题解，那些题解有几万的访问量，我也有了一个自己的小圈子，我们互相鼓励，互相学习。得益于社交网络的力量，让我可以了解到：原来全国的OIer几乎都有着类似的境遇，不被学校老师认可，顶着巨大的压力踽踽独行。所以我从未恐惧过未来。</p><p>––「大概这就是成长，也许我只能找到一些自我安慰，然后继续作死的日常」(注1)</p><p>––想想看我本人太执着于竞赛，计算机不是只有算法，高中也不是只有学术（没有多余的时间好好跟朋友们享受青春），想通这一点要感谢我在大学时代遇到的人与经历的事。也正是想通了这一点，我慢慢对自己不完美的高中生涯释怀了，不论成绩如何，那段拼搏的日子我很快乐～也结识了很多并肩作战的朋友。能为自己喜欢的事执着，已经非常幸运了。正如《灌篮高手》中湘北没有夺冠。而有人问过作者井上雄彦，为什么不设计湘北最后夺冠？井上雄彦回答说，因为青春的梦想往往是不完美的。</p><p>––虽然高中过的不理想，保送到大学后，觉得应当改变自己，多尝试一些可能。那个年代正逢移动互联网创业潮（2011年左右，iPhone 4/4S发布，乔布斯去世），刚上大学我便跟着学校最大的计算机社团活动，团长是我高中的直系学长，他叫MyShuo（化名）。而这个社团是打着社团名义，实际上拉拢全校计算机精英才干的创业组织。学校非常鼓励学生自主创业，便默认了学长的公司，经四个学院共同盖章批准还附赠了学生活动中心的一处办公室给他。但是我直觉上认为在大学时代就创业有些操之过急，根基不稳，于是在大一下学期跟照顾我半年多的学长表明了自己打算深造的心意，告了别，放弃了与他共同创业的可能。有考虑过读博士专注做科研，不过最终发现自己还是喜欢产业界，想做真正有价值的东西。虽喜欢学术，也尊敬大科学家，但却不希望将自己的人生全部奉献。</p><p>后来，开始会多看一些因为投入到计算机而一直想却没有时间赏析的文学、历史、哲学作品，电影和动漫，也开始尝试学了电吉他——电吉他是我请一位网工专业的学长教我的，他高中也搞过计算机竞赛，那时我觉得或许真的有「命运」这个东西也说不定，一开始我甚至不知道他也是计算机系的——不过手残没救，最终放弃治疗了。就是因为这些粗浅的尝试，我一度改变了自己既有的传统观念，认为人生不一定非得过得像革命先烈一样跟苦行僧似的，太单调。青春也好，人生也罢，过去了不会重来，为何不丰富一点，何况我<a href="https://izhen.me/2018/09/20/portfolio/">原本</a>就是这样的人呐。</p><p>也不算朝花夕拾，那些新的经历反向激励到了我，再一次想找回曾经痴狂的感觉，经验告诉我：无论遇到多大的阻碍，坚持住，不要离开，失去的永远不会回来。想起来一句出自《芒果街上的小屋》的话：「你总要离开，你总要回来」</p><p>大三下学期我非常繁忙的在学校的超算实验室做研究助理并轮轴周转于三个学术竞赛：MCM数学建模大赛，ACM-ICPC省赛，ASC超级计算机大赛，抱各位给力的小伙伴的大腿取得了一点微小的成绩。想接触真正广阔的计算机领域，做自己喜欢的项目，学自己喜欢的理论。想让自己的羽翼赶快丰满起来，遨游于属于自己的互联网大航海时代，有自己的小船，有自己的伙伴，共同冒险于惊涛骇浪之上，追寻梦想中的岛屿或新大陆。最终我选择毕业后继续深造，搭上了通往英国的飞机，飞往欧亚大陆的彼岸……</p><p>––应当感谢这个时代，10年时间物非人非，经历过曲折的道路，体味过平凡的日常，感受过荣耀的时刻。时代的变迁，世代继承的意志，人的梦，这些都是无法改变的。我曾一度迷茫，为自己的羸弱感到遗憾，这时我往往处在成长的停滞期，我甚至做出了很多超越性的尝试，体验了很多事物，从小处，从大处。「珍惜」自己所经历的一切，象牙塔终归不能给予我们真理，但是更重要的是一个氛围而已。</p><p>经营自己的人生不容易，凡是理想的生活都需要有相对应的付出，这就需要我们努力并产生等价交换。顶端的应用的也好，底层的基础的也好，只要做了都是好的。所以我不再拘泥于所谓的科学家、工程师这种头衔，我就是我，一个傻傻向前的追梦者~</p><p>––不包含研究生时代，以上。</p><p>––P.S. 如果当初没有选择计算机这条路，可能会去做时装设计吧～</p><p>注1:摘录自Dimpurr的一句话</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;––曲折道路上的追梦者，仅部分片段。&lt;/p&gt;
&lt;p&gt;––孩童时期是一个非常普通的竹篱茅舍的毛小子，爱好玩耍，不懂读书。最喜欢夏天穿着短裤光着小脚在牵牛花的陪伴下，走向田野，附和着成荫绿树的影子，在乡间的小溪边荡漾。摇曳着清风的线条，我能抓住的不只是蜻蜓和蚂蚱，还是那未到的盛夏，偶尔下着小雨，土地就会变成了贪玩孩子的梦想泥潭。我很喜欢清风，尤其是夏天出来乘凉，刮过的沁人心脾的夜风，毕竟抬头就是银河，一望无际的夜空，美丽的闪烁着的星体和月亮。我是那么的喜欢星空，感觉在浩瀚无垠的宇宙面前，一切都升华了，所以小时候我第一个梦想就是天文学家……&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="Basic" scheme="http://izhen.me/tags/Basic/"/>
    
      <category term="Pascal" scheme="http://izhen.me/tags/Pascal/"/>
    
      <category term="物理" scheme="http://izhen.me/tags/%E7%89%A9%E7%90%86/"/>
    
      <category term="VB" scheme="http://izhen.me/tags/VB/"/>
    
      <category term="游戏" scheme="http://izhen.me/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>OCaml开发环境搭建</title>
    <link href="http://izhen.me/2019/05/11/ocaml_config/"/>
    <id>http://izhen.me/2019/05/11/ocaml_config/</id>
    <published>2019-05-11T14:51:45.000Z</published>
    <updated>2019-11-26T11:41:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年之前撰文 <a href="https://izhen.me/2018/08/10/haskell_emacs/">Haskell开发环境搭建</a>，并且更新了对于<code>VS Code</code>的配置。虽然个人对<code>Vim</code>对使用时间更长，但是对于函数式语言对开发来说，还是觉得<code>Emacs</code>更好上手，特别是交互式开发模式。这一点不论Haskell还是Ocaml都是一样的。</p><a id="more"></a><h3 id="Emacs-for-OCaml"><a href="#Emacs-for-OCaml" class="headerlink" title="Emacs for OCaml"></a>Emacs for OCaml</h3><p>因为有了Haskell的配置经验，而OCaml的开发环境比Haskell简单不少，所以这里不做太多长篇大论的描述，主要配置参考了<a href="https://dev.realworldocaml.org/install.html" target="_blank" rel="noopener">Real World OCaml</a>。</p><h3 id="完整的配置文档"><a href="#完整的配置文档" class="headerlink" title="完整的配置文档"></a>完整的配置文档</h3><p>先装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brew install opam</span><br><span class="line">$ opam install core utop</span><br><span class="line">$ opam install async yojson core_extended core_bench cohttp async_graphics cryptokit menhir</span><br><span class="line">$ opam install merlin ocp-indent</span><br></pre></td></tr></table></figure><p>而后是完整文档，完整快捷键配置需参考注释，常用如下：</p><ul><li><code>C-c C-s</code> 打开Ocaml Utop</li><li><code>C-x C-e</code> 执行当前代码</li><li><code>C-x C-r</code> 执行当前选中区域</li><li><code>C-x C-b</code> 执行当前buffer</li><li><code>C-c C-k</code> 杀掉utop</li><li><code>C-c C-t</code> 显示光标所在位置的类型</li><li><code>C-c C-l</code> 去到定义处</li><li><code>C-c &lt;left&gt;</code> 类型展开/收缩</li><li><code>C-c &lt;right&gt;</code> 类型展开/收缩</li></ul><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; install OCaml support</span></span><br><span class="line">(<span class="name">package-install</span> 'tuareg)</span><br><span class="line">(<span class="name">package-install</span> 'utop)</span><br><span class="line">(<span class="name">package-install</span> 'merlin)</span><br><span class="line">(<span class="name">package-install</span> 'auto-complete)</span><br><span class="line"></span><br><span class="line">(<span class="name">add-hook</span> 'tuareg-mode-hook 'tuareg-imenu-set-imenu)</span><br><span class="line">(<span class="name">setq</span> auto-mode-alist</span><br><span class="line">      (<span class="name">append</span> '((<span class="string">"\\.ml[ily]?$"</span> . tuareg-mode)</span><br><span class="line">                (<span class="string">"\\.topml$"</span> . tuareg-mode))</span><br><span class="line">              auto-mode-alist))</span><br><span class="line">(<span class="name">autoload</span> 'utop-setup-ocaml-buffer <span class="string">"utop"</span> <span class="string">"Toplevel for OCaml"</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">add-hook</span> 'tuareg-mode-hook 'utop-setup-ocaml-buffer)</span><br><span class="line">(<span class="name">add-hook</span> 'tuareg-mode-hook 'merlin-mode)</span><br><span class="line">(<span class="name">setq</span> merlin-use-auto-complete-mode <span class="literal">t</span>)</span><br><span class="line">(<span class="name">setq</span> merlin-error-after-save <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; -- merlin setup ---------------------------------------</span></span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> opam-share (<span class="name">substring</span> (<span class="name">shell-command-to-string</span> <span class="string">"opam config var share"</span>) <span class="number">0</span> <span class="number">-1</span>))</span><br><span class="line">(<span class="name">add-to-list</span> 'load-path (<span class="name">concat</span> opam-share <span class="string">"/emacs/site-lisp"</span>))</span><br><span class="line">(<span class="name">require</span> 'merlin)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; Enable Merlin for ML buffers</span></span><br><span class="line">(<span class="name">add-hook</span> 'tuareg-mode-hook 'merlin-mode)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; So you can do it on a mac, where `C-&lt;up&gt;` and `C-&lt;down&gt;` are used</span></span><br><span class="line"><span class="comment">;; by spaces.</span></span><br><span class="line">(<span class="name">define-key</span> merlin-mode-map</span><br><span class="line">  (<span class="name">kbd</span> <span class="string">"C-c &lt;left&gt;"</span>) 'merlin-type-enclosing-go-up)</span><br><span class="line">(<span class="name">define-key</span> merlin-mode-map</span><br><span class="line">  (<span class="name">kbd</span> <span class="string">"C-c &lt;right&gt;"</span>) 'merlin-type-enclosing-go-down)</span><br><span class="line">(<span class="name">set-face-background</span> 'merlin-type-face <span class="string">"#88FF44"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; -- enable auto-complete -------------------------------</span></span><br><span class="line"><span class="comment">;; Not required, but useful along with merlin-mode</span></span><br><span class="line">(<span class="name">require</span> 'auto-complete)</span><br><span class="line">(<span class="name">add-hook</span> 'tuareg-mode-hook 'auto-complete-mode)</span><br><span class="line">(<span class="name">setq</span> merlin-ac-setup 't)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; Replace tuareg by ocp-indent</span></span><br><span class="line">(<span class="name">setq</span> opam-share (<span class="name">substring</span> (<span class="name">shell-command-to-string</span> <span class="string">"opam config var share"</span>) <span class="number">0</span> <span class="number">-1</span>))</span><br><span class="line">(<span class="name">load-file</span> (<span class="name">concat</span> opam-share <span class="string">"/emacs/site-lisp/ocp-indent.el"</span>))</span><br></pre></td></tr></table></figure><h3 id="Vim-for-OCaml"><a href="#Vim-for-OCaml" class="headerlink" title="Vim for OCaml"></a>Vim for OCaml</h3><p>Vim中的配置如下，主要依赖Omni和Merlin这个神器：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" Vim needs to be built with Python scripting support, and must be</span></span><br><span class="line"><span class="comment">" able to find Merlin's executable on PATH.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">executable</span>(<span class="string">'ocamlmerlin'</span>) &amp;&amp; <span class="built_in">has</span>(<span class="string">'python'</span>)</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s:ocamlmerlin</span> = <span class="keyword">substitute</span>(<span class="built_in">system</span>(<span class="string">'opam config var share'</span>), <span class="string">'\n$'</span>, <span class="string">''</span>, <span class="string">''</span><span class="string">''</span>) . <span class="string">"/merlin"</span></span><br><span class="line">  <span class="keyword">execute</span> <span class="string">"set rtp+="</span>.<span class="variable">s:ocamlmerlin</span>.<span class="string">"/vim"</span></span><br><span class="line">  <span class="keyword">execute</span> <span class="string">"set rtp+="</span>.<span class="variable">s:ocamlmerlin</span>.<span class="string">"/vimbufsync"</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:opamshare</span> = <span class="keyword">substitute</span>(<span class="built_in">system</span>(<span class="string">'opam config var share'</span>),<span class="string">'\n$'</span>,<span class="string">''</span>,<span class="string">''</span><span class="string">''</span>)</span><br><span class="line"><span class="keyword">execute</span> <span class="string">"set rtp+="</span> . <span class="variable">g:opamshare</span> . <span class="string">"/merlin/vim"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !exists(<span class="string">'g:neocomplcache_force_omni_patterns'</span>)</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g:neocomplcache_force_omni_patterns</span> = &#123;&#125;</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g:neocomplcache_force_omni_patterns</span>.ocaml = <span class="string">'[^. *\t]\.\w*\|\h\w*|#'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" OCP-indent</span></span><br><span class="line"><span class="keyword">autocmd</span> FileType ocaml <span class="keyword">execute</span> <span class="string">"set rtp+="</span> . <span class="keyword">substitute</span>(<span class="built_in">system</span>(<span class="string">'opam config var share'</span>), <span class="string">'\n$'</span>, <span class="string">''</span>, <span class="string">''</span><span class="string">''</span>) . <span class="string">"/ocp-indent/vim/indent/ocaml.vim"</span></span><br></pre></td></tr></table></figure><p>VS Code中的配置很简单，装上<a href="https://marketplace.visualstudio.com/items?itemName=freebroccolo.reasonml" target="_blank" rel="noopener">Ocaml and Reason IDE</a>，就好了。这里面还有一个神器<a href="https://docs.imandra.ai/imandra-docs/notebooks/installation-simple/" target="_blank" rel="noopener">Imandra</a>，可以粗浅的看作是Ocaml中LiquidHaskell，而且是商业化的。</p><p><img src="/image/imandra.jpg" alt="Imandra IDE"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Aquamacs简洁的配置用来做快速的原型开发很合适。效果如下图所示，代码补全与Utop：</p><p><img src="/image/ocaml_utop.jpg" alt="Merlin 与 Emacs 配合"></p><p>Macvim/Vim更适合需要快速加载的大型项目，加载速度是emacs的痛点。效果如下图所示，Omni代码补全：</p><p><img src="/image/ocaml_vim.jpg" alt="Merlin 与 Vim 配合"></p><p>题外话：时代在不断进步，<a href="https://spacevim.org" target="_blank" rel="noopener">SpaceVim</a>和<a href="http://spacemacs.org" target="_blank" rel="noopener">Spacemacs</a>逐渐趋于成熟，很多主流的编程语言完全可以尝试新的开发环境。各自有各自的特点可以穿插交替使用。<a href="">Sublime Text</a>感觉已经凉了，<a href="">VS Code</a>是更好的选择，除了本身背后有微软一个团队在做（Visual Studio的技术积累），开放的社区能提供更多更快的特性支持。但是<a href="">Sublime Merge</a>横空出世，可以做为<a href="">Github Desktop</a>的代替品，相对来说<code>Git</code>或者<code>diff</code>这种单一功能的工具也许更适合一个微型团队持续维护与支持。</p><p>附：utop有一些<a href="https://github.com/ocaml-community/utop/issues/258" target="_blank" rel="noopener">更新</a>，可以参考这个issue</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年之前撰文 &lt;a href=&quot;https://izhen.me/2018/08/10/haskell_emacs/&quot;&gt;Haskell开发环境搭建&lt;/a&gt;，并且更新了对于&lt;code&gt;VS Code&lt;/code&gt;的配置。虽然个人对&lt;code&gt;Vim&lt;/code&gt;对使用时间更长，但是对于函数式语言对开发来说，还是觉得&lt;code&gt;Emacs&lt;/code&gt;更好上手，特别是交互式开发模式。这一点不论Haskell还是Ocaml都是一样的。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="IDE" scheme="http://izhen.me/tags/IDE/"/>
    
      <category term="Emacs" scheme="http://izhen.me/tags/Emacs/"/>
    
      <category term="Mac OS X" scheme="http://izhen.me/tags/Mac-OS-X/"/>
    
      <category term="VS Code" scheme="http://izhen.me/tags/VS-Code/"/>
    
      <category term="OCaml" scheme="http://izhen.me/tags/OCaml/"/>
    
      <category term="Vim" scheme="http://izhen.me/tags/Vim/"/>
    
      <category term="imandra" scheme="http://izhen.me/tags/imandra/"/>
    
  </entry>
  
  <entry>
    <title>MAC OS X 上可以使用的开源免费创意软件</title>
    <link href="http://izhen.me/2019/05/07/opensource_creative/"/>
    <id>http://izhen.me/2019/05/07/opensource_creative/</id>
    <published>2019-05-07T10:42:39.000Z</published>
    <updated>2019-05-08T10:58:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>早先写过<a href="https://izhen.me/2014/03/07/2014-03-07-my-mac-software-list/">MAC OS X 常用软件分享</a>，商业软件中存在相当多制作精良，可以大大提高生产效率的工具。但是也往往伴随着不菲的价格，这里我介绍一下能达到商业规范并且免费开源的创意软件。所列举的产品都是可以在Mac系统上使用的。</p><a id="more"></a><h4 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h4><ol><li><a href="https://www.gimp.org" target="_blank" rel="noopener">GIMP</a> 开源界的Photoshop</li><li><a href="http://www.krita.org" target="_blank" rel="noopener">Krita</a> 很强大的绘图软件，可以制作2D动画</li><li><a href="https://inkscape.org" target="_blank" rel="noopener">Inkscape</a> 矢量图形制作工具，Adobe Illustrator的代替，目前没有支持native OS X环境</li></ol><h4 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h4><ol><li><a href="http://www.darktable.org" target="_blank" rel="noopener">darktable</a> 功能强大的raw图处理软件</li><li><a href="https://www.digikam.org" target="_blank" rel="noopener">digikam</a> 同上，有相册功能</li><li><a href="http://www.rawtherapee.com" target="_blank" rel="noopener">RawTherapee</a> 同上</li><li><a href="http://pixls.us" target="_blank" rel="noopener">pixls.us</a> 专注开源照片处理工具的博客</li></ol><h4 id="动画软件"><a href="#动画软件" class="headerlink" title="动画软件"></a>动画软件</h4><ol><li><a href="https://www.pencil2d.org" target="_blank" rel="noopener">Pencil2D</a> 简单强大的2D动画制作软件</li><li><a href="https://www.synfig.org" target="_blank" rel="noopener">Synfig Studio</a> Adobe Animation(Flash)的代替</li><li><a href="http://opentoonz.github.io/e/" target="_blank" rel="noopener">Toonz Studio</a> 吉卜力工作室御用软件</li><li><a href="https://www.blender.org/download/" target="_blank" rel="noopener">blender</a> 众所周知的3D制作软件，最新版也支持2D动画制作</li></ol><h4 id="写作工具"><a href="#写作工具" class="headerlink" title="写作工具"></a>写作工具</h4><ol><li><a href="http://www.twinery.org" target="_blank" rel="noopener">Twine</a> 很棒的交互式非线性小说构建工具</li><li><a href="https://www.softpedia.com/get/Office-tools/Other-Office-Tools/Manuskript.shtml" target="_blank" rel="noopener">Manuskript</a> scrivener的开源替代品，也有不错的功能</li><li><a href="http://cs.sharelatex.com" target="_blank" rel="noopener">ShareLatex</a> 在线的Tex工具包</li><li><a href="https://www.scribus.net" target="_blank" rel="noopener">Scribus</a> 排版软件，Adobe InDesign替代</li></ol><h4 id="视频软件"><a href="#视频软件" class="headerlink" title="视频软件"></a>视频软件</h4><ol><li><a href="https://www.olivevideoeditor.org" target="_blank" rel="noopener">Olive</a> 开源的符合视频编辑标准的视频剪辑工具</li><li><a href="https://natrongithub.github.io" target="_blank" rel="noopener">Natron</a> 基于结点的特效制作工具，Adobe Effects替代</li></ol><h4 id="音乐软件"><a href="#音乐软件" class="headerlink" title="音乐软件"></a>音乐软件</h4><ol><li><a href="https://musescore.com" target="_blank" rel="noopener">MuseScore</a> 乐谱编辑软件，还有一个庞大的社区</li><li><a href="https://www.mixxx.org" target="_blank" rel="noopener">Mixxx</a> DJ混音软件</li><li><a href="https://www.audacityteam.org" target="_blank" rel="noopener">Audacity</a> 功能简单的音频编辑软件</li><li><a href="http://hydrogen-music.org" target="_blank" rel="noopener">Hydrogen</a> 鼓点制作软件</li></ol><h4 id="游戏制作"><a href="#游戏制作" class="headerlink" title="游戏制作"></a>游戏制作</h4><ol><li><a href="http://www.machinations.io" target="_blank" rel="noopener">Machinations</a> 在线的游戏机制设计工具</li><li><a href="http://www.compilgames.net" target="_blank" rel="noopener">GDevelop</a> 不需要写代码的横版游戏制作软件</li><li><a href="http://www.sentientsketchbook.com" target="_blank" rel="noopener">Sentient Sketchbook</a> 地图自动生成工具，是作者的博士论文的项目</li><li><a href="https://www.renpy.org" target="_blank" rel="noopener">Ren’Py</a> Python写的视觉小说SDK，主要用来制作GalGame</li><li><a href="https://itch.io" target="_blank" rel="noopener">itch.io</a> 独立游戏制作者社会化网络</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>优秀的开源软件有太多，还有比如强大的FreeCAD、IDE等等。但是这里对于工业设计软件和开发工具都不做过多的介绍，很多开源世界的瑰宝就留给读者自己去<a href="https://itsfoss.com" target="_blank" rel="noopener">探索</a>吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早先写过&lt;a href=&quot;https://izhen.me/2014/03/07/2014-03-07-my-mac-software-list/&quot;&gt;MAC OS X 常用软件分享&lt;/a&gt;，商业软件中存在相当多制作精良，可以大大提高生产效率的工具。但是也往往伴随着不菲的价格，这里我介绍一下能达到商业规范并且免费开源的创意软件。所列举的产品都是可以在Mac系统上使用的。&lt;/p&gt;
    
    </summary>
    
      <category term="OS X" scheme="http://izhen.me/categories/OS-X/"/>
    
    
      <category term="OS X" scheme="http://izhen.me/tags/OS-X/"/>
    
      <category term="open source" scheme="http://izhen.me/tags/open-source/"/>
    
      <category term="software" scheme="http://izhen.me/tags/software/"/>
    
  </entry>
  
  <entry>
    <title>JVM中的invokedynamic</title>
    <link href="http://izhen.me/2019/04/22/invoke-dynamic/"/>
    <id>http://izhen.me/2019/04/22/invoke-dynamic/</id>
    <published>2019-04-21T16:21:00.000Z</published>
    <updated>2019-05-05T10:59:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>浅谈一下自JVM发行以来首次引入的新指令。</p><a id="more"></a><h3 id="为了支持更多语言"><a href="#为了支持更多语言" class="headerlink" title="为了支持更多语言"></a>为了支持更多语言</h3><p>官方在<a href="http://cr.openjdk.java.net/~jrose/pres/200910-VMIL.pdf" target="_blank" rel="noopener">论文</a>中阐述新指令的引入动机是为了更好的支持更多的语言，因为当时已经不再是Java这一种语言在使用JVM了。首要解决的是诸如Python、Ruby这类动态类型语言的支持问题。Java是强类型的语言，尽管在编译后真正跑在虚拟机上是去类型的，可是在最终invoke时要做类型检查，如果这时候签名不一致回报错，所以编译时就要确定这些参数。可是动态类型的语言只有在运行时才能知道具体类型，因此在没有invokedynamic前，Jython和JRuby实现起来很繁琐。</p><p>这个invoke类型的引入也同时引入了Bootstrap Method(简称BSM)的概念和一个新的对象CallSite。BSM构造CallSite，CallSite存储MethodHandle。</p><h4 id="BSM"><a href="#BSM" class="headerlink" title="BSM"></a>BSM</h4><p>一个Bootstrap Method通常存储在常量池中，一般认为BSM都是static的。它的前三个参数和返回类型均有<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/package-summary.html" target="_blank" rel="noopener">约定</a>，是用户定义的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> CallSite <span class="title">bootstrap</span><span class="params">(Lookup caller, String name, MethodType type)</span></span></span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>caller: 用以查找MethodHandle的方法</li><li>name: 被查找方法的名字</li><li>type: 方法的签名</li></ul><p>可以拥有251个额外的静态参数，因为JVM启动的时候就会load这个BSM，所以要求静态。</p><h4 id="CallSite"><a href="#CallSite" class="headerlink" title="CallSite"></a>CallSite</h4><p>里面存储的MethodHandle，可以在BSM构造后使用setTarget()重新设定一个MH，但是签名必须一致。</p><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>invokedynamic先调用BSM构造出CallSite，这一步叫做调用点解析。然后调用解析好的调用点。Dalvik中将invokedynamic拆成invoke-custom和invoke-polymorphic，前者可以认为是弱化的dynamic，而后者则是一个Dalvik中支持签名多态的新指令，由Methodhandle.invoke和MethodHandle.invokeExact实现。</p><h3 id="Java-8-中的匿名函数"><a href="#Java-8-中的匿名函数" class="headerlink" title="Java 8 中的匿名函数"></a>Java 8 中的匿名函数</h3><p>官方在<a href="https://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html" target="_blank" rel="noopener">设计文档</a>中指出，虽然lambda expression可以用inner class，invokedynamic，MethodHandle Proxies等多种方法实现，但是因为一些历史原因最终选择了invokedynamic，这就使得这一条指令肩负着动态类型语言和函数式特性两大任务。</p><p>本质上lambda expression在Java中是一个Desugar的过程，最终推到runtime去做bind。下面是J8中LambdaMetafactory的一个BSM：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> CallSitemetafactory​(MethodHandles.Lookup caller, </span><br><span class="line">                            String invokedName, </span><br><span class="line">                            MethodType invokedType, </span><br><span class="line">                            MethodType samMethodType, </span><br><span class="line">                            MethodHandle implMethod, </span><br><span class="line">                            MethodType instantiatedMethodType)</span><br></pre></td></tr></table></figure><p>可以尝试写几个lambda expression后，通过javap反汇编看到编译后对应的invoke指令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浅谈一下自JVM发行以来首次引入的新指令。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="lambda expression" scheme="http://izhen.me/tags/lambda-expression/"/>
    
      <category term="JVM instruction" scheme="http://izhen.me/tags/JVM-instruction/"/>
    
      <category term="dynamic typed" scheme="http://izhen.me/tags/dynamic-typed/"/>
    
      <category term="dalvik" scheme="http://izhen.me/tags/dalvik/"/>
    
      <category term="invokecustom" scheme="http://izhen.me/tags/invokecustom/"/>
    
      <category term="invokepolymorphic" scheme="http://izhen.me/tags/invokepolymorphic/"/>
    
      <category term="invokedynamic" scheme="http://izhen.me/tags/invokedynamic/"/>
    
  </entry>
  
  <entry>
    <title>Project lambda部署指南</title>
    <link href="http://izhen.me/2019/04/22/lambda_config/"/>
    <id>http://izhen.me/2019/04/22/lambda_config/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2019-04-22T13:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目本身规模小、且没有足够的时间与人力去设计运维部分。这么小的项目却要做很多不必要的或者不合理的工作，实在惭愧。</p><a id="more"></a><h4 id="数据库设置"><a href="#数据库设置" class="headerlink" title="数据库设置"></a>数据库设置</h4><p>项目的数据库存储与项目本身的部署是分离，先装好 <a href="">PotgreSQL</a> 后，启动一个数据库，具体的步骤请参阅官方文档。</p><p>设置好后将用户名，密码以及端口号写入<code>Skeleton/Kernel/Internal/Model.hs</code>。</p><h4 id="邮件订阅"><a href="#邮件订阅" class="headerlink" title="邮件订阅"></a>邮件订阅</h4><p>在<code>Skeleton/Kernel/Core/Mail.hs</code>里面设置好邮件发送端相关信息。</p><h4 id="前端设定"><a href="#前端设定" class="headerlink" title="前端设定"></a>前端设定</h4><p>将 <a href="">ProLambda/Times-default-theme</a> 放入<code>static</code>文件夹。</p><h4 id="两次启动"><a href="#两次启动" class="headerlink" title="两次启动"></a>两次启动</h4><ol><li>第一次启动要在<code>Main.hs</code>中将以下注释放开，然后构建项目并运行：</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- initializeStatDb</span></span><br><span class="line"><span class="comment">-- initializeNewsDb</span></span><br><span class="line"><span class="comment">-- setLevel "xxx" 12 (+1) -- "xxx" could be any registered user, for setting super admin, can be run when has at least one user</span></span><br></pre></td></tr></table></figure><ol start="2"><li>重新注释好第一步的三句语句后，再次启动，启动命令如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$stack build</span><br><span class="line">$stack exec proj</span><br></pre></td></tr></table></figure><h5 id="DISQUS"><a href="#DISQUS" class="headerlink" title="DISQUS"></a>DISQUS</h5><p>需要在<code>main.html</code>中设定事先注册好的账户。</p><h5 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h5><p>某些<code>Linux</code>的发行版，比如 <a href="">AWS</a> 上面的可能会缺库，可以自行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$install postgresql-devel, zlib-devel</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目本身规模小、且没有足够的时间与人力去设计运维部分。这么小的项目却要做很多不必要的或者不合理的工作，实在惭愧。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="Haskell" scheme="http://izhen.me/tags/Haskell/"/>
    
      <category term="project lambda" scheme="http://izhen.me/tags/project-lambda/"/>
    
      <category term="Configuration" scheme="http://izhen.me/tags/Configuration/"/>
    
  </entry>
  
  <entry>
    <title>星巴克不需要两阶段提交</title>
    <link href="http://izhen.me/2018/12/18/starbucks/"/>
    <id>http://izhen.me/2018/12/18/starbucks/</id>
    <published>2018-12-17T19:17:14.000Z</published>
    <updated>2018-12-23T13:53:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.enterpriseintegrationpatterns.com/ramblings/18_starbucks.html" target="_blank" rel="noopener">原文</a>中更多想说明的是异步处理很棒以及要根据实际的需求做出合适合理的架构设计。</p><a id="more"></a><p>简单归纳几点常见的架构设计注意事项。首先没有完美的一致性方案，这个可以探究CAP原理，要么低延时/弱一致性，要么强一致/低吞吐。根据需要按需选择，在分布式领域切记高可用而不是高可靠。保证高可用，可以在必要时刻进行服务降级，将流量集中在重要的服务上面。但是对于集群的容错一定要考虑，比如可以使用「舱壁隔离」，容错模式可以选用：fail-over——立即重试，fail-fast——不重要的任务忽略，fail-back——先记录，后重试，fail-fork——同时发请求，降低失败概率。服务之间也不是平等的合作关系，而是消费者/提供者关系。对于弹性伸缩，伸缩本身是一门艺术，然而「弹性」其实没那么重要。</p><p>分布式理论第一原则：不分布。这就是说我们是在问题必须要分布处理的时候才选择分布，不分布就能极大的减少很多问题的引入。当要考虑分布时，不能一个劲的堆叠系统的复杂程度。</p><p>微服务架构，最要紧的是如何正确划分边界，微不微不重要。一个理想的划分模式是服务划分，垂直优先，比如领域驱动的设计。系统由服务组成，服务之间只能通过接口进行交互。服务独立开发、测试、发布、部署和升级。</p><p>服务划分第一原则：不要划分。这个就跟分布式理论一致了。「有必要」才进行划分。</p><p>在设计API的时候，有一种风格是REST，通过预定义有限枚举的动词配合资源导向，使用Non + Verb来表达系统的业务能力。实现方式可以选择：Json over HTTP，用资源的方式抽象接口。可以参考 <a href="https://cloud.google.com/apis/design/" target="_blank" rel="noopener">Google Cloud API Design Guide</a>。</p><p>底层能力库有不一样的选择，上层会有不一样的想法。比如在出现钢结构之前，很难想象鸟巢这种建筑。可以使用容器、虚拟机做资源池化。</p><p>几个设计模式：sidecar模式，使用IPC而不是RPC。绞杀着模式，在升级系统时一部分一部分来，然后使用蓝绿部署进行热更新，可以参考Netflix在AWS的案例。</p><p>有一些很容易被曲解的地方：</p><ul><li>简单而不是简陋</li><li>权衡而不是将就</li><li>迭代而不是半成品</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.enterpriseintegrationpatterns.com/ramblings/18_starbucks.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;中更多想说明的是异步处理很棒以及要根据实际的需求做出合适合理的架构设计。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="2PC" scheme="http://izhen.me/tags/2PC/"/>
    
      <category term="Architecture" scheme="http://izhen.me/tags/Architecture/"/>
    
      <category term="Starbuck" scheme="http://izhen.me/tags/Starbuck/"/>
    
  </entry>
  
  <entry>
    <title>细数大学前的重大创作</title>
    <link href="http://izhen.me/2018/09/20/portfolio/"/>
    <id>http://izhen.me/2018/09/20/portfolio/</id>
    <published>2018-09-20T14:53:47.000Z</published>
    <updated>2018-09-27T13:34:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>大三，在我整理移动硬盘内的资料为了方便备份系统时，误删了几乎全部的作品，最令我心疼的就是<a href="https://izhen.me/2018/09/20/firstsite/">「神英启蒙」</a>。因为我当时将网站上传到了虚拟主机，便抱着最后的一丝希望疯狂的搜索，然而虎翼空间早已不见踪影。这种感觉就好比一个不小心弄丢了自己一半的灵魂。不幸中的万幸虽然没能找到我的网站，却找到了PPT（传说已经被小学信息技术课采用作为教学案例），可笑的是不知是谁上传到付费资源网站的，上传也就罢了还要收费…作者本人并没有获利XD。不过也因此我才能重新收集起来。</p><p>下述不完全列表记载了读大学前我觉得最重要的一些创作，很多零零散散的作品没有录入：</p><a id="more"></a><h4 id="学龄前"><a href="#学龄前" class="headerlink" title="学龄前"></a>学龄前</h4><ol><li>小房子：用长木棍（原本用于栅栏），先搭好骨架用白色的线捆绑固定，再铺上麻袋做成帐篷的样子，木棍的支撑点用红砖加固。刚好可容纳3、4个小孩，着有趣味～</li></ol><h4 id="小学"><a href="#小学" class="headerlink" title="小学"></a>小学</h4><ol><li>一年级、二年级：古诗两首：《某日》、《春风》</li><li>二年级：连环画<a href="https://izhen.me/2015/12/21/2015-12-21-guangtou/">《九三皮历险记》</a>：一开始遇到吐火怪，头发被烧光。经历万重困难后，结局变成了化石，是个悲剧</li><li>三年级之前：发明各种游戏同小伙伴一起玩，是指捉迷藏那种现实世界的游戏，主要是设计游戏规则</li><li>四年级：web一个 - <a href="https://izhen.me/2018/09/20/firstsite/">神英启蒙</a></li><li>四年级、五年级：PPT若干，Intel求知计划<a href="https://izhen.me/lab/tlx_intel.ppt">作品</a></li><li>五年级：Authorware作品 - 仿照<a href="https://book.douban.com/subject/1241152/" target="_blank" rel="noopener">《动感多媒体自己制》</a>，另外还有一款软件：Director，不太会用</li><li>五年级：MS Painter作品若干，至少有一张邮票、一副街景图 、宇宙涂鸦</li></ol><p><img src="/image/homepage/oi_city.jpg" alt="OI城 - 高中凭记忆复刻的小学时的街景图"></p><ol start="8"><li>五年级或六年级：Visual Basic编写的MP3播放器，使用了控件。照猫画虎仿着一本教材学习的。</li><li>手工制作若干：亚洲车(用一个空调机的盒子做的，里面的布局不像汽车，像是一个小房子)，易拉罐船，设计类似大富翁的游戏等</li></ol><h4 id="初中"><a href="#初中" class="headerlink" title="初中"></a>初中</h4><ol><li>海报两幅，其中一个入围了Intel的海报设计全国比赛</li><li>Logo两个，其中一个logo是月牙形状的，忘记主题是什么了，用Fireworks做的。另一个是看了一本PS的书现学现卖的，环保主题，海报的中心是一个地球。两幅作品都为代表班级参赛</li><li>邀请函设计一个，科协的老师邀请我为Intel制作的，也不知道他们用没用</li><li>PPT若干，将以前制作的全部PPT组合到一起，集大成之作，和我创立的「奇幻天龙」小组共同完成。(P.S.这个小组后来发展成初中班级史上规模最大的帮会「十人帮」)</li><li>Pascal写的加密软件，加密机制是我在小学时读《福尔摩斯》受到启发而创作的凯撒密码。小学时只设计未实现，初中用Pascal语言实现了（P.S. 小学数学老师鼓励我们创立兴趣小组，志同道合的朋友在一起学习进步，我就搞了这个组，并且用这个密码设计“暗号”）</li></ol><h4 id="高中"><a href="#高中" class="headerlink" title="高中"></a>高中</h4><ol><li><a href="https://izhen.me/lab/timetester.zip">Online Judge内核</a> - C++</li><li>首次维护博客：新浪sacredfantasy，百度空间Adventop</li><li>使用木工制作的「火柴盒里的小剧场」（参考：《手工制作戏法玩具》，人民邮电出版社），是劳技课的作业，如果老师没弄丢应该还收藏在学校里。一开始老师还嫌弃我们用料太多</li><li><a href="https://izhen.me/lab/treap.pptx">《基本Treap》</a> 教学PPT</li><li>发表在NOI杂志上的<a href="https://izhen.me/lab/noi_journal.pdf">《使程序效率火箭般提速的数学构造》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大三，在我整理移动硬盘内的资料为了方便备份系统时，误删了几乎全部的作品，最令我心疼的就是&lt;a href=&quot;https://izhen.me/2018/09/20/firstsite/&quot;&gt;「神英启蒙」&lt;/a&gt;。因为我当时将网站上传到了虚拟主机，便抱着最后的一丝希望疯狂的搜索，然而虎翼空间早已不见踪影。这种感觉就好比一个不小心弄丢了自己一半的灵魂。不幸中的万幸虽然没能找到我的网站，却找到了PPT（传说已经被小学信息技术课采用作为教学案例），可笑的是不知是谁上传到付费资源网站的，上传也就罢了还要收费…作者本人并没有获利XD。不过也因此我才能重新收集起来。&lt;/p&gt;
&lt;p&gt;下述不完全列表记载了读大学前我觉得最重要的一些创作，很多零零散散的作品没有录入：&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="小学" scheme="http://izhen.me/tags/%E5%B0%8F%E5%AD%A6/"/>
    
      <category term="中学" scheme="http://izhen.me/tags/%E4%B8%AD%E5%AD%A6/"/>
    
      <category term="学龄前" scheme="http://izhen.me/tags/%E5%AD%A6%E9%BE%84%E5%89%8D/"/>
    
      <category term="创作" scheme="http://izhen.me/tags/%E5%88%9B%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>小学第一个个人网站</title>
    <link href="http://izhen.me/2018/09/20/firstsite/"/>
    <id>http://izhen.me/2018/09/20/firstsite/</id>
    <published>2018-09-20T12:53:47.000Z</published>
    <updated>2018-12-17T15:19:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>那是小学四年级的暑假，11岁，用 Frontpage 2000 亦或是 2002 制作了人生中第一个个人网站「神英启蒙网」。网站的名称来源于当时父亲不知从哪里搞来的一套少儿启蒙教学视频，里面有很多英语、数学等练习题目，帮助启发兴趣和开拓思维吧。我印象比较深的就是数学栏目中有关于火柴棒的题目，譬如说“移动两根让剩余的火柴棒组成某种等式”类似这样的。</p><a id="more"></a><p>当时流行的入门级网页制作工具是Macromedia公司的网页三剑客：Dreamweaver, Fireworks, Flash。还有更入门的M$的Frontpage。恰巧我对计算机的使用萌生了很大的兴趣，四年级之前最喜欢的应用程序是：MS Painter和金山画王。因为也学会了制作PPT，进而打算学习网页制作。家里也有学习资料，比如“洪恩教育”系列教学光盘（这家公司还出品过RTS游戏）。我学习了用Frontpage所见即所得制作网页后打算自己也建立一个网站以供孩子们启蒙，而且所有的素材都是我自己收集并编织在一起的。</p><p>先是在虎翼空间(51.net)注册了一个20M(或50M)的免费虚拟主机。</p><p>P.S. 恰恰在那个时期，我记得电视节目上播出某“天才”少女制作网站呼吁人们环保，那个网站只有一个主页，没记错的话页面背景是纯黑色。最崇拜的公司是搜狐，还很谦虚的说自己的东西比搜狐差远了。不知道现在她是否还继续做着类似的事情，我很想念那个浪漫的童年时代。</p><h4 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h4><p>主页的结构如图所示，中间有用“艺术字”做成的竖排文字Logo ——神英启蒙网，两边是一些分割好的格子，每个格子都填充了一类内容，同时也有简短的内容介绍，基本就是类似索引一样的东西。底部仿照正式的网站用剪贴画做了页脚，其中有一副Gif图我还记得是繁体字的“多谢来函”。同时整个页面还有背景音乐，我用的是《灌篮高手》OP的MIDI音乐。MIDI音乐和Gif图片都来自那时在电脑城很容易买到的「网站素材大全」之类的光盘。</p><p><img src="/image/homepage/index.jpg" alt="index.html"></p><h4 id="语文页"><a href="#语文页" class="headerlink" title="语文页"></a>语文页</h4><p>我还记得整体的页面是淡黄色的配色，比较柔和，里面有我小学一二年级写的两首诗《春风》《某日》，剩下的不是我的日记就是作文。全部都是单调的文字。</p><h4 id="英语页"><a href="#英语页" class="headerlink" title="英语页"></a>英语页</h4><p>整体配色偏深蓝色或深紫色，使用素材是小学的英语课本，我摘抄了几篇对话课文配上配图组成的，架构跟语文页差不了多少。如果是英文对话则排版成气泡的样式。</p><h4 id="计算机页"><a href="#计算机页" class="headerlink" title="计算机页"></a>计算机页</h4><p>这个页面是横版的，整体的色调是黑色，页面被分割成七巧板一样的结构，有很多计算机或者硬件的剪贴画，之所以设计成这个样子，我想应该是受到横版过关游戏<a href="https://en.wikipedia.org/wiki/Duke_Nukem_(video_game)" target="_blank" rel="noopener">Duke Nukem</a>的启发，除此以外可能还有《晴天有时下猪》里面主人公自己做报纸的桥段。内容是介绍基本的计算机知识，应该没有软件的教学内容，毕竟仅仅一个页面无法做到这么多。</p><p><img src="/image/homepage/pc.jpg" alt="Computer page"></p><h4 id="生活小窍门页"><a href="#生活小窍门页" class="headerlink" title="生活小窍门页"></a>生活小窍门页</h4><p>这个页面是受到小学老师的启发，多多积累日常生活中的小窍门，比如淘米水可以浇花什么的。但是版型也忘得一干二净了。</p><p>其他页面有点淡忘了，包括有没有做与数学有关的页面我实在记不清楚了，毕竟当时如果真的做了，恐怕应该也有一些练习题目，不过确实印象模糊想不起来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;那是小学四年级的暑假，11岁，用 Frontpage 2000 亦或是 2002 制作了人生中第一个个人网站「神英启蒙网」。网站的名称来源于当时父亲不知从哪里搞来的一套少儿启蒙教学视频，里面有很多英语、数学等练习题目，帮助启发兴趣和开拓思维吧。我印象比较深的就是数学栏目中有关于火柴棒的题目，譬如说“移动两根让剩余的火柴棒组成某种等式”类似这样的。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="Frontpage" scheme="http://izhen.me/tags/Frontpage/"/>
    
      <category term="小学" scheme="http://izhen.me/tags/%E5%B0%8F%E5%AD%A6/"/>
    
      <category term="烘培鸡" scheme="http://izhen.me/tags/%E7%83%98%E5%9F%B9%E9%B8%A1/"/>
    
  </entry>
  
  <entry>
    <title>Haskell开发环境搭建</title>
    <link href="http://izhen.me/2018/08/10/haskell_emacs/"/>
    <id>http://izhen.me/2018/08/10/haskell_emacs/</id>
    <published>2018-08-10T14:51:45.000Z</published>
    <updated>2019-11-26T10:31:07.083Z</updated>
    
    <content type="html"><![CDATA[<p>两年之前撰文 <a href="https://izhen.me/2016/10/21/Atom-Haskell-IDE/">Haskell的Atom IDE伪装</a>，那时刚离开英国，因为在旁听一门大一新生的<a href="https://www.inf.ed.ac.uk/teaching/courses/inf1/fp/" target="_blank" rel="noopener">函数式编程入门课</a>时某个契机启发了主讲教授，便委托我撰写了一个配置指南。期间我们还因为依赖的安装互相通过邮件交流了很多。现在当我再次去网站上浏览时发觉atom是仅剩的指导了，说来惭愧，我现在不怎么用atom了，使用atom取代emacs并不是我的本意，至少我并不希望任何一款editor占据主导地位。</p><a id="more"></a><p>2019年11月补充：随着时间的推移，我从在Aquamacs上使用<code>Ghc-mod</code>到<code>intero</code>，再到VS Code配合<code>Haskell IDE Engine</code>，可以看出整个社区生态的一个趋势：集成度越来越高。以往我们是要将各种插件统统由自己进行组装定制。现在有了<code>LSP</code>，慢慢后端变得整齐多了。我个人是比较倾向多使用现有成熟工具体系的，有时候面对很多新锐语言只能自己组环境时才去用Vim/Emacs。对于Haskell来说，至少目前<code>HIE</code>大有前途，而且维护也很活跃，兴许用不了很久杀手级的IDE就会诞生。</p><p><img src="/image/newemacs.jpg" alt="Minimal Emacs for Haskell"></p><h3 id="做工具的主人，而不是奴隶"><a href="#做工具的主人，而不是奴隶" class="headerlink" title="做工具的主人，而不是奴隶"></a>做工具的主人，而不是奴隶</h3><p>我始终觉得工具越是开箱即用越好，曾几何时，这个赞誉属于过 <a href="">Macbook</a>。在开发工具领域，很多优质的商业化集成开发环境就是好的样本，诚然这样的工具并不是针对每一种编程语言都随处可见。不同的语言需要不同的理解和优化，好的IDE需要投入巨大的成本去开发。所以很多小众的语言依然需要我们自行配置开发环境。</p><h3 id="Emacs-for-Haskell"><a href="#Emacs-for-Haskell" class="headerlink" title="Emacs for Haskell"></a>Emacs for Haskell</h3><p>我只需要为Haskell做<strong>最基础</strong>的配置，尽量做一个简洁的环境出来，所以这里不选择「Spacemacs」。我这里打算使用的是 <a href="http://aquamacs.org" target="_blank" rel="noopener">Aquamacs</a>，这是一个专门为Mac改良的Emacs，当作一个特别的发行版好了。</p><p>首先，我很久没有管理我之前的配置了，这次突然又折腾一遍是因为我买了台新的「Macbook Pro 15’」，我习惯第一时间先折腾环境。</p><p>然后我开始了「吃苦」的旅程。</p><h4 id="Brew"><a href="#Brew" class="headerlink" title="Brew"></a>Brew</h4><p>不知道是<code>GFW</code>的原因还是被<code>M$</code>收购的原因，不在终端配个<code>export ALL_PROXY</code>都连不上<code>Github</code>。</p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>Stack的官方软件源实在是不能用，我换了清华的源后好多了。有了Stack当然能方便不少，但是呢，老问题来了，我16年的时候开发网站就遇到过的：版本兼容。有些包还是不能在每一个resolver里面都有，我的办法是找不到的用<code>cabal install</code>，除此外别无他法。</p><h4 id="Emacs"><a href="#Emacs" class="headerlink" title="Emacs"></a>Emacs</h4><p>这个槽点就多了，首先在某个版本后，把什么gnutls的插件取消了，然后我不得不疯狂Goolge：自己搞了个SSL，然后配置上了。接着呢，在Melpa中很多插件在网站列表里有，但是我本地怎么都拉不到（flycheck），<del>所幸遇到神器intero，不然我可能就要用一个简陋版本了</del>，解决办法是切换到清华的源，现在我已经弃用intero了，直接组装出一个最小化的版本。注意使用代码补全的时候，有时候要等待TAGS文件准备好，Catalina这一版系统跑Emacs确实比较慢。</p><h3 id="完整的配置文档"><a href="#完整的配置文档" class="headerlink" title="完整的配置文档"></a>完整的配置文档</h3><p>先装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ brew install gnutls libressl</span><br><span class="line">$ stack install happy apply-refact hlint stylish-haskell hasktags hoogle</span><br><span class="line">$ git <span class="built_in">clone</span> --recursive git@github.com:ucsd-progsys/liquidhaskell.git </span><br><span class="line">$ <span class="built_in">cd</span> liquidhaskell</span><br><span class="line">$ stack install <span class="comment">#还需要装Z3 SMT Solver，具体看官方指南</span></span><br></pre></td></tr></table></figure><p>而后是完整文档，完整快捷键配置需参考注释，常用如下：</p><ul><li><code>C-c C-l</code> 打开repl</li><li><code>C-c h</code> Hoogle</li><li><code>M-x speedbar</code> 打开speedbar</li><li><code>C-c r</code> 接受hlint光标所在位置的建议，自动重构</li><li><code>C-c b</code> 接受hlint全局的建议，自动重构</li><li><code>M-s M-s</code> stack mode</li><li><code>M-.</code> 跳转到定义（需先保存文件，保存文件会自动触发tags和stylish）</li><li><code>M-?</code> 跳转到使用</li><li><code>liquid /path/to/file.hs</code> 在VS Code配合HIE使用，或Emacs/Vim执行Unix终端命令</li></ul><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; ____________________________________________________________________________</span></span><br><span class="line"><span class="comment">;; Aquamacs custom-file warning:</span></span><br><span class="line"><span class="comment">;; Warning: After loading this .emacs file, Aquamacs will also load</span></span><br><span class="line"><span class="comment">;; customizations from `custom-file' (customizations.el). Any settings there</span></span><br><span class="line"><span class="comment">;; will override those made here.</span></span><br><span class="line"><span class="comment">;; Consider moving your startup settings to the Preferences.el file, which</span></span><br><span class="line"><span class="comment">;; is loaded after `custom-file':</span></span><br><span class="line"><span class="comment">;; ~/Library/Preferences/Aquamacs Emacs/Preferences</span></span><br><span class="line"><span class="comment">;; _____________________________________________________________________________</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; stack install happy apply-refact hlint stylish-haskell hasktags hoogle</span></span><br><span class="line"><span class="comment">;; for SSL issue: https://github.com/davidswelt/aquamacs-emacs/issues/133</span></span><br><span class="line"><span class="comment">;; Prerequisite - begin</span></span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> hlint-refactor-call-process-region-checked (<span class="name">start</span> end program <span class="symbol">&amp;optional</span> args)</span><br><span class="line">  <span class="string">"Send text from START to END to PROGRAM with ARGS.</span></span><br><span class="line"><span class="string">This is a wrapper around `call-process-region' that doesn't replace</span></span><br><span class="line"><span class="string">the region with the output of PROGRAM if it returned a non-zero</span></span><br><span class="line"><span class="string">exit code."</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">exit</span> (<span class="name">apply</span> 'call-process-region</span><br><span class="line">                     start end</span><br><span class="line">                     program            <span class="comment">; name of program</span></span><br><span class="line">                     <span class="literal">t</span>                  <span class="comment">; delete region</span></span><br><span class="line">                     <span class="literal">t</span>                  <span class="comment">; send output to buffer</span></span><br><span class="line">                     <span class="literal">nil</span>                <span class="comment">; no redisplay during output</span></span><br><span class="line">                     args</span><br><span class="line">                     )))</span><br><span class="line">    (<span class="name">unless</span> (<span class="name">eq</span> exit <span class="number">0</span>) (<span class="name">primitive-undo</span> <span class="number">1</span> buffer-undo-list))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> hlint-refactor-call-process-region-preserve-point (<span class="name">start</span> end program <span class="symbol">&amp;optional</span> args)</span><br><span class="line">  <span class="string">"Send text from START to END to PROGRAM with ARGS preserving the point.</span></span><br><span class="line"><span class="string">This uses `call-process-region-checked' internally."</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">line</span> (<span class="name">line-number-at-pos</span>))</span><br><span class="line">        (<span class="name">column</span> (<span class="name">current-column</span>)))</span><br><span class="line">    (<span class="name">hlint-refactor-call-process-region-checked</span> start end program args)</span><br><span class="line">    (<span class="name">goto-line</span> line)</span><br><span class="line">    (<span class="name">move-to-column</span> column)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;;###autoload</span></span><br><span class="line">(<span class="name">defun</span> hlint-refactor-refactor-buffer (<span class="name">&amp;optional</span> args)</span><br><span class="line">  <span class="string">"Apply all hlint suggestions in the current buffer.</span></span><br><span class="line"><span class="string">ARGS specifies additional arguments that are passed to hlint."</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">hlint-refactor-call-process-region-preserve-point</span></span><br><span class="line">   (<span class="name">point-min</span>)</span><br><span class="line">   (<span class="name">point-max</span>)</span><br><span class="line">   <span class="string">"hlint"</span></span><br><span class="line">   (<span class="name">append</span> '(<span class="string">"--refactor"</span></span><br><span class="line">             <span class="string">"-"</span>)</span><br><span class="line">           args)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;;###autoload</span></span><br><span class="line">(<span class="name">defun</span> hlint-refactor-refactor-at-point ()</span><br><span class="line">  <span class="string">"Apply the hlint suggestion at point."</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">col</span> (<span class="name">number-to-string</span> (<span class="name">+</span> <span class="number">1</span> (<span class="name">current-column</span>))))</span><br><span class="line">        (<span class="name">line</span> (<span class="name">number-to-string</span> (<span class="name">line-number-at-pos</span>))))</span><br><span class="line">    (<span class="name">hlint-refactor-refactor-buffer</span></span><br><span class="line">     (<span class="name">list</span> (<span class="name">concat</span> <span class="string">"--refactor-options=--pos "</span> line <span class="string">","</span> col)))))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;;###autoload</span></span><br><span class="line">(<span class="name">define-minor-mode</span> hlint-refactor-mode</span><br><span class="line">  <span class="string">"Automatically apply hlint suggestions"</span></span><br><span class="line">  <span class="symbol">:lighter</span> <span class="string">" hlint-refactor"</span></span><br><span class="line">  <span class="symbol">:keymap</span> (<span class="name">let</span> ((<span class="name">map</span> (<span class="name">make-sparse-keymap</span>)))</span><br><span class="line">            (<span class="name">define-key</span> map <span class="string">"\C-cb"</span> 'hlint-refactor-refactor-buffer)</span><br><span class="line">            (<span class="name">define-key</span> map <span class="string">"\C-cr"</span> 'hlint-refactor-refactor-at-point)</span><br><span class="line">            map))</span><br><span class="line"></span><br><span class="line">(<span class="name">provide</span> 'hlint-refactor)</span><br><span class="line"></span><br><span class="line"><span class="comment">;;Pre - end</span></span><br><span class="line"></span><br><span class="line">(<span class="name">set-frame-size</span> (<span class="name">selected-frame</span>) <span class="number">140</span> <span class="number">55</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">setenv</span> <span class="string">"PATH"</span> (<span class="name">concat</span> (<span class="name">getenv</span> <span class="string">"PATH"</span>) <span class="string">":/usr/local/bin/"</span>))</span><br><span class="line">(<span class="name">setq</span> exec-path (<span class="name">append</span> exec-path '(<span class="string">"/usr/local/bin/"</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">with-eval-after-load</span> 'tls</span><br><span class="line">    (<span class="name">push</span> <span class="string">"/usr/local/etc/libressl/cert.pem"</span> gnutls-trustfiles))</span><br><span class="line"></span><br><span class="line">(<span class="name">global-linum-mode</span> <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">require</span> 'cl)</span><br><span class="line"></span><br><span class="line">(<span class="name">when</span> (<span class="name">&gt;=</span> emacs-major-version <span class="number">24</span>)</span><br><span class="line">  (<span class="name">require</span> 'package)</span><br><span class="line">  (<span class="name">add-to-list</span></span><br><span class="line">   'package-archives</span><br><span class="line">   '(<span class="string">"melpa"</span> . <span class="string">"http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/"</span>) <span class="literal">t</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">package-initialize</span>)</span><br><span class="line"><span class="comment">;; (package-refresh-contents)</span></span><br><span class="line"></span><br><span class="line">(<span class="name">package-install</span> 'exec-path-from-shell)</span><br><span class="line">(<span class="name">exec-path-from-shell-initialize</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">defvar</span> prelude-packages</span><br><span class="line">  '(haskell-mode)</span><br><span class="line">  <span class="string">"A list of packages to ensure are installed at launch."</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> prelude-packages-installed-p ()</span><br><span class="line">  (<span class="name">loop</span> for p in prelude-packages</span><br><span class="line">        when (<span class="name">not</span> (<span class="name">package-installed-p</span> p)) do (<span class="name">return</span> <span class="literal">nil</span>)</span><br><span class="line">        finally (<span class="name">return</span> <span class="literal">t</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">if</span> (<span class="name">version&lt;=</span> <span class="string">"24.0"</span> emacs-version)</span><br><span class="line">    (<span class="name">unless</span> (<span class="name">prelude-packages-installed-p</span>)</span><br><span class="line">      <span class="comment">;; check for new packages (package versions)</span></span><br><span class="line">      (<span class="name">message</span> <span class="string">"%s"</span> <span class="string">"Emacs Prelude is now refreshing its package database..."</span>)</span><br><span class="line">      (<span class="name">package-refresh-contents</span>)</span><br><span class="line">      (<span class="name">message</span> <span class="string">"%s"</span> <span class="string">" done."</span>)</span><br><span class="line">      <span class="comment">;; install the missing packages</span></span><br><span class="line">      (<span class="name">dolist</span> (<span class="name">p</span> prelude-packages)</span><br><span class="line">        (<span class="name">when</span> (<span class="name">not</span> (<span class="name">package-installed-p</span> p))</span><br><span class="line">          (<span class="name">package-install</span> p)))))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; Haskell</span></span><br><span class="line">(<span class="name">package-install</span> 'flycheck-color-mode-line)</span><br><span class="line">(<span class="name">package-install</span> 'flycheck-pos-tip)</span><br><span class="line">(<span class="name">package-install</span> 'seti-theme)</span><br><span class="line"></span><br><span class="line">(<span class="name">load-theme</span> 'seti <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; COMPLETION</span></span><br><span class="line"></span><br><span class="line">(<span class="name">add-hook</span> 'after-init-hook 'global-company-mode)</span><br><span class="line"></span><br><span class="line"><span class="comment">;shortcut for completion</span></span><br><span class="line">(<span class="name">add-hook</span> 'after-init-hook 'global-company-mode)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-c w"</span>) 'company-complete)</span><br><span class="line"></span><br><span class="line"><span class="comment">;after how many letters do we want to get completion tips? 1 means from the first letter</span></span><br><span class="line">(<span class="name">setq</span> company-minimum-prefix-length <span class="number">1</span>)</span><br><span class="line">(<span class="name">setq</span> company-dabbrev-downcase <span class="number">0</span>)</span><br><span class="line"><span class="comment">;after how long of no keys should we get the completion tips? in seconds</span></span><br><span class="line">(<span class="name">setq</span> company-idle-delay <span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; ERRORS ON THE FLY</span></span><br><span class="line"></span><br><span class="line">(<span class="name">require</span> 'flycheck)</span><br><span class="line">(<span class="name">add-hook</span> 'after-init-hook #'global-flycheck-mode)</span><br><span class="line">(<span class="name">require</span> 'flycheck-color-mode-line)</span><br><span class="line"></span><br><span class="line"><span class="comment">;tooltip errors</span></span><br><span class="line">(<span class="name">require</span> 'flycheck-pos-tip)</span><br><span class="line">(<span class="name">with-eval-after-load</span> 'flycheck</span><br><span class="line">  (<span class="name">flycheck-pos-tip-mode</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> flycheck-pos-tip-timeout <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">with-eval-after-load</span> 'flycheck</span><br><span class="line">  (<span class="name">setq-default</span> flycheck-disabled-checkers '(emacs-lisp-checkdoc)))</span><br><span class="line"></span><br><span class="line">(<span class="name">require</span> 'flycheck-color-mode-line)</span><br><span class="line">(<span class="name">add-hook</span> 'flycheck-mode-hook</span><br><span class="line">  'flycheck-color-mode-line-mode)</span><br><span class="line"></span><br><span class="line">(<span class="name">global-set-key</span> [f9] 'flycheck-list-errors)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> my-haskell-hook ()</span><br><span class="line">  (<span class="name">progn</span></span><br><span class="line">    (<span class="name">hlint-refactor-mode</span>)</span><br><span class="line">    (<span class="name">interactive-haskell-mode</span>)</span><br><span class="line">    (<span class="name">haskell-doc-mode</span>)</span><br><span class="line">    (<span class="name">haskell-indentation-mode</span>)</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">(<span class="name">add-hook</span> 'haskell-mode-hook 'my-haskell-hook)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; install stack mode with shortcut: Alt-s Alt-s</span></span><br><span class="line">(<span class="name">package-install</span> 'hasky-stack)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"M-s M-s"</span>) #'hasky-stack-execute)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; use Shift-arrow keys to move between windows</span></span><br><span class="line">(<span class="name">windmove-default-keybindings</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">require</span> 'haskell-mode)</span><br><span class="line">(<span class="name">define-key</span> haskell-mode-map <span class="string">"\C-ch"</span> 'haskell-hoogle)</span><br><span class="line"><span class="comment">;(setq haskell-hoogle-command "hoogle")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; use M-. on a name in a Haskell buffer which will jump directly to its definition</span></span><br><span class="line">(<span class="name">setq</span> haskell-tags-on-save <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; M-x speedbar</span></span><br><span class="line">(<span class="name">require</span> 'speedbar)</span><br><span class="line">(<span class="name">speedbar-add-supported-extension</span> <span class="string">".hs"</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">custom-set-variables</span></span><br><span class="line"> <span class="comment">;; custom-set-variables was added by Custom.</span></span><br><span class="line"> <span class="comment">;; If you edit it by hand, you could mess it up, so be careful.</span></span><br><span class="line"> <span class="comment">;; Your init file should contain only one such instance.</span></span><br><span class="line"> <span class="comment">;; If there is more than one, they won't work right.</span></span><br><span class="line"> '(haskell-stylish-on-save t)</span><br><span class="line"> '(package-selected-packages</span><br><span class="line">   (quote</span><br><span class="line">    (auto-complete merlin utop tuareg hasky-stack exec-path-from-shell haskell-mode flycheck company))))</span><br><span class="line"></span><br><span class="line">(<span class="name">require</span> 'linum)</span><br><span class="line"></span><br><span class="line">(<span class="name">defvar</span> linum-current-line <span class="number">1</span> <span class="string">"Current line number."</span>)</span><br><span class="line">(<span class="name">defvar</span> linum-border-width <span class="number">1</span> <span class="string">"Border width for linum."</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">defface</span> linum-current-line</span><br><span class="line">  `((<span class="literal">t</span> :inherit linum</span><br><span class="line">       :foreground <span class="string">"goldenrod"</span></span><br><span class="line">       :weight bold</span><br><span class="line">       ))</span><br><span class="line">  <span class="string">"Face for displaying the current line number."</span></span><br><span class="line">  <span class="symbol">:group</span> 'linum)</span><br><span class="line"></span><br><span class="line">(<span class="name">defadvice</span> linum-update (<span class="name">before</span> advice-linum-update activate)</span><br><span class="line">  <span class="string">"Set the current line."</span></span><br><span class="line">  (<span class="name">setq</span> linum-current-line (<span class="name">line-number-at-pos</span>)</span><br><span class="line">        <span class="comment">;; It's the same algorithm that linum dynamic. I only had added one</span></span><br><span class="line">        <span class="comment">;; space in front of the first digit.</span></span><br><span class="line">        linum-border-width (<span class="name">number-to-string</span></span><br><span class="line">                            (<span class="name">+</span> <span class="number">1</span> (<span class="name">length</span></span><br><span class="line">                                  (<span class="name">number-to-string</span></span><br><span class="line">                                   (<span class="name">count-lines</span> (<span class="name">point-min</span>) (<span class="name">point-max</span>))))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> linum-highlight-current-line (<span class="name">line-number</span>)</span><br><span class="line">  <span class="string">"Highlight the current line number using `linum-current-line' face."</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">face</span> (<span class="name">if</span> (<span class="name">=</span> line-number linum-current-line)</span><br><span class="line">                  'linum-current-line</span><br><span class="line">                'linum)))</span><br><span class="line">    (<span class="name">propertize</span> (<span class="name">format</span> (<span class="name">concat</span> <span class="string">"%"</span> linum-border-width <span class="string">"d"</span>) line-number)</span><br><span class="line">                'face face)))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> linum-format 'linum-highlight-current-line)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>效果如下图所示，hlint代码建议：</p><p><img src="/image/aquamacs_haskell.png" alt="hlint 与 haskell mode 配合"></p><p>代码补全，有了intero可以不需要ghc-mod：</p><p><img src="/image/aquamacs_auto.png" alt="intero 的 autocomplete"></p><h3 id="2019年补充"><a href="#2019年补充" class="headerlink" title="2019年补充"></a>2019年补充</h3><p>Visual Studio Code可以说已经取代了曾经<a href="https://atom.io" target="_blank" rel="noopener">Atom</a>的地位，而且随着生态的不断完善已经可以胜任基本的开发工作。有一种可以说「一键式」的开发环境就是利用<a href="https://github.com/haskell/haskell-ide-engine" target="_blank" rel="noopener">Haskell Language Server</a>搭配任意你喜欢的Editor。这里我配置了一个VS Code的环境，HIE相对来讲配置简单，可以参考官方指南。相比于我自己的配置，最明显的多了<a href="https://github.com/alanz/HaRe" target="_blank" rel="noopener">HaRe</a>和<a href="https://ucsd-progsys.github.io/liquidhaskell-blog/" target="_blank" rel="noopener">LiquidHaskell</a>两个神器，这些全部配套起来再加上<code>stack ghci</code>完全可以作为胜任生产环境的工业级的IDE。使用效果：</p><p><img src="/image/hie.jpg" alt="VS Code + Haskell Language Server"></p><p>集成LiquidHaskell做形式验证的效果：</p><p><img src="/image/liquid.jpg" alt="LiquidHaskell"></p><p>配置过程中可能遇到的<a href="https://qiita.com/waddlaw/items/b83cd10311200095fe87" target="_blank" rel="noopener">问题</a>，还有需要安装<code>awk</code>通过<code>brew install awk</code>。可以配合其他VS Code的<a href="https://marketplace.visualstudio.com/items?itemName=hoovercj.haskell-linter" target="_blank" rel="noopener">hlint</a>插件使用。 </p><p>附：有一款为<code>Mac</code>开发的App推荐：<a href="http://haskellformac.com" target="_blank" rel="noopener">Haskell for Mac</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两年之前撰文 &lt;a href=&quot;https://izhen.me/2016/10/21/Atom-Haskell-IDE/&quot;&gt;Haskell的Atom IDE伪装&lt;/a&gt;，那时刚离开英国，因为在旁听一门大一新生的&lt;a href=&quot;https://www.inf.ed.ac.uk/teaching/courses/inf1/fp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;函数式编程入门课&lt;/a&gt;时某个契机启发了主讲教授，便委托我撰写了一个配置指南。期间我们还因为依赖的安装互相通过邮件交流了很多。现在当我再次去网站上浏览时发觉atom是仅剩的指导了，说来惭愧，我现在不怎么用atom了，使用atom取代emacs并不是我的本意，至少我并不希望任何一款editor占据主导地位。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="Haskell" scheme="http://izhen.me/tags/Haskell/"/>
    
      <category term="IDE" scheme="http://izhen.me/tags/IDE/"/>
    
      <category term="Emacs" scheme="http://izhen.me/tags/Emacs/"/>
    
      <category term="Intero" scheme="http://izhen.me/tags/Intero/"/>
    
      <category term="HIE" scheme="http://izhen.me/tags/HIE/"/>
    
      <category term="SSL" scheme="http://izhen.me/tags/SSL/"/>
    
      <category term="Mac OS X" scheme="http://izhen.me/tags/Mac-OS-X/"/>
    
      <category term="VS Code" scheme="http://izhen.me/tags/VS-Code/"/>
    
  </entry>
  
  <entry>
    <title>并行归并排序</title>
    <link href="http://izhen.me/2018/07/18/parallelmerge/"/>
    <id>http://izhen.me/2018/07/18/parallelmerge/</id>
    <published>2018-07-17T19:26:59.000Z</published>
    <updated>2018-07-18T15:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>归并排序是一种应用分治思想的稳定排序算法，算法分为两段，第一段先分数据，一直分到每个单元不能再二分为止。然后进入第二段归并，就是不断将有序的两段合并成一段。因为每次的分治阶段，也就是第一阶段中的每段之间在归并之前相互之间没有数据依赖，所以可以尝试并行实现。<br><a id="more"></a></p><h2 id="直接多线程实现分析"><a href="#直接多线程实现分析" class="headerlink" title="直接多线程实现分析"></a>直接多线程实现分析</h2><p>用<code>Thread</code>直接实现，首先我们要实现串行的算法，然后并行化。并行时每次遇到划分就生成新的线程，当线程资源耗尽时，就调用串行算法。每次划分都要<code>join()</code>归并结果，分治处理后的结果可以用<code>merge</code>方法合并。所以其实我们也仅仅只能做到一部分时间的加速(想想为什么)，同时也受到系统本身硬件线程数量的制约。根据 <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law" target="_blank" rel="noopener">Amdahl定律</a> 面对复杂问题时，我们很难实现理想的线性加速比。</p><h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] mergeArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        mergeArray = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">parallelMergeSort</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> low, <span class="keyword">final</span> <span class="keyword">int</span> high, <span class="keyword">final</span> <span class="keyword">int</span> numOfThread)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (numOfThread &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                mergeSort(low, high);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            Thread leftSorter = parallelMergeSort(low, mid, numOfThread / <span class="number">2</span>);</span><br><span class="line">            Thread rightSorter = parallelMergeSort(mid + <span class="number">1</span>, high, numOfThread / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            leftSorter.start();</span><br><span class="line">            rightSorter.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                leftSorter.join();</span><br><span class="line">                rightSorter.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            merge(low, mid, high);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt;= high)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        mergeSort(low, mid);</span><br><span class="line">        mergeSort(mid + <span class="number">1</span>, high);</span><br><span class="line">        merge(low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low; i &lt;= high; i++)</span><br><span class="line">            mergeArray[i] = nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = low;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mergeArray[i] &lt;= mergeArray[j])&#123;</span><br><span class="line">                nums[k++] = mergeArray[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k++] = mergeArray[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid)&#123;</span><br><span class="line">            nums[k++] = mergeArray[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= high)&#123;</span><br><span class="line">            nums[k++] = mergeArray[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> java.lang.Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//test here</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = random.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MergeSort mergeSort = <span class="keyword">new</span> MergeSort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        Thread thread = mergeSort.parallelMergeSort(<span class="number">0</span>, nums.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(endTime - currentTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[i] = random.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MergeSort mergeSort2 = <span class="keyword">new</span> MergeSort(nums);</span><br><span class="line"></span><br><span class="line">        currentTime = System.currentTimeMillis();</span><br><span class="line">        Thread thread2 = mergeSort2.parallelMergeSort(<span class="number">0</span>, nums.length - <span class="number">1</span>, Runtime.getRuntime().availableProcessors());</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.join();</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(endTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fork-Join框架分析"><a href="#Fork-Join框架分析" class="headerlink" title="Fork/Join框架分析"></a>Fork/Join框架分析</h2><p>直接多线程的弊端：</p><ol><li>线程本身的上下文切换占用的资源较多</li><li>实际的控制是我们自己完成的，其实上述实现并没有充分发挥全部线程，譬如说我们想要4个线程的并行能力，如果用上述实现应指定7条。想想为什么</li></ol><p>这里用<code>Java 7</code>提供的更好的<code>Fork/Join</code>来实现，如果说这种实现有什么好处，第一点就是更加高级，相较于我们确实能用<code>synchronize/wait/notify</code>这种同步原语去实现而言要简单多了。第二点就是拥有诸如负载均衡、工作窃取等很多优秀的特性。这些在这里不详细阐述，感兴趣可以查阅相关资料。</p><p>具体的实现很类似上述代码，只要稍作修改即可。只是我们不主动调用<code>fork()</code>，改用<code>invokeAll()</code>方法，这个方法的好处是在分派任务会给当前线程留一个，因此可以用满所有线程。</p><h2 id="完整实现-1"><a href="#完整实现-1" class="headerlink" title="完整实现"></a>完整实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.mergeSort(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = nums.length / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] left = Arrays.copyOfRange(nums, <span class="number">0</span>, mid);</span><br><span class="line">        <span class="keyword">int</span>[] right = Arrays.copyOfRange(nums, mid + <span class="number">1</span>, nums.length);</span><br><span class="line"></span><br><span class="line">        MergeSort leftSorter = <span class="keyword">new</span> MergeSort(left);</span><br><span class="line">        MergeSort rightSorter = <span class="keyword">new</span> MergeSort(right);</span><br><span class="line"></span><br><span class="line">        invokeAll(leftSorter, rightSorter);</span><br><span class="line"></span><br><span class="line">        merge(left, right, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = nums.length / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] left = Arrays.copyOfRange(nums, <span class="number">0</span>, mid);</span><br><span class="line">        <span class="keyword">int</span>[] right = Arrays.copyOfRange(nums, mid + <span class="number">1</span>, nums.length);</span><br><span class="line"></span><br><span class="line">        mergeSort(left);</span><br><span class="line">        mergeSort(right);</span><br><span class="line"></span><br><span class="line">        merge(left, right, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] low, <span class="keyword">int</span>[] high, <span class="keyword">int</span>[] original)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; low.length &amp;&amp; j &lt; high.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (low[i] &lt;= high[j])&#123;</span><br><span class="line">                original[k++] = low[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                original[k++] = high[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; low.length)&#123;</span><br><span class="line">            original[k++] = low[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; high.length)&#123;</span><br><span class="line">            original[k++] = high[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> java.lang.Exception</span>&#123;</span><br><span class="line">        <span class="comment">//test here</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000000</span>];</span><br><span class="line">        <span class="keyword">int</span>[] nums2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = random.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        MergeSort mergeSort = <span class="keyword">new</span> MergeSort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        mergeSort.mergeSort(nums);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(endTime - currentTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums2[i] = random.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MergeSort mergeSort2 = <span class="keyword">new</span> MergeSort(nums2);</span><br><span class="line"></span><br><span class="line">        currentTime = System.currentTimeMillis();</span><br><span class="line">        forkJoinPool.invoke(mergeSort2);</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(endTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际测试的时候要注意<code>缓存</code>和<code>Intel睿频</code>技术可能造成的影响，每次测试最好生成不同的测试数据。很多分治思想的算法均可以并行实现，比如找限定范围内所有的素数(有负载均衡问题)，找最大值，求数列的和等。与归并排序一样，快排也是分治思想，所以也可以并行实现。</p><p><a href="">Java 8</a> 之后加入了<code>Stream</code>的支持，进一步扩充了并行的特性。有关此概念可以参考函数式编程的内容。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>可以参考《计算机体系结构》、《多处理编程的艺术》与《算法导论》的相关章节进行进一步的理论分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;归并排序是一种应用分治思想的稳定排序算法，算法分为两段，第一段先分数据，一直分到每个单元不能再二分为止。然后进入第二段归并，就是不断将有序的两段合并成一段。因为每次的分治阶段，也就是第一阶段中的每段之间在归并之前相互之间没有数据依赖，所以可以尝试并行实现。&lt;br&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="Algorithm" scheme="http://izhen.me/tags/Algorithm/"/>
    
      <category term="parallel" scheme="http://izhen.me/tags/parallel/"/>
    
      <category term="Java" scheme="http://izhen.me/tags/Java/"/>
    
      <category term="merge sort" scheme="http://izhen.me/tags/merge-sort/"/>
    
      <category term="multithread" scheme="http://izhen.me/tags/multithread/"/>
    
      <category term="fork/join" scheme="http://izhen.me/tags/fork-join/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希Java实现</title>
    <link href="http://izhen.me/2018/07/15/consistentHash/"/>
    <id>http://izhen.me/2018/07/15/consistentHash/</id>
    <published>2018-07-14T19:26:59.000Z</published>
    <updated>2018-07-15T05:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在缓存服务的负载均衡领域，会遇到一种问题：考虑到我们可以通过哈希算法实现用户结点到服务结点的常数时间映射，但是如果服务器遇到上下线的问题，会使得原本的映射面临大范围的失效。比如用户A指向5号服务器，某个时刻5号服务器突然宕机，其他的服务器则需要替补5号服务的位置。此时我们使用的是<strong>直接</strong>映射方案，因此除了5号服务器，也包括替补服务器(可能是6号替补5号，这时原本6号的位置需要7号替补，以此类推)的全部缓存数据均需要更新。</p><p>这就带来了不一致问题。<br><a id="more"></a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这种不一致问题的根源是直接映射的不灵活性造成的，相当于任何一个用户一旦得到Hash值就会与某一特定服务器永久绑定。缺点就是服务端的变化会带来大面积的重新映射，而新的映射被迫要重新加载缓存。考虑到如果用户A的服务器映射失效，那么只需要把用户A重新关联到其他服务器上，这样就避免了很多不必要的影响，也既维护了一致性。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用 <a href="https://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">Consistent Hashing</a>，理论分析参考 <a href="https://dl.acm.org/citation.cfm?id=258660" target="_blank" rel="noopener">原始论文</a>。基本原理就是从直接的映射变为间接映射，每次算出Hash值后再多一个寻找临近服务器的过程。</p><p><img src="/image/consistent_hashing.jpg" alt="图源自网络，侵删"></p><p>可以使用一些高效的数据结构维护服务器列表，Key是Hash值，Value是服务器地址。要求具备有序性，可以用TreeMap或者SkipList，二者的效率都很高。考虑到哈希的场景通常用于负载均衡领域，所以我们还要照顾平衡性，也就是尽可能均匀。在Hash算法的选取上可以使用MD5，想象所有的映射在一个环上，用户结点对应的服务器就是在环上与自己距离最近的一个，如果当前服务器下线，那么重新寻找与自己距离最近的就可以了。</p><p>在环上有一种可能，如果所有的服务器分布比较集中，也容易造成用户结点映射不均衡。这时我们引入虚拟结点的概念，每一个真实结点对应N个虚拟结点，把每个虚拟结点都映射到环上，这样可以很大程度避免不平衡的问题。而用户只要找到虚拟结点就能映射到真实结点了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>在计算MD5的时候，用到了一些掩码技巧，请参考<a href="https://my.oschina.net/joymufeng/blog/139952" target="_blank" rel="noopener">这里</a>。关于Java自身的MD5算法的解读，请参考<a href="https://docs.oracle.com/javase/7/docs/api/java/security/MessageDigest.html" target="_blank" rel="noopener">这里</a>。</p><h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHash</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳表对于查找和遍历均有不错的执行效率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> SortedMap&lt;Long, T&gt; virtualNodes = <span class="keyword">new</span> ConcurrentSkipListMap();</span><br><span class="line">    <span class="keyword">private</span> MessageDigest md5 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRTUAL_NODES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始服务器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] servers = &#123;</span><br><span class="line">            <span class="string">"192.168.0.1:8080"</span>,</span><br><span class="line">            <span class="string">"192.168.0.2:8080"</span>,</span><br><span class="line">            <span class="string">"192.168.0.3:8080"</span>,</span><br><span class="line">            <span class="string">"192.168.0.4:8080"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsistentHash</span><span class="params">(<span class="keyword">int</span> numberOfVirtualNodes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.VIRTUAL_NODES = numberOfVirtualNodes;</span><br><span class="line">        <span class="keyword">for</span> (String x : servers)&#123;</span><br><span class="line">            addServer((T) x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addServer</span><span class="params">(T serverAddr)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"True Node: "</span> + serverAddr.toString() + <span class="string">" will be put in the circle"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODES; i++) &#123;</span><br><span class="line">            String nodeAddr = serverAddr.toString() + <span class="string">"#Virtual:"</span> + i;</span><br><span class="line">            <span class="keyword">long</span> hash = getConsistentHash(nodeAddr);</span><br><span class="line">            System.out.println(<span class="string">"Virtual Node: "</span> + nodeAddr + <span class="string">" has been added with hash code: "</span> + hash);</span><br><span class="line">            virtualNodes.put(hash, serverAddr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteServer</span><span class="params">(T deleteAddr)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"True Node: "</span> + deleteAddr.toString() + <span class="string">" will be removed from the circle"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODES; i++) &#123;</span><br><span class="line">            String nodeAddr = deleteAddr.toString() + <span class="string">"#Virtual:"</span> + i;</span><br><span class="line">            <span class="keyword">long</span> hash = getConsistentHash(nodeAddr);</span><br><span class="line">            System.out.println(<span class="string">"Virtual Node: "</span> + nodeAddr + <span class="string">" has been removed by hash code: "</span> + hash);</span><br><span class="line">            virtualNodes.remove(hash);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getConsistentHash</span><span class="params">(String addr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(md5 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (NoSuchAlgorithmException e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重置</span></span><br><span class="line">        md5.reset();</span><br><span class="line">        <span class="comment">//添加要计算的摘要信息</span></span><br><span class="line">        md5.update(addr.getBytes());</span><br><span class="line">        <span class="comment">//计算摘要</span></span><br><span class="line">        <span class="keyword">byte</span>[] bKey = md5.digest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 得到的byte分为4段，分段取出，然后组合在一起</span></span><br><span class="line"><span class="comment">         * byte是有符号8位，long比byte长，这时候如果想实现无符号扩展，要用掩码来限制</span></span><br><span class="line"><span class="comment">         * 0xFF默认int类型，最低8位是1111 1111，前面24位均为0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> result = ((<span class="keyword">long</span>) (bKey[<span class="number">3</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>) | ((<span class="keyword">long</span>) (bKey[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span> |</span><br><span class="line">                      ((<span class="keyword">long</span>) (bKey[<span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>) | (<span class="keyword">long</span>) (bKey[<span class="number">0</span>] &amp; <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getServer</span><span class="params">(Object userNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!virtualNodes.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">long</span> hash = getConsistentHash((String) userNode);</span><br><span class="line">            SortedMap&lt;Long, T&gt; tailMap = virtualNodes.tailMap(hash);</span><br><span class="line">            hash = tailMap.isEmpty() ? virtualNodes.firstKey() : tailMap.firstKey();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> virtualNodes.get(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//test case here</span></span><br><span class="line">        ConsistentHash&lt;String&gt; consistentHash = <span class="keyword">new</span> ConsistentHash&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(consistentHash.getServer(<span class="string">"192.168.155.155:8080"</span>));</span><br><span class="line">        System.out.println(consistentHash.getServer(<span class="string">"192.168.2.155:8080"</span>));</span><br><span class="line">        System.out.println(consistentHash.getServer(<span class="string">"192.168.155.134:8080"</span>));</span><br><span class="line"></span><br><span class="line">        consistentHash.deleteServer(<span class="string">"192.168.0.1:8080"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(consistentHash.getServer(<span class="string">"192.168.155.155:8080"</span>));</span><br><span class="line">        System.out.println(consistentHash.getServer(<span class="string">"192.168.2.155:8080"</span>));</span><br><span class="line">        System.out.println(consistentHash.getServer(<span class="string">"192.168.155.134:8080"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>注意到，在删除服务结点<code>192.168.0.1:8080</code>后，原本指向<code>192.168.0.4:8080</code>的用户结点不受影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">True Node: 192.168.0.1:8080 will be put <span class="keyword">in</span> the circle</span><br><span class="line">Virtual Node: 192.168.0.1:8080<span class="comment">#Virtual:0 has been added with hash code: 3991322147</span></span><br><span class="line">Virtual Node: 192.168.0.1:8080<span class="comment">#Virtual:1 has been added with hash code: 2054636666</span></span><br><span class="line">Virtual Node: 192.168.0.1:8080<span class="comment">#Virtual:2 has been added with hash code: 1058881351</span></span><br><span class="line">True Node: 192.168.0.2:8080 will be put <span class="keyword">in</span> the circle</span><br><span class="line">Virtual Node: 192.168.0.2:8080<span class="comment">#Virtual:0 has been added with hash code: 349956815</span></span><br><span class="line">Virtual Node: 192.168.0.2:8080<span class="comment">#Virtual:1 has been added with hash code: 2893347203</span></span><br><span class="line">Virtual Node: 192.168.0.2:8080<span class="comment">#Virtual:2 has been added with hash code: 967431380</span></span><br><span class="line">True Node: 192.168.0.3:8080 will be put <span class="keyword">in</span> the circle</span><br><span class="line">Virtual Node: 192.168.0.3:8080<span class="comment">#Virtual:0 has been added with hash code: 713816566</span></span><br><span class="line">Virtual Node: 192.168.0.3:8080<span class="comment">#Virtual:1 has been added with hash code: 3143344329</span></span><br><span class="line">Virtual Node: 192.168.0.3:8080<span class="comment">#Virtual:2 has been added with hash code: 2073965171</span></span><br><span class="line">True Node: 192.168.0.4:8080 will be put <span class="keyword">in</span> the circle</span><br><span class="line">Virtual Node: 192.168.0.4:8080<span class="comment">#Virtual:0 has been added with hash code: 999813558</span></span><br><span class="line">Virtual Node: 192.168.0.4:8080<span class="comment">#Virtual:1 has been added with hash code: 1089387445</span></span><br><span class="line">Virtual Node: 192.168.0.4:8080<span class="comment">#Virtual:2 has been added with hash code: 3541119725</span></span><br><span class="line">192.168.0.1:8080</span><br><span class="line">192.168.0.1:8080</span><br><span class="line">192.168.0.4:8080</span><br><span class="line">True Node: 192.168.0.1:8080 will be removed from the circle</span><br><span class="line">Virtual Node: 192.168.0.1:8080<span class="comment">#Virtual:0 has been removed by hash code: 3991322147</span></span><br><span class="line">Virtual Node: 192.168.0.1:8080<span class="comment">#Virtual:1 has been removed by hash code: 2054636666</span></span><br><span class="line">Virtual Node: 192.168.0.1:8080<span class="comment">#Virtual:2 has been removed by hash code: 1058881351</span></span><br><span class="line">192.168.0.3:8080</span><br><span class="line">192.168.0.3:8080</span><br><span class="line">192.168.0.4:8080</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在缓存服务的负载均衡领域，会遇到一种问题：考虑到我们可以通过哈希算法实现用户结点到服务结点的常数时间映射，但是如果服务器遇到上下线的问题，会使得原本的映射面临大范围的失效。比如用户A指向5号服务器，某个时刻5号服务器突然宕机，其他的服务器则需要替补5号服务的位置。此时我们使用的是&lt;strong&gt;直接&lt;/strong&gt;映射方案，因此除了5号服务器，也包括替补服务器(可能是6号替补5号，这时原本6号的位置需要7号替补，以此类推)的全部缓存数据均需要更新。&lt;/p&gt;
&lt;p&gt;这就带来了不一致问题。&lt;br&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="Algorithm" scheme="http://izhen.me/tags/Algorithm/"/>
    
      <category term="Consistent Hash" scheme="http://izhen.me/tags/Consistent-Hash/"/>
    
      <category term="Java" scheme="http://izhen.me/tags/Java/"/>
    
      <category term="Skip List" scheme="http://izhen.me/tags/Skip-List/"/>
    
  </entry>
  
  <entry>
    <title>判定给定图是否为二分图</title>
    <link href="http://izhen.me/2018/07/13/Bipartite/"/>
    <id>http://izhen.me/2018/07/13/Bipartite/</id>
    <published>2018-07-12T19:26:59.000Z</published>
    <updated>2018-07-13T13:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述请参考 <a href="https://leetcode.com/problems/is-graph-bipartite/description/" target="_blank" rel="noopener">LeetCode - 785</a><br><a id="more"></a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>二分图的充要条件是：任何一个结点回路的长度为偶数。</p><p>所以我们如果将定义实现就是一个正确的方法了。但是有个问题，这样需要穷举判定全部的回路，时间复杂度过高。<br>简单办法（参考引申）：任选一个结点开始进行黑白交叉染色，起点开始奇数距离路径的结点全部都跟自己异色，偶数则同色。否则必然不是二分图，这一点也与定义一致，考虑到全部偶数距离的路径也包括回路，所以必是同色。因此当我们染色发生矛盾时就能知道这张图就不是二分图了。</p><p>*引申：任选一个结点a放入A集合，若给定图是二分图，则所有到a路径长度为偶数的结点均可放入A集合，否则均可放入A’集合，A与A’构成二分图。</p><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        size = len(graph)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> graph:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        edge, que, color, has = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(size)], [], [<span class="number">0</span>] * size, []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x, i <span class="keyword">in</span> enumerate(graph):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> i:</span><br><span class="line">                edge[x][y] = edge[y][x] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> color[i] == <span class="number">0</span>:</span><br><span class="line">                que.append(i)</span><br><span class="line">                color[i] = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">                <span class="keyword">while</span> que:</span><br><span class="line">                    curr = que.pop()</span><br><span class="line">                    has.append(curr)</span><br><span class="line">            </span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size):</span><br><span class="line">                        <span class="keyword">if</span> edge[curr][i]:</span><br><span class="line">                            <span class="keyword">if</span> color[i] == <span class="number">0</span>:</span><br><span class="line">                                color[i] = -color[curr]</span><br><span class="line">                            <span class="keyword">elif</span> color[i] == color[curr]:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">False</span>                    </span><br><span class="line">                            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> has:</span><br><span class="line">                                que.append(i)     </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目描述请参考 &lt;a href=&quot;https://leetcode.com/problems/is-graph-bipartite/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode - 785&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="Algorithm" scheme="http://izhen.me/tags/Algorithm/"/>
    
      <category term="二分图" scheme="http://izhen.me/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="交叉染色" scheme="http://izhen.me/tags/%E4%BA%A4%E5%8F%89%E6%9F%93%E8%89%B2/"/>
    
      <category term="判定" scheme="http://izhen.me/tags/%E5%88%A4%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>女神异闻录5</title>
    <link href="http://izhen.me/2018/05/19/persona5/"/>
    <id>http://izhen.me/2018/05/19/persona5/</id>
    <published>2018-05-19T06:46:13.000Z</published>
    <updated>2018-05-20T10:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/p5/2.jpg" alt="JRPG神作 - P5"></p><p>「女神异闻录」系列最新版，时隔10年的后继作品。我还在英国的时候打穿了上一代的<a href="">黄金版</a>，本代同样制作精良但是内容和品质基本做到了可以触及的极致。<a href="">P4G</a> 的一贯套路延续，<del>披着RPG外壳的GalGame</del>或许是本作有如此之高人气的原因之一吧。其实相当多传统日系RPG游戏大多以欧洲风格的设定做为主世界观，Persona系列则非比寻常的采用现代日本，尽管<a href="">伊戈尔</a>常在，但每一代都发生于不同地点，也有着各自不同的传说。时尚、发人深思、中二、有趣等都不足以形容这款游戏为玩家所带来的感受，相信只有打通至少两个周目后才能有充分的认知吧~</p><a id="more"></a><h3 id="纵观"><a href="#纵观" class="headerlink" title="纵观"></a>纵观</h3><p>其实还是一个可以从现实进入异世界的套路，但是和上一代的目的不一致，上一代的格局要小一些：大体可以看做是在一个小镇上抓捕杀人犯到最后发现其实真凶是真女主的另一个人格的奇异物语。当然主要玩的不仅仅是主线剧情，作为传承回合制战斗系统的角色扮演又不让人玩的太累，游戏中的丰富元素和以日期作为事件最小单位的设计可以说非常新颖。</p><p><img src="/image/p5/1.jpg" alt="P4G"></p><p>本作则上升到了对于社会人性研究的一个角度，不好说是不是大格局，也因此使得整部作品的基调稍显昏暗，至少我个人觉得发人深省这一点还是有做到的。</p><h3 id="过场动画"><a href="#过场动画" class="headerlink" title="过场动画"></a>过场动画</h3><p>使用整段2D动画作为剧情过场动画我还是第一次见，可以说这个手法发挥了本土优势的同时，让游戏沾染上一层别样的味道。如果是经常看动漫的玩家会觉得浸入感十足，很享受这些用心的地方。上一代作品其实是 <a href="">PS2</a> 游戏的复刻，本作是在四公主平台上，跨越了两代主机画质的提升是显然的，人物的立绘也更精彩，这一点在过场动画中体现的不是很多。</p><p><img src="/image/p5/3.jpg" alt="Production I.G.制作的过场动画"></p><h3 id="吉祥物"><a href="#吉祥物" class="headerlink" title="吉祥物"></a>吉祥物</h3><p>每一代都会有个吉祥物一样的指导者跟随着你，上一代是个小熊。本作是一只黑色猫咪，除了游戏过程一些莫名其妙的情节外，我觉得它可以算是刻画的最成功的角色了。配音和《海贼王》里的乔巴以及皮卡丘都是同一人。跟龙司拌嘴吵架的时候非常可爱，又是一直在主人公身旁不离不弃的贤内助。最后与主人公一同返回了家乡。</p><p><img src="/image/p5/4.jpg" alt="Mona"></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>有着比上作更广阔的场景，场景的丰富程度也反映在游戏长度上面，我在仅仅收集了54%的人格面具的情况下通关也花掉了我95个小时。XD<br>这个游戏长度也证实了制作团队着实想呈现给各位玩家的良心，<a href="">P5</a> 并不算一款完美的游戏，不过卓越确确实实已经是了。</p><p><img src="/image/p5/5.jpg" alt="Rain"></p><p>上一代的故事展开在一座无名的小镇当中，本作则使用了繁华的东京，我个人觉得如果如果不是故意要动漫风格的渲染，那么贴图还是比较粗糙，还不能达到次世代3A大作的画面标准。这个也许受限于技术或者经费，也算不上什么瑕疵。另一方面，本作的UI设计的不错，几处界面切换做的挺惊艳。</p><p><img src="/image/p5/6.jpg" alt="After school"></p><h3 id="COOP"><a href="#COOP" class="headerlink" title="COOP"></a>COOP</h3><p>重中之重的COOP系统可以说托起了整部作品的灵魂。我觉得玩「女神异闻录」主要玩的就是这个部分，除了起到推进剧情的作用外，与各个人物关系每每发展到一定程度，都会解锁一些很好用的技能，这些技能可以用在很多方面，比如战斗加成、日常加成等等。与主角团队的发展最终还能促成人格面具的超觉醒和对应种类最高人格面具的解锁。女性角色还能发展伴侣关系，感觉游戏的一些精华全部都集中在这里了。</p><p><img src="/image/p5/7.jpg" alt="奥村春"></p><h3 id="战斗、结语"><a href="#战斗、结语" class="headerlink" title="战斗、结语"></a>战斗、结语</h3><p>RPG的战斗没什么好提及的，我相信制作团队也知道人们早已对回合制审美疲劳了，也正因此「女神异闻录」没有在战斗本身强加太大难度，当合成的人格面具越来越强的时候，打怪是很有爽快感的。合成人格面具是本作一个特色，有些特定日子阴影甚至会得流感，这个时候如果去印象空间挑战死神的话有惊喜~</p><p>和上一代的风格有一些差异，我可能更喜欢上一代的人设，虽然总发生杀人事件，不过整体氛围还是比本代轻松明快一点。抛开这些主观的，本代相较于上一代是全面的提升。美中不足的是无论本作还是上一部都不能随心所欲的换装，还得专门买DLC才行，而且初始设定的服装都不好看，就连杏去兼职模特摄影的服装都让人觉得是随意拼凑的。我觉得日本不缺优秀的设计师，可以找个设计师设计一下。就比如 <a href="https://www.youtube.com/watch?v=nrnAD5ua_UM" target="_blank" rel="noopener">FF15</a> 与 <a href="https://www.youtube.com/watch?v=nrnAD5ua_UM" target="_blank" rel="noopener">Vivienne</a> 合作设计了婚纱，我记得 <a href="https://www.youtube.com/watch?v=jbPDeT5A6uw" target="_blank" rel="noopener">FF13</a> 也与 <a href="https://www.youtube.com/watch?v=jbPDeT5A6uw" target="_blank" rel="noopener">LV</a> 有过类似合作。既然「女神异闻录」越来越时尚何不考虑跨界合作一下呢~</p><p>最后，相信每一位玩家都能从P5中找到属于自己的独特品味。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/image/p5/2.jpg&quot; alt=&quot;JRPG神作 - P5&quot;&gt;&lt;/p&gt;
&lt;p&gt;「女神异闻录」系列最新版，时隔10年的后继作品。我还在英国的时候打穿了上一代的&lt;a href=&quot;&quot;&gt;黄金版&lt;/a&gt;，本代同样制作精良但是内容和品质基本做到了可以触及的极致。&lt;a href=&quot;&quot;&gt;P4G&lt;/a&gt; 的一贯套路延续，&lt;del&gt;披着RPG外壳的GalGame&lt;/del&gt;或许是本作有如此之高人气的原因之一吧。其实相当多传统日系RPG游戏大多以欧洲风格的设定做为主世界观，Persona系列则非比寻常的采用现代日本，尽管&lt;a href=&quot;&quot;&gt;伊戈尔&lt;/a&gt;常在，但每一代都发生于不同地点，也有着各自不同的传说。时尚、发人深思、中二、有趣等都不足以形容这款游戏为玩家所带来的感受，相信只有打通至少两个周目后才能有充分的认知吧~&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game" scheme="http://izhen.me/tags/Game/"/>
    
      <category term="Persona 5" scheme="http://izhen.me/tags/Persona-5/"/>
    
      <category term="JRPG" scheme="http://izhen.me/tags/JRPG/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode - Median of Tow Sorted Arrays</title>
    <link href="http://izhen.me/2018/05/19/leetcode004/"/>
    <id>http://izhen.me/2018/05/19/leetcode004/</id>
    <published>2018-05-19T05:58:03.000Z</published>
    <updated>2018-05-19T06:28:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.<br>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).<br><a id="more"></a></p><h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><p>这道题在处理题目的模型和实现上都稍微有点难度。</p><p>这里我们先讨论普通的二分查找，就是说我们要确定一个数字的具体排位的时候，比如说第N大的数字。可以维护一个优先队列，期望时间复杂度就是O(nlogm)。《编程珠玑》里面提到的一种更好的方法：借助快排的思想，可以将复杂度优化到O(n)。</p><h3 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h3><p>不过，上面是无序的情况，如果是有序的数字呢？显然，可以O(1)找到对应排位的数字，这个也就是我们要突破的重点。两个有序的序列，找到其中的中位数字。首先我们怎么理解可以帮助我们呢?中位数是<strong>分割一个序列为两个部分，这两个的部分的数字个数相等</strong>。中位数是说排在(n/2)或(n/2, n/2 + 1)的数字。</p><p>所以这道题目就是要我们找到一个中位数，使得两个数列合在一起可以被分成数目相等的两个部分。这样我们重新定义了问题，使得理解更加具体。</p><h3 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h3><ul><li>a[0], a[1], a[2] … a[i - 1]    median   a[i + 1], a[i + 2] … a[n]<br>b[0], b[1], b[2] … b[j - 1]   median   b[j + 1], b[j + 2] … b[m]   </li><li>a[i - 1] &lt; b[j]  <strong>(a)</strong><br>b[j - 1] &lt; a[i]  <strong>(b)</strong></li><li>a[i] == b[j] // 找到了median，中位数不一定同时存在于两个数组中</li></ul><p>如何找到相应的i与j呢？切入口在于我们二分的对象是什么。<br>这里有个隐藏的条件：i + j = n - i + m - j(<strong>中位数两边的数字个数相等</strong>)，也就是说i确定了，j也就可以确定了，这个结论很好，我们只需要枚举其中一个就能解决问题。通常我们需要枚举长度短的序列，这样边界就不会溢出。</p><p>重要结论1：i = (m + n + 1) / 2 - j。<br>这样我们遍历 i 亦或 j 中的一个，就能确定另外一个的值了。<br>我们来搜索 i ：</p><ol><li>如果 a[i] == b[j]，那么我们就找到了最终的结果。</li><li>如果 a[i] &gt; b[j] 说明我们要调整 i，使得a[i]减小，b[j]则相对增大。</li><li>对于2，反之亦然。</li></ol><p>不过，这里要考虑一个情况，要找到的值未必都在两个数列中。比如：[1,2,3,4,5] 和 [6]。更特殊：[1,2], []。<br>这个也是问题的第二个关键点。<br>首先，假设较短的数列已经触及边界，同时不满足约束条件(a), (b)，那么就意味着我们已经找到答案了。原因在于每次的划分都是平衡划分，一个数列触及了边界，答案也就一定在另外一个数列当中，而答案在另一个数列当中的时候就是一个普通的二分查找。显然较短的数列会更快碰到边界。<br>结论2：我们每次搜索需要检查较短数列的边界在合理范围之内。</p><p>搜索结束后，正确答案在哪里？<br>如果两个数列的长度总和为奇数，那么搜索位置较大的那个即为所求。否则要计算两个位置较大的和后继位置较小的数字的均值：</p><p>max(a[i-1], b[j-1]), odd<br>(max(a[i-1], b[j-1]) + min(a[i], b[j])) / 2, even</p><p>边界条件的处理，当 i == 0 或 i == length of list 的时候，这个时候搜索也结束了。对于 j 亦然。</p><h2 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] longNum;</span><br><span class="line">        <span class="keyword">int</span>[] shortNum;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            longNum = nums1;</span><br><span class="line">            shortNum = nums2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            longNum = nums2;</span><br><span class="line">            shortNum = nums1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = shortNum.length, half = (longNum.length + shortNum.length + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> leftHalf = <span class="number">0.0</span>, rightHalf = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = half - i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; shortNum.length &amp;&amp; shortNum[i] &lt; longNum[j - <span class="number">1</span>])</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; longNum[j] &lt; shortNum[i - <span class="number">1</span>])</span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) leftHalf = longNum[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) leftHalf = shortNum[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> leftHalf = Math.max(shortNum[i - <span class="number">1</span>], longNum[j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> ((shortNum.length + longNum.length) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> leftHalf;</span><br><span class="line">                <span class="keyword">if</span> (i == shortNum.length) rightHalf = longNum[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == longNum.length) rightHalf = shortNum[i];</span><br><span class="line">                <span class="keyword">else</span> rightHalf = Math.min(shortNum[i], longNum[j]);</span><br><span class="line">                <span class="keyword">return</span> (leftHalf + rightHalf) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目概述&quot;&gt;&lt;a href=&quot;#题目概述&quot; class=&quot;headerlink&quot; title=&quot;题目概述&quot;&gt;&lt;/a&gt;题目概述&lt;/h2&gt;&lt;p&gt;There are two sorted arrays nums1 and nums2 of size m and n respectively.&lt;br&gt;Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).&lt;br&gt;
    
    </summary>
    
    
      <category term="分治" scheme="http://izhen.me/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>赛博朋克酒保计划</title>
    <link href="http://izhen.me/2018/02/22/cyberpunk/"/>
    <id>http://izhen.me/2018/02/22/cyberpunk/</id>
    <published>2018-02-22T05:50:00.000Z</published>
    <updated>2018-02-22T06:32:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://store.steampowered.com/" target="_blank" rel="noopener">Steam</a>上发现了这样一款游戏，属于AVG类型，不论是艺术表现还是题材都蛮新颖。里面有很多ACG的梗，相对来讲受众面较窄，是一款小众的独立作品。</p><a id="more"></a><h3 id="BACKGROUND"><a href="#BACKGROUND" class="headerlink" title="BACKGROUND"></a>BACKGROUND</h3><p>游戏的背景是一个人工智能主导的未来乌托邦都市。玩家扮演一个酒保在调酒的过程中与诸多客人对话获取情报并不断的推动剧情的发展。貌似有多个结局，需要触发不同的条件来获得。游戏模式就是通过与顾客对话，给顾客调酒或者灌醉对方来进行的。</p><p><img src="/image/cyberpunk/1.jpg" alt="初始画面"></p><p>这个游戏我还没有通关，玩了一段时间后觉得像这样中二的文字解密游戏似乎除了日本外，别国做的不多。如果打算试一试这种类型游戏本人大力推荐。</p><p><img src="/image/cyberpunk/2.jpg" alt="主角"></p><p>游戏是现代游戏，但是全部都用像素风格的艺术形式呈现，跟<a href="">Cave Story</a>表现手法一样，所以虽然这种类型的游戏不多见但不能算是创新。</p><p><img src="/image/cyberpunk/3.jpg" alt="调酒界面"></p><p>调酒方式很简单，只要按照要求配比就好了，只是某些时候可能顾客会提一些奇怪的要求导致你得去猜测他们需要什么样子的鸡尾酒。</p><h3 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h3><p>整个过程还是比较享受的，主要是荤段子相对很多，小朋友请绕道而行。基本上最近几年比较流行的梗都cover到了，长期混迹ACG圈子就比较容易get到里面的点。</p><p><img src="/image/cyberpunk/4.jpg" alt="缸中脑"></p><p><img src="/image/cyberpunk/5.jpg" alt="段子"></p><p><img src="/image/cyberpunk/6.jpg" alt="主线剧情"></p><p>毕竟是文字解密类的游戏，在这里不能透露太多游戏内容，总的来说是一款值得一试的作品。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://store.steampowered.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Steam&lt;/a&gt;上发现了这样一款游戏，属于AVG类型，不论是艺术表现还是题材都蛮新颖。里面有很多ACG的梗，相对来讲受众面较窄，是一款小众的独立作品。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="Game" scheme="http://izhen.me/tags/Game/"/>
    
      <category term="R17" scheme="http://izhen.me/tags/R17/"/>
    
      <category term="Cyberpunk" scheme="http://izhen.me/tags/Cyberpunk/"/>
    
  </entry>
  
  <entry>
    <title>Github Page的DNS与HTTPS设置</title>
    <link href="http://izhen.me/2017/12/24/customdomainforblog/"/>
    <id>http://izhen.me/2017/12/24/customdomainforblog/</id>
    <published>2017-12-24T07:00:13.000Z</published>
    <updated>2017-12-25T14:04:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>我大概从初中开始写博客，第一个<code>Blog</code>，也是非独立的新浪博客，主要目的是写一些<code>Pascal</code>的题目解答。第二个博客则是高中时代维护的<code>百度空间</code>，主要写一些<a href="/2017/08/06/USACO-update/">USACO</a>题解，这个已经消失了。没记错的话，这两个博客都是图形界面的用户定制系统，我可以通过拖动组件来改变页面的布局。而从<a href="./2013/11/07/2014-01-18-basic-octopress-build/">第三个</a>博客开始就是独立的了。<a href="./2014/06/30/hello-world/">这个</a>博客严格来说是我的第四个博客，也是一直都维护在<code>Github</code>上，除了<code>Markdown</code>之外的最大不同大概就是域名的配置稍微与传统博客有点区别。<br><a id="more"></a></p><h3 id="DNS设置"><a href="#DNS设置" class="headerlink" title="DNS设置"></a>DNS设置</h3><p><strong>首先</strong>要在域名提供商那里注册一个域名，我使用的是<a href="https://www.namecheap.com/" target="_blank" rel="noopener">NameCheap</a>。</p><p>我们在部署<code>Hexo</code>的时候(或者其他静态页面)，需要在<code>Github repo</code>的根目录下面创建一个名为<code>CNAME</code>的文件，里面的内容是你注册的域名。然后根据<code>Github</code><a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/" target="_blank" rel="noopener">提供</a>的帮助信息，重点设置<code>A记录</code>，<code>CNAME记录</code>和<code>www</code>等子域名。</p><p><img src="/image/dns.jpg" alt="设置成功的Setting页面"></p><h3 id="HTTPS设置"><a href="#HTTPS设置" class="headerlink" title="HTTPS设置"></a>HTTPS设置</h3><p>我们如果不使用自己的域名而是<code>Github Page</code>默认的，那么本身是自带<code>HTTPS</code>的，否则就不能在浏览器的地址栏看到小绿锁了。同时很多<code>SSL</code>提供商都是以证书安装在服务器的形式，显然不符合我们的需求。不过，我们依旧可以用不需在再服务端安装证书的<code>HTTPS</code>模式。</p><blockquote><p>HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密套件和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的防护</p></blockquote><p>获取<code>HTTPS</code>的步骤：</p><ul><li>注册<a href="https://www.cloudflare.com/" target="_blank" rel="noopener">CloudFlare</a>账号，选择<code>Free website</code>方案</li><li>输入域名进行迁移检测</li><li>在域名注册商的管理页面把<code>Name Server</code>改成<a href="https://www.cloudflare.com/" target="_blank" rel="noopener">CloudFlare</a>给定的地址，通常是下面的形式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noel.ns.cloudflare.com</span><br><span class="line">rita.ns.cloudflare.com</span><br></pre></td></tr></table></figure><p>之后在<code>Crypto</code>选项卡中配置<code>SSL</code>模式，这里我用的是<code>Full</code>模式，注意<code>Full strict</code>模式会要求在服务端安装证书。</p><p><img src="/image/ssl.png" alt="三种SSL方案"></p><p>记得同时配置一下<code>Always use HTTPS</code>，然后静待其生效。</p><h3 id="多个二级域名设置"><a href="#多个二级域名设置" class="headerlink" title="多个二级域名设置"></a>多个二级域名设置</h3><p>名为<code>username.github.io</code>的<code>repo</code>可以设置<code>CNAME</code>为<code>blog.izhen.me</code>这样的形式，之后要在<code>DNS</code>供应商那边设置<code>CNAME</code>。</p><p>因为一个<code>repo</code>只能设置一个<code>CNAME</code>，所以如果要设置多个二级域名的话就要新建<code>Github Page</code>的<code>repo</code>然后编辑<code>CNAME</code>类似于<code>resume.izhen.me</code>的形式。在<code>DNS</code>设置中也要创建一个<code>CNAME</code>记录到<code>username.github.io.</code>，其中<code>username</code>就是你的账户名。</p><p>这里要注意，<code>repo</code>中的<code>CNAME</code>和<code>DNS</code>设置里的<code>CNAME</code>有关联，但是不同。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我大概从初中开始写博客，第一个&lt;code&gt;Blog&lt;/code&gt;，也是非独立的新浪博客，主要目的是写一些&lt;code&gt;Pascal&lt;/code&gt;的题目解答。第二个博客则是高中时代维护的&lt;code&gt;百度空间&lt;/code&gt;，主要写一些&lt;a href=&quot;/2017/08/06/USACO-update/&quot;&gt;USACO&lt;/a&gt;题解，这个已经消失了。没记错的话，这两个博客都是图形界面的用户定制系统，我可以通过拖动组件来改变页面的布局。而从&lt;a href=&quot;./2013/11/07/2014-01-18-basic-octopress-build/&quot;&gt;第三个&lt;/a&gt;博客开始就是独立的了。&lt;a href=&quot;./2014/06/30/hello-world/&quot;&gt;这个&lt;/a&gt;博客严格来说是我的第四个博客，也是一直都维护在&lt;code&gt;Github&lt;/code&gt;上，除了&lt;code&gt;Markdown&lt;/code&gt;之外的最大不同大概就是域名的配置稍微与传统博客有点区别。&lt;br&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="Octopress" scheme="http://izhen.me/tags/Octopress/"/>
    
      <category term="Hexo" scheme="http://izhen.me/tags/Hexo/"/>
    
      <category term="Github" scheme="http://izhen.me/tags/Github/"/>
    
      <category term="HTTPS" scheme="http://izhen.me/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Mac环境之浏览器三分天下</title>
    <link href="http://izhen.me/2017/12/23/new3webbrowser/"/>
    <id>http://izhen.me/2017/12/23/new3webbrowser/</id>
    <published>2017-12-23T04:41:54.000Z</published>
    <updated>2017-12-23T06:25:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器技术在目前的背景下还是非常重要的，如果能在当前条件下进一步整合破碎的前端体系完全可以营造客服端设备(移动、桌面)只需要一个浏览器的局面。相对而言浏览器的技术含量比较高，如果想了解具体的技术架构，<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">这里</a>有一篇不错的介绍。我不会对三个浏览器做专业评测(没兴趣)，只想说作为一个用户，直观体验上带来了一些不同。<br><a id="more"></a></p><h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><p>依旧是市场占有率最高，响应最快、最为有技术含量的浏览器之一。当然，资源消耗也很可观。过去在 <a href="https://www.apple.com/macos/high-sierra/" target="_blank" rel="noopener">Mac</a> 上的字体渲染表现一般，不如<a href="https://www.apple.com/safari/" target="_blank" rel="noopener">Safari</a>。不过，在 <a href="https://www.apple.com/" target="_blank" rel="noopener">Apple</a> 内部最近几年不知道经历了什么之后，<a href="http://www.google.cn/chrome/browser/desktop/index.html" target="_blank" rel="noopener">Chrome</a> 的字体渲染相比较我倒是觉得还好啦： </p><p><img src="/image/chrome.jpg" alt="Chrome 字体渲染"></p><p>可以看出来，其字体渲染相对简单清晰，整体观感中规中矩。打个比方的话，就像是和朋友选择了一家还不错的火锅店，所有的火锅涮料规规矩矩，是一顿让人非常满足的聚餐，然而也不会有太意想不到之处，最受欢迎，也最为熟知。</p><h3 id="Safari"><a href="#Safari" class="headerlink" title="Safari"></a>Safari</h3><p>在 <a href="https://www.apple.com/macos/high-sierra/" target="_blank" rel="noopener">Mac</a> 环境下一度是字体渲染最佳的浏览器，然而一系列的魔改之后已经面目全非，本身速度也不占据优势，特别是17年这个版本对视频的播放支持实在太差，动不动就卡顿，具体就不多说了，目前的最大作用就是还保存着我的书签：</p><p><img src="/image/safari.jpg" alt="Safari 字体渲染"></p><p>放弃了最不该放弃的东西，好比一家法式料理的大厨用陈醋代替了柠檬，做出来不知怎么形容的菜品，其他也没什么好评价的了。</p><h3 id="Firefox-Quantum"><a href="#Firefox-Quantum" class="headerlink" title="Firefox Quantum"></a>Firefox Quantum</h3><p>在这个版本更新之前是 <a href="https://www.apple.com/macos/high-sierra/" target="_blank" rel="noopener">Mac</a> 环境下最丑的浏览器，更新之后 <a href="http://www.google.cn/chrome/browser/desktop/index.html" target="_blank" rel="noopener">Chrome</a> 是最丑的XD。速度提升非常显著，界面也好看了，标签页的设计也感到了用心。只是对某些特殊服务貌似不是很兼容，也许是安全性问题。字体渲染的表现和 <a href="http://www.google.cn/chrome/browser/desktop/index.html" target="_blank" rel="noopener">Chrome</a> 差不多，同样都是走纤细路线的。现在用它仿佛让我找到了小时候享受使用计算机上网冲浪的感觉，很fancy：</p><p><img src="/image/firefox.jpg" alt="Firefox Quantum 字体渲染"></p><p>目前来说，我最喜欢 <a href="http://www.firefox.com.cn/" target="_blank" rel="noopener">Firefox</a> 的渲染风格，比较接近魔改前的 <a href="https://www.apple.com/safari/" target="_blank" rel="noopener">Safari</a>。相比较 <a href="http://www.google.cn/chrome/browser/desktop/index.html" target="_blank" rel="noopener">Chrome</a> 看起来更明朗舒适。恰如一道顶级的鹅肝料理，色泽柔和寡淡，看上去感觉还不错，品尝后更是惊艳，虽然浓郁却不发腻，完美保留了最原始的香味，而标签页的改变就好比用醋腌过的洋葱配菜，酸甜清冽，使得整道菜品更富层次感。待其性能稳定之后可以作为主力浏览器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器技术在目前的背景下还是非常重要的，如果能在当前条件下进一步整合破碎的前端体系完全可以营造客服端设备(移动、桌面)只需要一个浏览器的局面。相对而言浏览器的技术含量比较高，如果想了解具体的技术架构，&lt;a href=&quot;https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;有一篇不错的介绍。我不会对三个浏览器做专业评测(没兴趣)，只想说作为一个用户，直观体验上带来了一些不同。&lt;br&gt;
    
    </summary>
    
      <category term="OS X" scheme="http://izhen.me/categories/OS-X/"/>
    
    
      <category term="OS X" scheme="http://izhen.me/tags/OS-X/"/>
    
      <category term="web browser" scheme="http://izhen.me/tags/web-browser/"/>
    
      <category term="safari" scheme="http://izhen.me/tags/safari/"/>
    
      <category term="firefox quantum" scheme="http://izhen.me/tags/firefox-quantum/"/>
    
      <category term="chrome" scheme="http://izhen.me/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>AWS初上手指南</title>
    <link href="http://izhen.me/2017/10/29/aws-intro/"/>
    <id>http://izhen.me/2017/10/29/aws-intro/</id>
    <published>2017-10-29T05:29:00.000Z</published>
    <updated>2017-10-29T09:32:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>亚马逊的 <a href="https://aws.amazon.com" target="_blank" rel="noopener">AWS</a> 是当下市场占有率最高的云服务供应平台，目前(截止今天)仍有一年免费试用计划，对于建立个人博客，或者小型站点来说绰绰有余。除此以外可以发挥想象开发一些有意思的应用。这篇文章主要介绍如何快速上手，重点阐述一些基本的概念。</p><a id="more"></a><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>首先就是要注册一个账户，其中 <strong>Basic</strong> 方案是免费使用一年的，你可以根据需要选择自己想要服务。</p><h3 id="选择地区和开启EC2"><a href="#选择地区和开启EC2" class="headerlink" title="选择地区和开启EC2"></a>选择地区和开启EC2</h3><ul><li>选择地区，这里是指物理服务器所在的地区。当然更严格的说法是 <strong>VPC</strong> 所在的地区。每个区域通常都有多个可用区，之后我们会提到可用区的问题。（当我们在多个可用区进行部署同一个应用的时候，可以使用AWS提供的弹性负载均衡服务轻松实现负载均衡）</li></ul><p><img src="/image/aws/1.jpg" alt="VPC"></p><ul><li>选择 <strong>EC2</strong>, 即Elastic Compute Cloud。这是我们这篇文章介绍的重点，借助EC2服务我们可以架设很多应用。单击菜单「服务」-&gt; 「计算」 -&gt; 「EC2」，就能找到。</li></ul><p><img src="/image/aws/2.jpg" alt="EC2"></p><ul><li>控制界面：<ul><li>主界面中我们能看到最左侧的边栏列举了控制面板的一些功能组件，可以链接到相应的子面板中</li><li>主界面的右侧提供了一些附加信息</li><li>主界面的中央则是主操作面板，一开始我们可以看到正在运行的资源，初始状态通常有一个安全组</li></ul></li></ul><p><img src="/image/aws/3.jpg" alt="控制面板"></p><h3 id="配置EC2"><a href="#配置EC2" class="headerlink" title="配置EC2"></a>配置EC2</h3><p>1.好了，接着我们要配置EC2，单击左侧面板中的实例。如果没有运行中的实例，会看到「启动实例」按钮，单击之</p><p><img src="/image/aws/4.jpg" alt="Launch EC2"></p><p>2.选择你想要的 <strong>AMI</strong> 映像，你可以简单理解为选择实例所运行的操作系统，不过是跑在虚拟化环境当中的。这一步除了常规系统，我们还可以选择 <a href="https://aws.amazon.com" target="_blank" rel="noopener">AWS</a> 提供的 <strong>RDS</strong> 数据库服务，这里我选择一个 Deep Learning Ubuntu 的映像</p><p><img src="/image/aws/5.jpg" alt="AMI"></p><p>3.配置硬件资源，我选择 t2.micro 这个套餐</p><p><img src="/image/aws/6.jpg" alt="t2.micro"></p><p>4.配置实例的网络设置。主要有两处：首先要选择一个子网，如果没有高级的需求可以随意选择，这里的子网就是前面提到的可用区，每个可用区可以分配有限个IP地址，通常不同可用区之间不能直接访问。其次，自动分配公有IP选择「启用」</p><p><img src="/image/aws/7.jpg" alt="setting"></p><p>5.添加存储维持默认即可，如有特殊需要可以进行自定义设置</p><p><img src="/image/aws/8.jpg" alt="storage"></p><p>6.添加标签，不添加任何标签的话，系统会维持默认</p><p><img src="/image/aws/9.jpg" alt="tag"></p><p>7.<strong>关键</strong> ：安全组定义了访问的权限，而且对不同的协议分别编组。这里我们需要设置的是 <a href="https://en.wikipedia.org/wiki/SSH" target="_blank" rel="noopener">SSH</a> 和 <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="noopener">HTTP(S)</a>。重点内容是「来源」，它可以限制哪些IP才能访问，譬如说 SSH 这一项我们选择「我的IP」，那么就意味着只有当前访问这个页面的IP才可以成功建立 SSH 连接。可以根据自己的需要自行配置</p><p><img src="/image/aws/10.jpg" alt="security group"></p><p>8.建立自己的密钥对将来可以 <a href="https://en.wikipedia.org/wiki/SSH" target="_blank" rel="noopener">SSH</a> 用，这个务必保管好</p><p><img src="/image/aws/11.jpg" alt="key"></p><p>9.启动EC2</p><p><img src="/image/aws/12.jpg" alt="Launch"></p><h3 id="测试EC2"><a href="#测试EC2" class="headerlink" title="测试EC2"></a>测试EC2</h3><p>根据指示，远程连接。</p><p><img src="/image/aws/14.jpg" alt="SSH introduction"></p><p><img src="/image/aws/15.jpg" alt="SSH"></p><h3 id="其他、官方文档"><a href="#其他、官方文档" class="headerlink" title="其他、官方文档"></a>其他、官方文档</h3><ul><li><p>如果想绑定域名，则需要配置「弹性IP」服务</p></li><li><p>如果想使用弹性负载均衡，则要在不同的子网中启动多个实例，然后配置均衡器</p></li><li><p>前面配置EC2的第7步配置安全组中，我们在主面板可以看到「入站」「出站」两个标签，这两个标签可以分别让我们去配置入站和出站规则。比如，你可以入站<strong>配置</strong> <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="noopener">HTTP</a> ，同时出站<strong>限制</strong> <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="noopener">HTTP</a>，然后自己开启一个 Web Server 随便跑一个有外链的简单站点试试有什么效果</p></li></ul><p><img src="/image/aws/13.jpg" alt="security group"></p><ul><li>官方提供了很多<a href="https://amazonaws-china.com/cn/getting-started/use-cases/" target="_blank" rel="noopener">文档</a>帮助建立相应的服务，包括了很多常见的用例，可以自行查阅</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;亚马逊的 &lt;a href=&quot;https://aws.amazon.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AWS&lt;/a&gt; 是当下市场占有率最高的云服务供应平台，目前(截止今天)仍有一年免费试用计划，对于建立个人博客，或者小型站点来说绰绰有余。除此以外可以发挥想象开发一些有意思的应用。这篇文章主要介绍如何快速上手，重点阐述一些基本的概念。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="AWS" scheme="http://izhen.me/tags/AWS/"/>
    
      <category term="cloud service" scheme="http://izhen.me/tags/cloud-service/"/>
    
      <category term="EC2" scheme="http://izhen.me/tags/EC2/"/>
    
  </entry>
  
  <entry>
    <title>λ计划 - Haskell 实现 Hacker News</title>
    <link href="http://izhen.me/2017/08/20/aws-lambda/"/>
    <id>http://izhen.me/2017/08/20/aws-lambda/</id>
    <published>2017-08-20T05:36:43.000Z</published>
    <updated>2019-11-25T12:13:30.879Z</updated>
    
    <content type="html"><![CDATA[<p>λ计划是由我本人在做硕士毕设的空隙突发奇想发起的系(中)列(二)项目企划。目的是为社区输送新鲜血液，主张使用先进理论与技术进行开拓性的工作。鼓励将优秀的开源项目注册入PROJECT λ。且有意愿在将来组建λ基金会，定制自己的开源协议(够不够中二XD)。</p><p>目前已经把 <a href="https://aws.amazon.com" target="_blank" rel="noopener">AWS</a> 上部署的demo关闭了，录了一段demo的视频，计划中的项目已经开源。前端部分的代码差不多都是我到处 <a href="https://google.com" target="_blank" rel="noopener">Google</a>、到处复制粘贴的，用了不少JS的插件。后端大部分是自己开发的，某些子模块(邮件、MD5、Session、Chatroom)也有用开源项目进行二次开发。</p><a id="more"></a><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>这个网站是在一台13寸的<code>Macbook Pro</code>上，使用<code>Aquamacs</code>编辑<code>Haskell</code>和<code>JavaScript</code>开发完成。</p><h3 id="Times•λ"><a href="#Times•λ" class="headerlink" title="Times•λ"></a><a href="https://github.com/ProLambda/Times" target="_blank" rel="noopener">Times•λ</a></h3><p>这个项目是计划中的第一个项目，λ时报作为第一个原型项目主宰IT/Tech资讯分享与情报交流，其扮演PROJECT λ的入口角色，同时致力于让身处科技圈的群体在信息碎片化的时代更好的将精力集中于高价值信息当中。本项目的动机皆在提供可以营造相应环境的情报平台，鼓励用户成为情报Hacker且热衷于传播分享。</p><p>其本质上是一个用 <a href="https://www.haskell.org" target="_blank" rel="noopener">Haskell</a> 实现的 <a href="https://news.ycombinator.com" target="_blank" rel="noopener">Hacker News</a>，里面融合了一点我自己的理解。因为总想着快一点实现，代码质量几乎没有什么把控，写的比较草率。</p><h3 id="纯聊"><a href="#纯聊" class="headerlink" title="纯聊"></a><a href="https://github.com/ProLambda/PureChat" target="_blank" rel="noopener">纯聊</a></h3><p>纯粹为了聊天而生，没有任何多余的设计，基于Times的Chatroom。前端重新用 <a href="http://www.racket-lang.org" target="_blank" rel="noopener">Racket</a> 实现，<del>自带加密机制(没来得及实现)</del>，是一款动静相合的Chat Tool。</p><h3 id="Demo-for-Times•λ"><a href="#Demo-for-Times•λ" class="headerlink" title="Demo for Times•λ"></a>Demo for Times•λ</h3><ul><li>Submit功能:</li></ul><p><img src="/image/submit.gif" alt="Submit"></p><ul><li>评论功能，借助 <a href="https://www.disqus.com" target="_blank" rel="noopener">Disqus</a> 实现:</li></ul><p><img src="/image/view.gif" alt="View"></p><ul><li>完整Demo录播:</li></ul><iframe height="640" width="100%" quality="high" src="//player.bilibili.com/player.html?aid=13574956&cid=22218275&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><ul><li><p><a href="">Youtube上的录播</a></p></li><li><p>不专业的设计图(About之类不重要的页面没有画)：</p></li></ul><p><img src="/image/lambda-design.png" alt="Design"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;λ计划是由我本人在做硕士毕设的空隙突发奇想发起的系(中)列(二)项目企划。目的是为社区输送新鲜血液，主张使用先进理论与技术进行开拓性的工作。鼓励将优秀的开源项目注册入PROJECT λ。且有意愿在将来组建λ基金会，定制自己的开源协议(够不够中二XD)。&lt;/p&gt;
&lt;p&gt;目前已经把 &lt;a href=&quot;https://aws.amazon.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AWS&lt;/a&gt; 上部署的demo关闭了，录了一段demo的视频，计划中的项目已经开源。前端部分的代码差不多都是我到处 &lt;a href=&quot;https://google.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google&lt;/a&gt;、到处复制粘贴的，用了不少JS的插件。后端大部分是自己开发的，某些子模块(邮件、MD5、Session、Chatroom)也有用开源项目进行二次开发。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="open source" scheme="http://izhen.me/tags/open-source/"/>
    
      <category term="Haskell" scheme="http://izhen.me/tags/Haskell/"/>
    
      <category term="λ" scheme="http://izhen.me/tags/%CE%BB/"/>
    
  </entry>
  
  <entry>
    <title>USACO training 更新</title>
    <link href="http://izhen.me/2017/08/06/USACO-update/"/>
    <id>http://izhen.me/2017/08/06/USACO-update/</id>
    <published>2017-08-06T06:24:38.000Z</published>
    <updated>2017-08-06T06:58:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>时隔4、5年后的再一次更新 <a href="http://train.usaco.org/usacogate" target="_blank" rel="noopener">USACO training</a>。很久不关注OI/ACM竞赛圈了，大概了解到除了NOIP复赛变成了两天外，题目貌似也难了很多。不知道现在的小朋友还有多少人向我当初一样借助USACO做基础训练的。</p><a id="more"></a><p>其实早在三年前就发觉到USACO从97道题目扩充到100题，多了三道枚举。曾经还想补充来着，拖到了现在，感觉太久不做算法题目，脑筋都僵化了。这些年忙着折腾项目，忙着留学，忙着搞 <a href="https://en.wikipedia.org/wiki/Programming_language_theory" target="_blank" rel="noopener">PLT</a> 搞函数式编程，忙着研究机器学习，忙着宅，就是没有忙算法。一番折腾后，也离开了校园步入职场，个人觉得时不时的练一练还是有很多益处的，当然没必要跟搞竞赛一样，不论是难度还是强度。</p><p>言归正传：这三道题目有两道还蛮有意思，都不难，姑且我就认为是NOIP第一题的水平吧（其实我也不清楚现在OI是什么难度），可以训练一下思维模式。个人拙见：确定性算法(P问题)初级阶段有三大算法之母：</p><ul><li>模拟：解决各种杂题</li><li>贪心：局部最优决定全局最优，很多图算法都是贪心思想</li><li>穷举：试探所有可能，DP本质也是穷举的优化</li></ul><p>看似朴素，实则蕴含着无比精妙的思想，多在基础下功夫并做到循序渐进也是我喜爱USACO的一个重要理由。</p><p>地址：<a href="https://github.com/i-zhen/USACO-training" target="_blank" rel="noopener">Github</a> (<strong>初学者指导</strong>：网页版的题目解答比代码更重要)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时隔4、5年后的再一次更新 &lt;a href=&quot;http://train.usaco.org/usacogate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;USACO training&lt;/a&gt;。很久不关注OI/ACM竞赛圈了，大概了解到除了NOIP复赛变成了两天外，题目貌似也难了很多。不知道现在的小朋友还有多少人向我当初一样借助USACO做基础训练的。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="Complete Search" scheme="http://izhen.me/tags/Complete-Search/"/>
    
      <category term="USACO" scheme="http://izhen.me/tags/USACO/"/>
    
      <category term="题目解答" scheme="http://izhen.me/tags/%E9%A2%98%E7%9B%AE%E8%A7%A3%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>DOS时代的游戏及其它</title>
    <link href="http://izhen.me/2017/02/08/bio/"/>
    <id>http://izhen.me/2017/02/08/bio/</id>
    <published>2017-02-08T15:47:01.000Z</published>
    <updated>2017-11-23T14:53:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>大概学龄前的时候在<a href="https://en.wikipedia.org/wiki/Windows_95" target="_blank" rel="noopener">Windows 95</a>上玩过几款DOS平台的游戏，印象深刻的有这几部：</p><ul><li>游戏的开头有个开场动画，男主在奔跑，脑海中想着一个女孩，跑着跑着远方升起了蘑菇云，接下来就是泪奔了，然后男主驾驶着飞机开始了复仇之旅，<a href="https://en.wikipedia.org/wiki/Raiden_(video_game" target="_blank" rel="noopener">雷电</a>风格的游戏</li><li>一款横版过关的射击游戏，背景图案是浩瀚的宇宙</li><li><a href="https://3drealms.com/catalog/bio-menace_42/" target="_blank" rel="noopener">Bio</a>，在我去寻找这款游戏之前，只记得名字的前3个字母</li><li><a href="https://en.wikipedia.org/wiki/Wolfenstein_3D" target="_blank" rel="noopener">Wolfenstein 3D</a></li><li><a href="https://3drealms.com/catalog/duke-nukem-1_24/" target="_blank" rel="noopener">Duke Nukem</a></li></ul><p>直到后来才知道很多游戏是始祖级别的，但依然是玩过了就过了，唯一耿耿于怀的是Bio的Part 1的结尾出现的蛤蟆是不是博士，谁把他变成蛤蟆的，过了这么多年的今天真相终于大白。</p><p><img src="https://static.3drealms.com/media/screenshots/63247f5b68c9409382d577e7b66539be.jpg" alt="Bio的第一关"></p><a id="more"></a><h3 id="Bio-Menace"><a href="#Bio-Menace" class="headerlink" title="Bio Menace"></a>Bio Menace</h3><p>知道这款游戏的全名和我当初只是玩通了Part 1都是在最近。Part 1中某一关的小Boss: <strong>Skull Man</strong>一直很吸引我，不知道为啥有一种特别的神秘感，总觉得其设定与游戏本身的生化危机、AI危机的背景有点格格不入。也许恰恰是这种突兀令我记住了它，同时念念不忘的还有Part 1最后的那只有点难对付的大蛤蟆。在杀死蛤蟆后，有一个浑身是血身着白大褂的Dr出现了，因为小时候不理解英文，不太明白他到底讲了什么，其实呢，他想表达一种观点：人性是受到大环境制约的，当有Master Cain在的时候，他也不得不去制造生化怪物毁灭地球，甚至不惜让自己变成大蛤蟆。所以除恶必除根，时隔20年，我又一次踏上了征程……</p><p><img src="https://static.3drealms.com/media/screenshots/eb37178d529b4b609b72d489ca591bc4.jpg" alt="Skull Man"></p><p>在解决了Part 2的一个AI机械骷髅头之后，我披荆斩棘历尽艰难险阻终于在Part 3的结尾见到了Master Cain，也就是所有罪恶的源头。看其邪教一般的装扮就知道不是省油的灯，对于他可以化身孤魂野鬼的技能我是百思不得其解，看来这款游戏不单单是科幻题材，也有奇幻的内容。总之，结果了最终BOSS后，隐藏在背后的真实尽数显露，大致的剧情就是Master Cain原来是CIA的探员，一次任务他觉得遭到了国家的抛弃于是联合Dr进行复仇的故事，结局还算正常。</p><p><img src="/image/bio.jpg" alt="Happy End"></p><h3 id="Kkrieger"><a href="#Kkrieger" class="headerlink" title="Kkrieger"></a>Kkrieger</h3><p>这款游戏很神奇，使用了非常强劲的压缩技术，游戏的静态容量只有96KB，启动后会在内存中解压，运行时容量大概300+MB。据说官方不愿意透露使用的压缩技术，我个人倒是觉得压缩是一方面，游戏本身的构建技巧一定也有所讲究。比如建模可能是类似分形的原理，这样一来通过演算计算出场景从而大大减少本地存储的空间。游戏性一般，但是总有一种玩第一代<a href="https://en.wikipedia.org/wiki/Doom_(1993_video_game)" target="_blank" rel="noopener">Doom</a>的感觉，可以试一试。</p><embed height="640" width="100%" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="//static.hdslb.com/miniloader.swf" flashvars="aid=7006646&page=1" pluginspage="//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"><h3 id="Cave-Story"><a href="#Cave-Story" class="headerlink" title="Cave Story+"></a>Cave Story+</h3><p>如果有玩过<a href="https://3drealms.com/catalog/bio-menace_42/" target="_blank" rel="noopener">Bio Menace</a>的，或者很喜欢横版过关游戏的，推荐Cave Story+，这是一款日系横版游戏，极高的耐玩度，出众的剧情。一种不同于欧美风格的游戏体验，或许更多的是文化上的差异吧，很值得一试的作品。</p><p><img src="/image/cave.jpg" alt="Cave Story+"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概学龄前的时候在&lt;a href=&quot;https://en.wikipedia.org/wiki/Windows_95&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows 95&lt;/a&gt;上玩过几款DOS平台的游戏，印象深刻的有这几部：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;游戏的开头有个开场动画，男主在奔跑，脑海中想着一个女孩，跑着跑着远方升起了蘑菇云，接下来就是泪奔了，然后男主驾驶着飞机开始了复仇之旅，&lt;a href=&quot;https://en.wikipedia.org/wiki/Raiden_(video_game&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;雷电&lt;/a&gt;风格的游戏&lt;/li&gt;
&lt;li&gt;一款横版过关的射击游戏，背景图案是浩瀚的宇宙&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://3drealms.com/catalog/bio-menace_42/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bio&lt;/a&gt;，在我去寻找这款游戏之前，只记得名字的前3个字母&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Wolfenstein_3D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wolfenstein 3D&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://3drealms.com/catalog/duke-nukem-1_24/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Duke Nukem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直到后来才知道很多游戏是始祖级别的，但依然是玩过了就过了，唯一耿耿于怀的是Bio的Part 1的结尾出现的蛤蟆是不是博士，谁把他变成蛤蟆的，过了这么多年的今天真相终于大白。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.3drealms.com/media/screenshots/63247f5b68c9409382d577e7b66539be.jpg&quot; alt=&quot;Bio的第一关&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="Game" scheme="http://izhen.me/tags/Game/"/>
    
      <category term="Bio Menace" scheme="http://izhen.me/tags/Bio-Menace/"/>
    
      <category term="KKrieger" scheme="http://izhen.me/tags/KKrieger/"/>
    
      <category term="Cave Story+" scheme="http://izhen.me/tags/Cave-Story/"/>
    
  </entry>
  
  <entry>
    <title>Haskell的Atom IDE伪装</title>
    <link href="http://izhen.me/2016/10/21/Atom-Haskell-IDE/"/>
    <id>http://izhen.me/2016/10/21/Atom-Haskell-IDE/</id>
    <published>2016-10-21T03:49:05.000Z</published>
    <updated>2016-10-25T16:34:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/atom_haskell.jpg" alt="Haskell IDE"></p><p>受老师的委托，写了一篇使用 <a href="www.atom.io">Atom</a> 伪装 <a href="https://www.haskell.org" target="_blank" rel="noopener">Haskell</a> <a href="https://en.wikipedia.org/wiki/Integrated_development_environment" target="_blank" rel="noopener">IDE</a> 的配置指南。写作的动机皆在取代原本的 <a href="www.gnuemacs.org/">Emacs</a> + <a href="http://www.inf.ed.ac.uk/teaching/courses/inf1/fp/emacs.pdf" target="_blank" rel="noopener">Haskell mode</a>，因为大量学生抱怨其上手困难。另一方面，因为 <a href="https://www.haskell.org" target="_blank" rel="noopener">Haskell</a> 语言缺乏优秀的原生集成开发环境，现有的方案基本上就是某一种 <a href="">IDE</a> 结合插件的方式。不过 <a href="www.apple.com/mac">Mac</a> 平台上有一款值得尝试的商业软件：<a href="http://haskellformac.com" target="_blank" rel="noopener">Haskell for Mac</a>，有兴趣可以试一试。</p><a id="more"></a><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p><a href="atom.io">Atom</a> 是 <a href="github.com">Github</a> 开发的开源 Editor，可以看做是开源版本的 <a href="http://www.sublimetext.com" target="_blank" rel="noopener">Sublime Text</a>，拥有高度可定制性以及 <a href="github.com">Github</a>  本身的开源社区提供的插件资源。有关更多如何去定制 <a href="atom.io">Atom</a> 可以自行访问官方网站。</p><p><img src="/image/demo_atom.gif" alt="Haskell IDE 使用效果"></p><ul><li>配置IDE的正文：<a href="http://i-zhen.github.io/lab/resume/instruction.pdf" target="_blank" rel="noopener">这里</a></li></ul><h3 id="IDE-vs-Editor"><a href="#IDE-vs-Editor" class="headerlink" title="IDE vs Editor"></a><strong>IDE vs Editor</strong></h3><p>网上对于这两大阵营的争论已经足够多了，我也想发表一下自己的一些看法。首先，这篇文章的写作目的在于引导初学者，其内容客观性需要考究，本人不保证方方面面不会出现疏漏，自行判断即可。</p><p><strong>IDE</strong>的拥簇者通常会给出比较相似的理由：</p><ul><li>可用性</li><li>针对性</li><li>强大的技术支持</li><li>etc.</li></ul><p>这些理由可以说就是一个成功的集成开发环境所应当具备的基本特性，通常它们对于某一个语言的优化明显，背后的技术支持也比较完善，强大的静态分析技术的引用等也使得这一阵营在商业市场上更具活力。</p><p>另一方面，<strong>Editor</strong>的拥簇者们给出的理由通常都包含为何拒绝<strong>IDE</strong>的理由：</p><ul><li>IDE难看</li><li>定制性差</li><li>支持单一</li><li>etc.</li></ul><p>诚然，我本人也使用<strong>VIM/Emacs</strong>，经过配置后确实能具备令人满意的效果。然而，不论人们如何评价，使用原生<strong>Editor</strong>进行开发工作的并不占多数，要么使用某些已经具备语言支持的编辑器，要么就对<strong>VIM/Emacs</strong>进行相关的配置。可是你会发现，这些人最终还是把自己的编辑器折腾（伪装）成了<strong>IDE</strong>的样子。这也就是说编辑器党也不会抵制<strong>IDE</strong>所具备的优势特性，所以不论什么党派都将会是殊途同归。</p><p><img src="/image/vim_haskell.jpg" alt="VIM 伪装 IDE"></p><p><img src="/image/emacs_haskell.jpg" alt="Emacs 可以直接运行 Haskell 代码"></p><p>我给初学者的建议就是没有自己的主见时，莫受主流影响偏向一方，工具的目的毕竟是解放程序员繁杂的开发工作中因环境问题所牵扯的精力，正所谓集成开发环境，其首要考虑的因素应当是用户体验。为了折腾而折腾有点钻牛角尖。时间和精力都是有限的，有限的资源应该集中解决热点问题。对于开发来说就是集中在业务逻辑上，对于学生的学习工作来说就是重点攻坚知识技能。</p><blockquote><p>做工具的主人，而不是奴隶</p></blockquote><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a><strong>后记</strong></h3><p>优秀的剑客可以草木皆兵，而三流剑客即便手握绝世名剑也未必能在江湖站得住脚。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/image/atom_haskell.jpg&quot; alt=&quot;Haskell IDE&quot;&gt;&lt;/p&gt;
&lt;p&gt;受老师的委托，写了一篇使用 &lt;a href=&quot;www.atom.io&quot;&gt;Atom&lt;/a&gt; 伪装 &lt;a href=&quot;https://www.haskell.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Haskell&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Integrated_development_environment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IDE&lt;/a&gt; 的配置指南。写作的动机皆在取代原本的 &lt;a href=&quot;www.gnuemacs.org/&quot;&gt;Emacs&lt;/a&gt; + &lt;a href=&quot;http://www.inf.ed.ac.uk/teaching/courses/inf1/fp/emacs.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Haskell mode&lt;/a&gt;，因为大量学生抱怨其上手困难。另一方面，因为 &lt;a href=&quot;https://www.haskell.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Haskell&lt;/a&gt; 语言缺乏优秀的原生集成开发环境，现有的方案基本上就是某一种 &lt;a href=&quot;&quot;&gt;IDE&lt;/a&gt; 结合插件的方式。不过 &lt;a href=&quot;www.apple.com/mac&quot;&gt;Mac&lt;/a&gt; 平台上有一款值得尝试的商业软件：&lt;a href=&quot;http://haskellformac.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Haskell for Mac&lt;/a&gt;，有兴趣可以试一试。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="Haskell" scheme="http://izhen.me/tags/Haskell/"/>
    
      <category term="IDE" scheme="http://izhen.me/tags/IDE/"/>
    
      <category term="Atom" scheme="http://izhen.me/tags/Atom/"/>
    
      <category term="Editor" scheme="http://izhen.me/tags/Editor/"/>
    
      <category term="Vim/Emacs" scheme="http://izhen.me/tags/Vim-Emacs/"/>
    
  </entry>
  
  <entry>
    <title>欧洲之行</title>
    <link href="http://izhen.me/2016/10/01/euro-travel/"/>
    <id>http://izhen.me/2016/10/01/euro-travel/</id>
    <published>2016-10-01T14:51:45.000Z</published>
    <updated>2016-10-24T13:13:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>一年之前撰文 <a href="http://izhen.me/2015/09/26/cityofuk/">英国迷城</a>，那时刚到英国，便着重笔墨描绘了我对于爱丁堡的一些印象。这一次，过去了一年多，也取得了学位。还是用英国的城市作为起点，简单说说我所走到过的一些地方，留下的印象与感受。</p><p><img src="/image/euro/uk02.jpg" alt="伦敦的钢筋水泥柱子"></p><h3 id="伦敦"><a href="#伦敦" class="headerlink" title="伦敦"></a>伦敦</h3><p>这次去伦敦，除去参观白金汉宫、大笨钟和塔桥这些必去景点之外，我还看了看伦敦城市现代化的进展。比方说伦敦金融街上的那些水泥柱子，不过对于建筑外行来说，只看水泥柱子意义不是特别大。伦敦整体上还是保留了很多维多利亚时期的建筑，从伦敦之眼上可以发现这种古典与现代的融合。我是八月份去的这里，不巧赶上变天，温度十分低。再加上英伦三岛常年阴天下雨的特点，伦敦留给我的印象是比较冷峻的，这也比较符合英国人留给大众印象。个人认为最适合伦敦的天气是晴间多云。</p><a id="more"></a><p><img src="/image/euro/uk01.jpg" alt="大笨钟"></p><h3 id="西班牙"><a href="#西班牙" class="headerlink" title="西班牙"></a>西班牙</h3><p>去西班牙度假最好的月份是初夏，这时候似热不热的天气刚好方便出门欣赏这美丽的国度。我只去了一个城市—巴塞罗那，在那里待够了一个星期。有几天乘坐着环城巴士好好游览了一下整座城市。巴萨并不是很大，然而其丰富程度难以想象。夸张的说，每一条街道都可以当做一处风景。我和小伙伴还专门租了自行车穿梭于巴萨的小巷间。个人最喜欢的一处风景是蒙特居克山，在山上总览整个巴萨是非常令人享受的。你可以看到背后的小镇，美丽的地中海，似乎还能听到热情的西班牙人唱着动听的歌曲舞着弗拉明戈游荡在每一个瞬间。:-)</p><p><img src="/image/euro/sp1.jpg" alt="蒙特居克山"></p><p>圣家族大教堂是一个有点传奇色彩的建筑，算得上巴萨的地标，由著名建筑大师高迪设计，建筑经费来自于捐赠和门票。以至于这座教堂建了100年(大约)还是未能封顶。不论外观还是内部结构均有一种浓浓的异域风情。高迪也可以说缔造了巴萨的一种当代面孔，对于看惯了钢筋水泥的人来说，巴萨不可不去。叫一份西班牙海鲜饭，点上一杯<a href="https://en.wikipedia.org/wiki/Sangria" target="_blank" rel="noopener">Sangria</a>，耐心的享受西班牙的热情，个人最喜欢的欧洲城市之一。</p><p><img src="/image/euro/sp2.jpg" alt="圣家堂内部"></p><h3 id="法国"><a href="#法国" class="headerlink" title="法国"></a>法国</h3><p>浪漫的明珠巴黎想必是每一个去法国的旅客都要驻足的地方，这里有享誉世界的美食文化和经典的建筑景点，曾经一段时期是文艺复兴的中心，有着海量储量的世界级艺术品。参观这里的景点，品尝法国大餐，登上埃菲尔铁塔，漫步香榭丽舍大街。不过我也不需要过多介绍巴黎，每个人心中都有属于自己的法兰西式的浪漫不是吗。</p><p><img src="/image/euro/fr1.jpg" alt="巴黎埃菲尔铁塔"></p><p><img src="/image/euro/fr2.jpg" alt="法国大餐"></p><p>在法国我还去了普罗旺斯地区的三座城市，马赛、尼斯、戛纳。个人对戛纳这座小城情有独钟，不过原因也比较简单，马赛十分的脏乱，地面的污迹明显，实在配不上法国第二大城市的名声。尼斯稍微好点，但也是差强人意。戛纳相比较之下就好很多了，坐拥蓝色海岸，岸边停满了私人游艇，沙滩上还有让人目不暇接的风景，不禁会爱上这里。</p><p><img src="/image/euro/fr4.jpg" alt="戛纳街景"></p><h3 id="卢森堡-德国-比利时-荷兰"><a href="#卢森堡-德国-比利时-荷兰" class="headerlink" title="卢森堡 德国 比利时 荷兰"></a>卢森堡 德国 比利时 荷兰</h3><p>这几个国家除了荷兰玩的就比较走马观花了，卢森堡只是路过住了一晚，看了看夕阳，其中心购物街也没几个人，适合喜欢清静的人。德国去参观了科隆大教堂，着实雄伟，世界最高的哥特式教堂。比利时首府布鲁塞尔我觉得逛一逛还是蛮有意思的，比如著名景点撒尿小童。这里的巧克力听说也不赖，我买了一些松露巧克力，不过鉴于本人对巧克力本身不感冒，买来也只是尝尝就不过多评价了。</p><p><img src="/image/euro/bl1.jpg" alt="比利时布鲁塞尔大广场"></p><p>荷兰去的地方比较多，譬如阿姆斯特丹，羊角村，海牙，鹿特丹还有奥特莱斯。来荷兰一是与乌得勒支的小伙伴于阿姆斯特丹面基，二是陪同行小伙伴去奥特莱斯购物。所以滞留的时间相比于上述三个长了不少。阿姆斯特丹的中央车站距离红灯区不远，城市的中心有许多河道，这一点有点像威尼斯。街头上到处弥漫着大麻的味道，名副其实的罪恶之城。如果对乡村感兴趣，就可以去看看羊角村，如果喜欢现代建筑，鹿特丹是个好选择。</p><p><img src="/image/euro/ho1.jpg" alt="荷兰羊角村"></p><h3 id="意大利"><a href="#意大利" class="headerlink" title="意大利"></a>意大利</h3><p>不少人说意大利是欧洲的中国，我觉得两者不是很像。至少就我感觉，国内的水泥柱子要比意大利多得多。此行去意大利也是圆了我一个思念，我一直觉得去到那些遗迹地方才真的有「旅行」的感觉。必须要去的地方还真不少，尽管意大利的大多城市都不算大，不过认真去玩还是会花很多时间的。比如在罗马可以看竞技场、论坛等景点。还有个世界最小国家「梵蒂冈」被囊括其中，遗憾的是我没参观那里。佛罗伦萨在徐志摩的诗中被翻译为翡冷翠，可以在山顶上观看日出日落。因为其距离比萨很近，顺道可以看看比萨斜塔。我最喜欢的意大利城市要数威尼斯，不大的城市不少物质文化遗产，乘坐贡多拉到处转悠转悠，品尝一下意大利菜，欣赏极具特色的城市构型。似乎每一条水道都有一段动人的佳话。</p><p><img src="/image/euro/it1.jpg" alt="罗马"></p><p><img src="/image/euro/it2.jpg" alt="佛罗伦萨"></p><p><img src="/image/euro/it3.jpg" alt="比萨"></p><p><img src="/image/euro/it4.jpg" alt="威尼斯"></p><h3 id="摩纳哥"><a href="#摩纳哥" class="headerlink" title="摩纳哥"></a>摩纳哥</h3><p>这个小小的国家作为本轮旅行的终点（实际上我分三次去了上述所有国家）。与巴萨一样，是我最喜欢的欧洲国家/城市之一。这个国家非常小，却拥有两座城市，最大最重要就是蒙特卡洛。推荐去法国普罗旺斯地区游玩的各位，不要忘记这个小国，从飘着香味的车站登陆后，你将发现自己会沉醉在这个宛若仙境般的小小山坡之上。</p><p><img src="/image/euro/mo1.jpg" alt="摩纳哥蒙特卡洛"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一年之前撰文 &lt;a href=&quot;http://izhen.me/2015/09/26/cityofuk/&quot;&gt;英国迷城&lt;/a&gt;，那时刚到英国，便着重笔墨描绘了我对于爱丁堡的一些印象。这一次，过去了一年多，也取得了学位。还是用英国的城市作为起点，简单说说我所走到过的一些地方，留下的印象与感受。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/euro/uk02.jpg&quot; alt=&quot;伦敦的钢筋水泥柱子&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;伦敦&quot;&gt;&lt;a href=&quot;#伦敦&quot; class=&quot;headerlink&quot; title=&quot;伦敦&quot;&gt;&lt;/a&gt;伦敦&lt;/h3&gt;&lt;p&gt;这次去伦敦，除去参观白金汉宫、大笨钟和塔桥这些必去景点之外，我还看了看伦敦城市现代化的进展。比方说伦敦金融街上的那些水泥柱子，不过对于建筑外行来说，只看水泥柱子意义不是特别大。伦敦整体上还是保留了很多维多利亚时期的建筑，从伦敦之眼上可以发现这种古典与现代的融合。我是八月份去的这里，不巧赶上变天，温度十分低。再加上英伦三岛常年阴天下雨的特点，伦敦留给我的印象是比较冷峻的，这也比较符合英国人留给大众印象。个人认为最适合伦敦的天气是晴间多云。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="London" scheme="http://izhen.me/tags/London/"/>
    
      <category term="Italy" scheme="http://izhen.me/tags/Italy/"/>
    
      <category term="France" scheme="http://izhen.me/tags/France/"/>
    
      <category term="Monaco" scheme="http://izhen.me/tags/Monaco/"/>
    
      <category term="Spain" scheme="http://izhen.me/tags/Spain/"/>
    
      <category term="Germany" scheme="http://izhen.me/tags/Germany/"/>
    
      <category term="Belgium" scheme="http://izhen.me/tags/Belgium/"/>
    
      <category term="Luxembourg" scheme="http://izhen.me/tags/Luxembourg/"/>
    
      <category term="Holland" scheme="http://izhen.me/tags/Holland/"/>
    
  </entry>
  
  <entry>
    <title>证明列表翻转函数的单射</title>
    <link href="http://izhen.me/2016/01/29/Rev_injective/"/>
    <id>http://izhen.me/2016/01/29/Rev_injective/</id>
    <published>2016-01-28T19:26:59.000Z</published>
    <updated>2017-12-23T05:27:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>新年第一更，本文讲述一个非常直观的性质：对于列表的翻转函数，它是单射的。我们将使用 <a href="https://coq.inria.fr" target="_blank" rel="noopener">Coq</a> 来协助我们证明。这道问题的证明颇具启发意义，在这里撰文描述下证明的过程。我们也可以从证明本身探讨下一个成功的证明所应有的切入点。<br><a id="more"></a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>翻转列表函数<code>rev</code>的定义如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fixpoint rev (<span class="symbol">l:</span>natlist) : natlist <span class="symbol">:</span>= </span><br><span class="line">  match l with</span><br><span class="line">   <span class="params">| <span class="literal">nil</span>    =&gt; <span class="literal">nil</span></span></span><br><span class="line"><span class="params">   |</span> h <span class="symbol">:</span>: t =&gt; rev t ++ [h]</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>定理<code>rev_injective</code>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Theorem  rev_injective : forall (l1 l2 : natlist), rev l1 = rev l2 -&gt; l1 = l2.</span><br></pre></td></tr></table></figure><p>一个切入点或许是数学归纳，不过证明过程中相对繁琐，而且会遇到证明不下去的情况。我尝试过一些手段，都没有什么效果。也就是说，局部的分析或许不太适合本问题；尝试重新审视定理的内容，我们发现，事实上应该用全局的视角去看待它。</p><p>假设<code>rev l1 = rev l2</code>是正确的，那么接下来证明是不是就简单多了呢？(Hint : rev (rev l) = l)</p><p>引理<code>rev_involutive</code>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Theorem rev_involutive : forall l : natlist,</span><br><span class="line">  rev (rev l) = l.</span><br></pre></td></tr></table></figure><p>证明略。</p><h1 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h1><p>首先我们要假设前件成立：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Theorem  rev_injective : forall (l1 l2 : natlist), rev l1 = rev l2 -&gt; l1 = l2.</span><br><span class="line">Proof.</span><br><span class="line">  intros l1 l2.</span><br><span class="line">  intros H.</span><br></pre></td></tr></table></figure><p>得到一个<code>subgoal</code>:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> subgoal</span><br><span class="line">l1 : natlist</span><br><span class="line">l2 : natlist</span><br><span class="line">H : rev l1 = rev l2</span><br><span class="line">_____________________________________<span class="number">_</span>(<span class="number">1</span>/<span class="number">1</span>)</span><br><span class="line">l1 = l2</span><br></pre></td></tr></table></figure><p>根据定理<code>rev_involutive</code>我们可以推倒出：l1 = rev (rev l2)。在根据假设 rev l1 = rev l2，可以得到 l1 = rev (rev l1)。再次应用定理 <code>rev_involutive</code>， l1 = l1， rev l1 = rev l2 -&gt; l1 = l2 得证。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Theorem  rev_injective : forall (l1 l2 : natlist), rev l1 = rev l2 -&gt; l1 = l2.</span><br><span class="line">Proof.</span><br><span class="line">  intros l1 l2.</span><br><span class="line">  intros H.</span><br><span class="line">  rewrite &lt;- rev_involutive.</span><br><span class="line">  rewrite &lt;- H.</span><br><span class="line">  rewrite -&gt; rev_involutive.</span><br><span class="line">  reflexivity.</span><br><span class="line">Qed.</span><br></pre></td></tr></table></figure><p>剩余过程：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_____________________________________<span class="number">_</span>(<span class="number">1</span>/<span class="number">1</span>)</span><br><span class="line">l1 = rev (rev l2)</span><br><span class="line"></span><br><span class="line">_____________________________________<span class="number">_</span>(<span class="number">1</span>/<span class="number">1</span>)</span><br><span class="line">l1 = rev (rev l1)</span><br><span class="line"></span><br><span class="line">_____________________________________<span class="number">_</span>(<span class="number">1</span>/<span class="number">1</span>)</span><br><span class="line">l1 = l1</span><br><span class="line"></span><br><span class="line">no more subgoals</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>形式化证明可以很灵活。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新年第一更，本文讲述一个非常直观的性质：对于列表的翻转函数，它是单射的。我们将使用 &lt;a href=&quot;https://coq.inria.fr&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Coq&lt;/a&gt; 来协助我们证明。这道问题的证明颇具启发意义，在这里撰文描述下证明的过程。我们也可以从证明本身探讨下一个成功的证明所应有的切入点。&lt;br&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="Coq" scheme="http://izhen.me/tags/Coq/"/>
    
      <category term="Software Foundation" scheme="http://izhen.me/tags/Software-Foundation/"/>
    
      <category term="Automated Reasoning" scheme="http://izhen.me/tags/Automated-Reasoning/"/>
    
      <category term="Artificial Intelligence" scheme="http://izhen.me/tags/Artificial-Intelligence/"/>
    
  </entry>
  
  <entry>
    <title>一拳超人和《九三皮历险记》</title>
    <link href="http://izhen.me/2015/12/21/2015-12-21-guangtou/"/>
    <id>http://izhen.me/2015/12/21/2015-12-21-guangtou/</id>
    <published>2015-12-21T14:06:46.000Z</published>
    <updated>2018-09-20T12:24:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>一拳超人这部作品太酷了，不单指内容和作画。<br><a id="more"></a></p><p>我小学二年级时画过一部连环画《九三皮历险记》。故事的主角在某一回（我忘了哪一回了，因为已经丢失，这部作品只有我和我小学的好朋友看过，他是学习委员）遇到喷火怪被烧成了个大光头。</p><p>之所以这么发展是因为我嫌头发太难画。我不太会画画。</p><p>当时我用16K的打印纸自己装订成一本薄薄的册子，然后设计了很多情节。结局是悲剧，主角死了，变成了化石。最后一页最后一个分镜大概是下面的样子：主角飞出了山洞，同时变成了化石。</p><p><img src="/image/Untitled.jpg" alt="Bad End"></p><p>之后我出了续集，又是变成了光头，原因一样，也有继承的含义。内容大概就是给上一部的主人公复仇。同时我选用更好的A4打印纸作为载体。但是这一回没有完结。里面只有一个怪物我还记得很清楚：“主角来到一处山地，但是感觉却很奇怪这里一个人也没有，当主角意识到不正常的时候，为时已晚，山都变成了大山怪围攻了过来。”</p><p>我的作品的主角叫九三皮，现在看起的有点土鳖。受到小时候看的上海美术电影制片厂出品的动画片中周扒皮这个名字的启发（可能，记忆模糊了）。故事的情节受到葫芦娃和奥特曼的启发，就是一回又一回的打怪。</p><p>光头男这部作品真是勾起了我很多回忆啊。:-)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一拳超人这部作品太酷了，不单指内容和作画。&lt;br&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="comic" scheme="http://izhen.me/tags/comic/"/>
    
      <category term="animation" scheme="http://izhen.me/tags/animation/"/>
    
  </entry>
  
  <entry>
    <title>细数APP的变动</title>
    <link href="http://izhen.me/2015/12/20/2015-12-20-app-goodbey/"/>
    <id>http://izhen.me/2015/12/20/2015-12-20-app-goodbey/</id>
    <published>2015-12-20T12:24:39.000Z</published>
    <updated>2020-01-13T12:06:08.218Z</updated>
    
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器。以前发过一篇文章是说 <a href="http://izhen.me/2014/03/07/2014-03-07-my-mac-software-list/">MAC OS X 常用软件分享</a> 。这里要说说变动的一些APP，这其中既有主动弃掉，也有依依不舍但是没办法被动扔掉的，还有新加入的。最近因为没什么闲功夫整理技术文章，总发技术博文也略显失趣，所以就闲聊下好了。<br><a id="more"></a></p><h3 id="抛弃列表"><a href="#抛弃列表" class="headerlink" title="抛弃列表"></a>抛弃列表</h3><h4 id="主动抛弃"><a href="#主动抛弃" class="headerlink" title="主动抛弃"></a>主动抛弃</h4><ol><li><a href="http://macromates.com/" target="_blank" rel="noopener">TextMate</a> The Missing Editor for Mac OS X，装上就没怎么用过。</li><li>用 <a href="http://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 安装的一堆没用的依赖。</li><li><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">Sublime</a> 被 <a href="https://atom.io" target="_blank" rel="noopener">Atom</a> 替代了。并不是<code>ST</code>不够好，其实<code>Atom</code>在效率上还是有待改进的，毕竟其工作原理是V8托着Node.js，就像浏览器上跑着WEB应用，不同的是本地运行，没有网络延迟。效率这一点目前还比不过<code>ST</code>，但是感觉社区够好，而且我装一堆文本编辑器（我还有Vim和Emacs，没错我双党XD）没必要，个人不太喜欢在这个方面冗余，卸之。</li><li><a href="http://www.videolan.org/vlc/index.html" target="_blank" rel="noopener">VLC</a> 用的少。</li><li><a href="http://adium.im" target="_blank" rel="noopener">Adium</a> 用 <a href="https://weechat.org" target="_blank" rel="noopener">Weechat</a> 替代了。</li></ol><h4 id="被动抛弃"><a href="#被动抛弃" class="headerlink" title="被动抛弃"></a>被动抛弃</h4><ol><li><a href="http://mouapp.com/" target="_blank" rel="noopener">Mou</a> 所见即所得 Markdown 编辑器，不知道为什么就坑了。替代者 <a href="http://www.mweb.im" target="_blank" rel="noopener">MWeb</a></li><li><a href="http://sparrowmailapp.com/" target="_blank" rel="noopener">Sparrow</a> 因为停止更新了，目前用<code>OS X</code>自带的。</li></ol><h3 id="新丁"><a href="#新丁" class="headerlink" title="新丁"></a>新丁</h3><p>除了上面提到的，还有：</p><ol><li><a href="https://minecraft.net" target="_blank" rel="noopener">Minecraft</a> 神作，必须入。我不把<code>MC</code>单纯看做游戏。</li><li><a href="https://smilesoftware.com/pdfpenpro" target="_blank" rel="noopener">PDFpenPro</a> 非常强大的PDF阅读、标注工具。</li><li><a href="https://getpocket.com/" target="_blank" rel="noopener">Pocket</a> 用了就知道。</li><li><a href="https://agilebits.com/onepassword" target="_blank" rel="noopener">1Password</a> 好东西，推荐。</li><li><del><a href="https://www.techsmith.com" target="_blank" rel="noopener">TechSmith</a> 的两个录制屏幕的应用</del></li><li><a href="">Setapp</a> 最好到第三方租用软件平台。</li><li><a href="">Final Cut Pro X</a> 最棒到剪辑软件。</li><li><a href="">Photoshop</a> 修图利器</li><li><a href="">Affinity Photo</a> PS替代者</li><li><a href="">Lightroom</a> 照片调色行业标准</li><li><a href="">DaVinci</a> 视频调色行业标准</li><li><a href="">Origami Studio</a> Facebook推出到原型工具</li><li><a href="">Adobe XD</a> A家原型工具</li><li><a href="">Logic Pro X</a> 强化版库乐队</li><li><a href="">Capture One for Sony</a> 飞思出品到照片编辑工具</li><li><a href="">Folx</a> Mac上的迅雷</li><li><a href="">Sony Imaging</a> Sony自家照片编辑三件套</li><li><a href="">Drafts</a> 备忘录替代品</li><li><a href="">Day One</a> 日记软件</li><li><a href="">VMware Fusion</a> 比PD干净，更稳定到老牌虚拟机软件</li><li><a href="">Transimit</a> 新一代FTP工具，可以SSH</li></ol><h3 id="使用上的变动"><a href="#使用上的变动" class="headerlink" title="使用上的变动"></a>使用上的变动</h3><ol><li><code>Vim/Emacs</code> : 我用这个最强大的文本编辑器和这个编辑器中的操作系统的时候与以前比产生了一定的变化。以前我写<code>C/C++</code>都是开着<code>Vim</code>写，现在对于小程序仍然可以这么做，但是面对大的项目确实有一定的局限，除非你的配置文件异常出色。但是将大把精力投入在配置文件上并不总是值得推崇的。现在，一个超级强大的<code>Emacs</code>配置文件动辄上千行，然而和你单纯的写程序不一样，寻找、比较、调试配置文件更加消耗精力，你可以把时间用在更值得的地方。我现在的态度就是，学习一门新的编程语言用<code>Vim/Emacs</code>足够，因为过于强大的<code>IDE</code>在我入门时给出的<em>丰富的指示</em>反而不利于初学者思考。</li><li>以前我不太常用<code>IDE</code>，除了写<code>Java</code>用过<code>Eclipse</code>。现在，我在已经入门一个语言后，开始做项目时会选择一个<em>真正理解</em>程序语言的<code>IDE</code>。比如<code>Java</code>系的编程语言选择 <a href="http://www.jetbrains.com/" target="_blank" rel="noopener">Jetbrians</a> 的产品，<code>C/C++</code>选择<code>VS</code>系，而对于某些缺乏优秀<code>IDE</code>的函数式语言，目前只能用配置过的编辑器了，期待有朝一日，涌现大量的成熟的函数式语言的IDE(比如<code>F#</code>)。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>铁打的生态环境，流水的APP，时常会更新一些，删掉一些，加入一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工欲善其事，必先利其器。以前发过一篇文章是说 &lt;a href=&quot;http://izhen.me/2014/03/07/2014-03-07-my-mac-software-list/&quot;&gt;MAC OS X 常用软件分享&lt;/a&gt; 。这里要说说变动的一些APP，这其中既有主动弃掉，也有依依不舍但是没办法被动扔掉的，还有新加入的。最近因为没什么闲功夫整理技术文章，总发技术博文也略显失趣，所以就闲聊下好了。&lt;br&gt;
    
    </summary>
    
      <category term="OS X" scheme="http://izhen.me/categories/OS-X/"/>
    
    
      <category term="OS X" scheme="http://izhen.me/tags/OS-X/"/>
    
      <category term="open source" scheme="http://izhen.me/tags/open-source/"/>
    
      <category term="software" scheme="http://izhen.me/tags/software/"/>
    
  </entry>
  
  <entry>
    <title>英国迷城</title>
    <link href="http://izhen.me/2015/09/26/cityofuk/"/>
    <id>http://izhen.me/2015/09/26/cityofuk/</id>
    <published>2015-09-26T14:53:47.000Z</published>
    <updated>2016-08-14T01:51:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>从倒时差算起有三个月了，比祖国慢了七个小时，渐渐习惯了这里的环境，开始尝试接触人文。还没有往伦敦三角那里走，只是在爱丁堡过了一个月的国际艺术节、推了苏格兰的高地便已是沉醉其中。这次出国算是我人生第一次真正意义的出国旅行，当然了主要目的是出国读（旅）书（行）。世界这么大，自己就寻思着有一天可以在曾经的小圈子外面转一转，这一转就走了很远，漂洋过海来到了不列颠。</p><a id="more"></a><p><img src="/image/CoUK/uk00.jpg" alt="飞机上的蓝天白云"></p><h3 id="初见"><a href="#初见" class="headerlink" title="初见"></a>初见</h3><p>「遥想」三个月前，从卡塔尔转机后飞入欧洲大陆，看得到机舱外的蓝天和白云相映出宝石般的晶莹，但是这色泽又不腻人，不浓不淡，美得恰到好处。不仅如此，在机场降落时，不知爱丁堡这里环境竟如此迷人，从未亲眼见过这等美妙的田野和天空中的云融合一起的景色。云低得快要碰到小山包的顶了，看得清的不只是云的外观，就连它的层次、沟壑也尽显眼前。而田野旁边就是海了，还未来得及仔细品味这被冰块稀释的甘醇苏格兰威士忌我就匆匆入关了。</p><p><img src="/image/CoUK/uk01.jpg" alt="飞机降落"></p><p>尽管说爱丁堡是苏格兰的首府，欧洲「小镇」的风情倒是一清二楚的呈现出来了。说小其实也不太小，恐怕是在国内看惯了单调的没有多少文化底蕴的钢筋水泥，反而不太适应这里的天然。这让我想起来中学时代去盘山，半山腰的时候偶遇溪流穿过山谷，周边相映着绿树繁花，惊喜得像是误入了桃花源境，甚是感动。这里的美从某种层面上讲和盘山腹地是一样的，同样让我感受到了幸运、快乐、幸福，不同的则是形式和文化蕴含。</p><h3 id="风景"><a href="#风景" class="headerlink" title="风景"></a>风景</h3><p>在这里必然会邂逅不同的人，不同的事，不同的喜怒哀乐；感知不同的文化、思想和礼遇；欣赏不同的艺术、风景和人文。</p><p><img src="/image/CoUK/uk02.jpg" alt="Old College"></p><p><img src="/image/CoUK/uk03.jpg" alt="New College"></p><p><img src="/image/CoUK/uk04.jpg" alt="Old College internal"></p><p>第一个月适应这里的生活，在一个不需要地铁，可以徒步走遍中心街区的城市里，慢慢着如饮茶般啜饮着新古典主义的老建筑。这里的古典建筑保存完好，而且绝大多数都在使用。核心的街区一只手数的过来，数不过来的是爱丁堡新城和旧城所富有的宝藏。说来有趣，新旧两城都是物质文化遗产，而如果你想爬山，不用驱车数小时到景区，而是徒步最多30分钟就能到达爱丁堡之巅——亚瑟王座。</p><p><img src="/image/CoUK/uk13.jpg" alt="亚瑟王座"></p><p>若是想看海，两个小时的步程怎么想都不算远。可能不作为渔场的缘故，没有明显的海腥味，只是觉得在爱丁堡常年不用穿短袖，海里戏个水还是挑最热的几个月去吧。我们玩得晚了点，风雨交加，随意在海边找了酒吧，坐下了点了杯苏格兰国酒。</p><p><img src="/image/CoUK/uk15.jpg" alt="Beach"></p><p><img src="/image/CoUK/uk05.jpg" alt="Bar"></p><p><img src="/image/CoUK/uk06.jpg" alt="Bar"></p><h3 id="节日"><a href="#节日" class="headerlink" title="节日"></a>节日</h3><p>国际艺术节，这是作为艺术之都的标志，其实酒吧遍布爱丁堡，也比较吸引艺术家和作家在这里度假，兴许一个不小心，你就遇到了之前一直很喜欢的作家。整个节日持续一个月，有个就像开幕式一样的重要表演：Military Tattoo，各个受到邀请的国家会派出军队在这里表演，不过不用太严肃，是军乐表演。今年正赶上中国受到邀请，也算是幸运了。抽出时间看个歌剧，听个音乐会，其实这也只是大众生活的一部分罢了。</p><p><img src="/image/CoUK/uk11.jpg" alt="Military Tattoo"></p><p><img src="/image/CoUK/uk12.jpg" alt="费加罗的婚礼"></p><p><img src="/image/CoUK/uk10.jpg" alt="奥斯陆爱乐乐团"></p><h3 id="高地"><a href="#高地" class="headerlink" title="高地"></a>高地</h3><p>苏格兰高地，大名鼎鼎的尼斯湖，听说那里有个水怪。我们几个人一起驱车去了那里，在民宿过了一夜，一路欣赏了黑色的湖水。正巧赶上下雨，个人虽不喜欢雨，不过雨后的彩虹矗立湖中央还是副醉人的美景。</p><p><img src="/image/CoUK/uk18.jpg" alt="尼斯湖"></p><p><img src="/image/CoUK/uk19.jpg" alt="城堡遗迹"></p><h3 id="学院"><a href="#学院" class="headerlink" title="学院"></a>学院</h3><p>学校的校址分布在整个爱丁堡，英国的大学除了没有围墙还有就是不集中，所以上学的感觉与国内也是不同的，明确的说每一个校园都不是很大，却都很精致，从十六世纪末，大概是文艺复兴同期算起，数百载的历史也使学校有着独特的历史性魅力。本身爱丁堡就有「鬼城」一说，加上这里的纬度偏高，夏天甚至11、12点都还有晚霞，冬天下午2、3点就天黑了，名副其实的鬼城。半路吸血鬼出没的话，敢问君可惧否？:-)</p><p><img src="/image/CoUK/uk23.jpg" alt="UofE"></p><p>出国后有至少一个好处就是可以遇见一些大师可以开开眼界，比如我来之前听都没听说过认知科学这个词汇，其实可以理解为「强」人工智能的一个切入点，是研究人脑的运作规律的，同时与计算机科学交叉。除此以外，没有特大都市的空气污染这一点令我欣慰；缺点嘛，比如英国这里的料理不好吃，不夸张的说如果你仅仅煮熟了面条，加点美味的酱油或其他酱料拌一下就能算是半个美食了。所以出国要占用一些时间学习自立，不单单指做饭，所以换个角度看，这也算个好处，你知道，料理食物也是有其哲学在内的，通过对美食的理解不同才产生了当今世界如此多的菜系。想想看哪一道名菜不是那些大厨费尽心血设计出来的？这与编程做项目有相通之处。</p><p><img src="/image/CoUK/uk24.jpg" alt="UofE"></p><p><img src="/image/CoUK/uk25.jpg" alt="UofE"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>很有意思的一座瑰宝。这里商业化并不明显，适合慢节奏的生活，拿起一本SICP亦或是TAOCP；一边享受着下午茶一边想着Monad单子问题。读书读累了，就做做项目、补补番、打打游戏，总之做自己喜欢的事情，生活啊其实就是这样子。:-)</p><p><img src="/image/CoUK/uk14.jpg" alt="Cloudy#Edinburgh"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从倒时差算起有三个月了，比祖国慢了七个小时，渐渐习惯了这里的环境，开始尝试接触人文。还没有往伦敦三角那里走，只是在爱丁堡过了一个月的国际艺术节、推了苏格兰的高地便已是沉醉其中。这次出国算是我人生第一次真正意义的出国旅行，当然了主要目的是出国读（旅）书（行）。世界这么大，自己就寻思着有一天可以在曾经的小圈子外面转一转，这一转就走了很远，漂洋过海来到了不列颠。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="Edinburgh" scheme="http://izhen.me/tags/Edinburgh/"/>
    
      <category term="UK" scheme="http://izhen.me/tags/UK/"/>
    
      <category term="UofE" scheme="http://izhen.me/tags/UofE/"/>
    
  </entry>
  
  <entry>
    <title>编程珠玑第三部分随笔——十一至十五章</title>
    <link href="http://izhen.me/2015/06/27/ProgrammingPearlsPart3-11-15/"/>
    <id>http://izhen.me/2015/06/27/ProgrammingPearlsPart3-11-15/</id>
    <published>2015-06-27T02:29:56.000Z</published>
    <updated>2016-08-14T01:53:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>第三部分是《编程珠玑》的精华，对于这块内容我建议是边读边结合实际。最好是在项目中用到了作者给出的方法，这样的理解会更加深入。我在这一部分统一做一个简单的总结，恰好很多内容曾经遇到过，不论是在项目中还是编程竞赛中。作者给出了很多经典的解决方案看起来似曾相识，这也说明了好的方法渊远流长，可能以前有人拜读过此书，并且把解决方案早早应用在了自己的项目之中。</p><a id="more"></a><blockquote><p>解决现有的问题是程序员任务的一部分，另一个也许更重要的部分是做好解决未来问题的准备。有时，这种准备包括听课或者读书；不过更常见的情况是，程序员通过询问自己如何用不同的方法解决问题来得到提高。</p></blockquote><h3 id="第十一章排序"><a href="#第十一章排序" class="headerlink" title="第十一章排序"></a>第十一章排序</h3><p>这一章节的主题就是我们最为常用的排序算法了，可以说但凡是初学计算机入门的程序员，冒泡排序往往是第一个正式的算法。本章的主人公是快速排序，我们其实在前面几章的习题中已经用过快排的思想了，如果没记错就是讲解二分算法的一章。二分算法作为可以说同样为最常用的算法之一，其前提条件就是作用对象相对有序。有序化有时会给我们带来很大的帮助。随机的快排，应该可以为你的项目提速不少。</p><h3 id="第十二章取样问题"><a href="#第十二章取样问题" class="headerlink" title="第十二章取样问题"></a>第十二章取样问题</h3><p>我觉得这是很重要的一章，特别是在大数据时代，面临的数据处理与日俱增，当我们面对在一个很大样本空间中取样时，书中的方法就很好用了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select = m</span><br><span class="line">remaining = n</span><br><span class="line"><span class="keyword">for</span> i = [<span class="number">0</span>, n)</span><br><span class="line"><span class="keyword">if</span> (bigrand() % remaining) &lt; select</span><br><span class="line">print i</span><br><span class="line">select--</span><br><span class="line">remaining--</span><br></pre></td></tr></table></figure><p>上面这段取样程序很巧妙，Knuth证明了其正确性，而另一种由Knuth提出的方法即是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = [<span class="number">0</span>, n)</span><br><span class="line">swap(i, randint(i, n - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>然后把前m个元素取出，想想看是不是很棒的思路？</p><h3 id="第十三章搜索"><a href="#第十三章搜索" class="headerlink" title="第十三章搜索"></a>第十三章搜索</h3><p>这个就不用说了，太广泛的算法。哪里都会用到搜索，比如我们设计游戏，其中用到的寻路算法A*，最近听说有更好的解决方案了。虽然这个方法常用，但是在遇到剪枝等复杂的优化情况时，仍然要多多积累。</p><h3 id="第十四章堆"><a href="#第十四章堆" class="headerlink" title="第十四章堆"></a>第十四章堆</h3><p>还记得曾经写过的Dijkstra的单源最短路径算法吗？算法复杂度是多少？如果用优先队列优化后又会是多少？我们操作系统的内存管理的数据结构就用到了堆栈，而且因为堆本身良好的性质：二叉堆是完全二叉树，其实现非常漂亮简洁。此外，理论上很牛掰的裴波那契堆可以被实现很简洁的配对堆在实用中替代。值得深入研究的一个领域。</p><h3 id="第十五章字符串"><a href="#第十五章字符串" class="headerlink" title="第十五章字符串"></a>第十五章字符串</h3><p>作者把这一章留作结束，也给了我一些回忆。记得小学时最后一个算法就是字符串处理，当时还写着BASIC代码。直到高中时代学会的KMP、AC自动机、Tire等之后就告一段落了。首先，字符串非常重要，可以说我们大部分工作都是围绕着文本进行了，而且字符串中模式匹配占据着一定的比例。本章作者提到了后缀数组，我觉得有必要连带后缀树一同学习一下。而生成文本部分则给了我一个惊喜。试想用一个「具有固定转换概率的有限状态马尔可夫链」去生成一个随机英文文本，且其中大部分都是真正的英文单词是多么有趣的一件事。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这是一本干货充足的好书，很难得遇到这样的作品。通读过后，感觉这辈子值了~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三部分是《编程珠玑》的精华，对于这块内容我建议是边读边结合实际。最好是在项目中用到了作者给出的方法，这样的理解会更加深入。我在这一部分统一做一个简单的总结，恰好很多内容曾经遇到过，不论是在项目中还是编程竞赛中。作者给出了很多经典的解决方案看起来似曾相识，这也说明了好的方法渊远流长，可能以前有人拜读过此书，并且把解决方案早早应用在了自己的项目之中。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="排序" scheme="http://izhen.me/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="取样" scheme="http://izhen.me/tags/%E5%8F%96%E6%A0%B7/"/>
    
      <category term="搜索" scheme="http://izhen.me/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="字符串" scheme="http://izhen.me/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="堆" scheme="http://izhen.me/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>编程珠玑第十章探讨</title>
    <link href="http://izhen.me/2015/06/23/ProgrammingPearls10/"/>
    <id>http://izhen.me/2015/06/23/ProgrammingPearls10/</id>
    <published>2015-06-22T16:52:39.000Z</published>
    <updated>2016-08-14T01:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一章的内容很贴近实际。一方面我们的确要面对现实，不可能永远都有充足的存储空间；另一方面，数据空间的压缩有时不是只有单一的含义，这里的数据可能指代状态空间的总数，也就是说，此时对于数据空间的优化，是与时间挂钩的。不过，更常见的情景依旧是时间换空间，空间换时间。鱼和熊掌不可得兼，考虑哪个更加重要进而作出优化的判断。<br><a id="more"></a></p><blockquote><p>重新计算、稀疏结构、信息理论、分配策略；函数定义、解释程序、翻译</p></blockquote><h3 id="问题探讨"><a href="#问题探讨" class="headerlink" title="问题探讨"></a>问题探讨</h3><p>1.这个问题可以理解为，原始压缩的数据在被处理时需要的指令相对比较多，可以类比「重新计算」。但是把压缩去掉后就是原始数据，无需解压操作，面对这类数据时，指令数会减少不少，所以代码空间少了很多。</p><p>6.这个编码思想我觉得非常重要，信息论本身在我们的生活中体现着很重要的作用，对于编码的研究不但可以更高效的存储，还可以在通信领域施展拳脚。譬如数据压缩技术，我们现在享受的互联网多媒体：在线的音乐、视频、图片，以及未来的「流游戏(<a href="https://www.shinra.com/us" target="_blank" rel="noopener">神罗</a>公司)」五一不为了更快速的传输对原本庞大的体积进行了压缩，将这种思想用于程序，当然我们也能得到不菲的回报。</p><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>尽管我们有时候不得以在时间和空间中二选一，但是有时候也许会有完美的状况发生：时间空间都恰到好处。不过这种完美是片面的，往往会伴随着「复杂」，在本章的边栏文摘中就体现了这一点，Ken Thompson 为国际象棋分析程序优化数据空间而使用了一种相对繁杂的分析手段，如果你做过USACO，就知道USACO 1.5.4 checker，也就是第一章最后一题，就可以使用这种发掘棋盘对称性的技术从而优化状态空间提升速度。如果空间相当重要，我们自然也不会吝惜那一点复杂。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一章的内容很贴近实际。一方面我们的确要面对现实，不可能永远都有充足的存储空间；另一方面，数据空间的压缩有时不是只有单一的含义，这里的数据可能指代状态空间的总数，也就是说，此时对于数据空间的优化，是与时间挂钩的。不过，更常见的情景依旧是时间换空间，空间换时间。鱼和熊掌不可得兼，考虑哪个更加重要进而作出优化的判断。&lt;br&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="数据空间技术" scheme="http://izhen.me/tags/%E6%95%B0%E6%8D%AE%E7%A9%BA%E9%97%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="压缩" scheme="http://izhen.me/tags/%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>编程珠玑第九章探讨</title>
    <link href="http://izhen.me/2015/04/21/ProgrammingPearlsCh9/"/>
    <id>http://izhen.me/2015/04/21/ProgrammingPearlsCh9/</id>
    <published>2015-04-21T14:32:33.000Z</published>
    <updated>2016-08-14T01:53:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章的内容让我想到了去年参加<a href="http://izhen.me/2014/04/20/2014-04-20-asc-2014-pre/">超算大赛</a>的经历。当时所做的诸多事务中有一环就是代码调优，列举一下调优的经过大概就是：分析代码，找到热点，重构函数，调优参数。在这一章中，热点的寻找和重构函数都有提及，因为是一篇介绍性质的文章所以没有说明怎样调优一个系统。不过书中对于最基础的调优的介绍已经充分了，而且在更多的情况下，代码调优也差不多就是指代这些。<br><a id="more"></a></p><blockquote><p>代码调优的最重要原理就是尽量少用它</p></blockquote><h3 id="问题探讨"><a href="#问题探讨" class="headerlink" title="问题探讨"></a>问题探讨</h3><p>本章的内容分析了包括基于高速缓存原理的调优，宏定义调优，代码展开等。当我们在调优一个大型的系统时，往往调优的顺序是先考虑串行调优，这时候我们会首先在编译参数上动手脚，因为这是最省事的，然后会进行一些指令级并行的调优，例如代码展开，循环重构等，都有助于高效利用缓存并增加指令并行的可能，当然如果在更高阶的层面上可以优化，比如等价的代数表达或者更换算法的话，固然更好；另一方面，我们还会进行并行的调优，第一步也是编译参数调试，然后我们可能会改写OpenMP或者MPI的部分使得通信瓶颈得到优化，但是这些不在我们的讨论范围内，只提一句，不必细说。</p><p>不论是循环展开亦或是循环的重构都可以归结为局部访存优化，书中第一个例子可以归结为这一类，不同的是，作者的实现利用了高速缓存的原理，而不是让系统自己去管理(也没办法自己管理)。另一个不得不提到的就是循环展开，当二分搜索的上下界确定的时候，我们可以展开整个二分循环，下面是书中给出的上界1000的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> (x[<span class="number">511</span>] &lt; t) l = <span class="number">1000</span> - <span class="number">512</span></span><br><span class="line"><span class="keyword">if</span> (x[l + <span class="number">256</span>] &lt; t) l += <span class="number">256</span></span><br><span class="line"><span class="keyword">if</span> (x[l + <span class="number">128</span>] &lt; t) l += <span class="number">128</span></span><br><span class="line"><span class="keyword">if</span> (x[l + <span class="number">64</span>]  &lt; t) l += <span class="number">64</span></span><br><span class="line"><span class="keyword">if</span> (x[l + <span class="number">32</span>]  &lt; t) l += <span class="number">32</span></span><br><span class="line"><span class="keyword">if</span> (x[l + <span class="number">16</span>]  &lt; t) l += <span class="number">16</span></span><br><span class="line"><span class="keyword">if</span> (x[l + <span class="number">8</span>]   &lt; t) l += <span class="number">8</span></span><br><span class="line"><span class="keyword">if</span> (x[l + <span class="number">4</span>]   &lt; t) l += <span class="number">4</span></span><br><span class="line"><span class="keyword">if</span> (x[l + <span class="number">2</span>]   &lt; t) l += <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> (x[l + <span class="number">1</span>]   &lt; t) l += <span class="number">1</span></span><br><span class="line">p = l + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (p &gt; <span class="number">1000</span> || x[p] != t)</span><br><span class="line">p = <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>4.这个问题挺有意思，归结与宏定义的语义问题可能会大大影响到代码的效率。我想到曾经我打ACM比赛时，在赛场上用到了<code>memset()</code>初始化数据，结果一直<code>TLE</code>而且找不到原因。终于在无数次<code>WA</code>之后，我们更换为一个循环初始化数据后才顺利<code>AC</code>。C++的确存在很多陷阱，但是我在自己的机器上试验的时候，并没有这个问题中提到的现象。</p><p>7.因为一个非常的长的字节序列我们可以看成很多个有限长度的字节序列的总和，而有限长度的字节序列，比方说是8位的，当长达10亿或更多的时候，里面必然会存在很多的重复，因为8位数只有256种可能，所以我们只需要一开始统计256个数各个包含多少个1，然后把很多的数位切成8位一组的N个组再统计就起到加速的作用了。</p><p>11.最初我领略打表的精妙是在高中时，参加了一次<strong>CTSC</strong>和<strong>APIO</strong>然后跟一位大牛学会的。我觉得都可以归结为Hash表的思想，就是快速的索引，这能够解决很多问题，比如减少重复或不必要的计算。</p><p>12.先因式分解，减少乘法计算次数。属于对于已有结果加以利用而不是重复计算。</p><h3 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h3><p>在过去，程序员知道，如果程序的运行时间主要消耗在输入输出上，那么对程序中的计算进行加速是毫无意义的。在现代的体系结构中，如果对内存的访问占用了大量的运行时间，那么减少计算时间同样是毫无意义的。</p><p>对老式计算机来说，降低开销可以加速10%或20%。对于现代计算机来说，将循环展开则有助于避免管道阻塞、减少分支、增加指令级的并行性。</p><p>效率的角色。软件的其他许多性质和效率一样重要，甚至更重要。Don Knuth观察发现，不成熟的优化是大量编程灾害的根源，它会危机程序的正确性、功能性以及可维护性。当可能危害影响较大时，请考虑适当将效率放一放。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章的内容让我想到了去年参加&lt;a href=&quot;http://izhen.me/2014/04/20/2014-04-20-asc-2014-pre/&quot;&gt;超算大赛&lt;/a&gt;的经历。当时所做的诸多事务中有一环就是代码调优，列举一下调优的经过大概就是：分析代码，找到热点，重构函数，调优参数。在这一章中，热点的寻找和重构函数都有提及，因为是一篇介绍性质的文章所以没有说明怎样调优一个系统。不过书中对于最基础的调优的介绍已经充分了，而且在更多的情况下，代码调优也差不多就是指代这些。&lt;br&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="代码调优" scheme="http://izhen.me/tags/%E4%BB%A3%E7%A0%81%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>树莓派上手记录</title>
    <link href="http://izhen.me/2015/03/31/raspberry-tut/"/>
    <id>http://izhen.me/2015/03/31/raspberry-tut/</id>
    <published>2015-03-30T16:17:43.000Z</published>
    <updated>2016-10-21T03:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/flash-rasp.jpg" alt="Raspberry - Flash 播放器支持"></p><p>这些天上手了 Raspberry Pi 2 Model B，非常mini跟一张信用卡差不多大，适合学习Linux和做一些好玩的玩意儿。考虑到是ARM架构的设备，必然很多应用是用不了的。它非常吸引我的有两点，一是支持 <a href="http://www.raspberrypi.org/tag/python/" target="_blank" rel="noopener">Python</a> 和 <a href="http://dev.windows.com/en-us/featured/raspberrypi2support" target="_blank" rel="noopener">Win10</a> ，二是居然有树莓派版本的 <a href="http://pi.minecraft.net" target="_blank" rel="noopener">Minecraft</a> 。除了以上这些，因为树莓派本身很小巧，可以做很多玩具，比如遥控车之类的，作为一个开发工具也是一种选择。<br><a id="more"></a></p><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><p>鉴于是初学，我们一步一步从买东西开始说起。我们至少需要</p><ul><li>一片Raspberry</li><li>一根HMDI线 </li><li>一根microUSB线</li><li>一个 5V 2A 的DC电源 </li><li>一张不小于8G的microSD卡</li><li>一根网线或者usb wifi(我选用edup的树莓派专用wifi，免驱)。</li><li>支持HDMI的屏幕</li></ul><p>Raspberry只是一块板子，除了必要的芯片和接口外。本身连硬盘都没有，所以我们要自备SD卡充当硬盘以及筹集一切其他外设，包括键盘鼠标等。这里要注意，树莓派本身的负载很小，我们如果用某些键盘可能造成树莓派电压不足。所以要么用自带电源的USB hub，要么用电流小的键盘鼠标，一般的薄膜键盘和光电鼠就可以。</p><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p><img src="/image/rasp1.jpg" alt="Raspberry"></p><p>初学树莓派的我们就用最傻瓜的方式安装，先到官网上找到并下载 <a href="http://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">NOOBS</a> ，然后呢，我们把microSD卡格式化成<strong>FAT32</strong>格式，官方给了建议的格式化工具，<a href="https://www.sdcard.org/downloads/formatter_4/eula_mac/" target="_blank" rel="noopener">Formatter 4</a> (OS X版)。然后把解压好的 <a href="http://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">NOOBS</a> 全部内容复制到SD卡根目录上去。</p><p>接着我们连接好树莓派，包括鼠标、键盘、HDMI、SD卡和wifi网卡并给树莓派加电。然后我们就可以进入傻瓜模式安装了，因为安装非常简单，只要点点鼠标等待就行。可以选择你想要安装的内容，在1.4版中似乎只剩下了Raspbian，其他的发行版要么自行安装，要么等待官方更新。在安装成功后，我们设置一下进入到GUI模式，这个也比较简单看文字提示就好了，设置完成后要求重启动。</p><p><img src="/image/rasp4.jpg" alt="Raspberry"></p><p>上图是启动成功后的界面(by <a href="http://www.realvnc.com/download/viewer/" target="_blank" rel="noopener">VNC Viewer</a>)：</p><p><img src="/image/rasp3.jpg" alt="Raspberry"></p><h2 id="wifi设置"><a href="#wifi设置" class="headerlink" title="wifi设置"></a>wifi设置</h2><p>比起网线，wifi还是要方便许多。我们在开机启动后连接edup(具体型号就不打广告了)的wifi，之所以用这个是因为这个对树莓派1/2两代都是免驱的。这个特性帮我们省了大心，不用专门去驱动wifi了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsusb</span><br></pre></td></tr></table></figure><p>如果可以看到<code>Realtek</code>字样，那么说明连接上了。然后我们做如下几步</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nano /etc/network/interfaces</span><br></pre></td></tr></table></figure><p>修改成如下内容并且保存(Ctrl-X)</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">iface eth<span class="number">0</span> inet dhcp</span><br><span class="line">allow-hotplug wlan<span class="number">0</span></span><br><span class="line">face wlan<span class="number">0</span> inet static</span><br><span class="line">iface default inet dhcp</span><br><span class="line">wpa-ssid 你的wifi的ID</span><br><span class="line">wpa-psk  你的wifi的密码</span><br><span class="line">address <span class="number">192.168</span>.<span class="number">1</span>.XXX  <span class="comment">#固定IP，可以设置一个</span></span><br><span class="line">netmask <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">gateway <span class="number">192.168</span>.<span class="number">1.1</span></span><br><span class="line">network <span class="number">192.168</span>.<span class="number">1.1</span></span><br><span class="line"><span class="comment">#wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf</span></span><br></pre></td></tr></table></figure><p>保存后重新启动</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo reboot</span><br></pre></td></tr></table></figure><p>之后我们就可以正常上网了，而这些设置文件对我们后期设置远程登录也是很有用的，其实就是一个固定ip。感受一下：</p><p><img src="/image/rasp7.jpg" alt="Raspberry"></p><h2 id="VNC远程登录"><a href="#VNC远程登录" class="headerlink" title="VNC远程登录"></a>VNC远程登录</h2><p>有了这个我们就可以告别外接屏幕了。节约出一块屏幕的同时，也节省了树莓派用来连接鼠标和键盘的两个USB接口，这样一来树莓派本身的负载就会下降，这是不是会让树莓派的运行更稳定我就不太清楚了，VNC Server的负荷是客观存在的。不过缺点就是使用远程登录操控树莓派必然是有一定延迟。而且不能够直接接收音频，妄想着用VNC听音乐是不靠谱的。如果非要远程听的话就用树莓派搭建个流媒体服务器好了。</p><p><img src="/image/rasp-vnc.jpg" alt="Raspberry"></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install tightvncserver</span><br><span class="line">$ vncpasswd  <span class="comment">#设置密码</span></span><br></pre></td></tr></table></figure><p>接着运行如下命令，修改配置文件</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nano /etc/init.d/tightvncserver</span><br></pre></td></tr></table></figure><p>修改为下述内容</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:          tightvncserver</span></span><br><span class="line"><span class="comment"># Required-Start:    $local_fs</span></span><br><span class="line"><span class="comment"># Required-Stop:     $local_fs</span></span><br><span class="line"><span class="comment"># Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop:      0 1 6</span></span><br><span class="line"><span class="comment"># Short-Description: Start/stop tightvncserver</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"><span class="comment"># More details see:</span></span><br><span class="line"><span class="comment"># http://www.penguintutor.com/linux/tightvnc</span></span><br><span class="line"><span class="comment">### Customize this entry</span></span><br><span class="line"><span class="comment"># Set the USER variable to the name of the user to start tightvncserver under</span></span><br><span class="line">export USER=‘pi’</span><br><span class="line"><span class="comment">### End customization required</span></span><br><span class="line">eval cd ~$USER</span><br><span class="line"><span class="keyword">case</span> “$1” <span class="keyword">in</span></span><br><span class="line">  start)</span><br><span class="line">    su $USER -c ‘/usr/bin/tightvncserver -depth <span class="number">16</span> -geometry <span class="number">1024</span>x768 <span class="symbol">:</span><span class="number">1</span>’</span><br><span class="line">    echo “Starting TightVNC server <span class="keyword">for</span> $USER “</span><br><span class="line">    ;;</span><br><span class="line">  stop)</span><br><span class="line">    su $USER -c ‘/usr/bin/tightvncserver -kill <span class="symbol">:</span><span class="number">1</span>’</span><br><span class="line">    echo “Tightvncserver stopped”</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    echo “<span class="symbol">Usage:</span> /etc/init.d/tightvncserver &#123;start<span class="params">|stop&#125;”</span></span><br><span class="line"><span class="params">    exit 1</span></span><br><span class="line"><span class="params">    ;;</span></span><br><span class="line"><span class="params">esac</span></span><br><span class="line"><span class="params">exit 0</span></span><br></pre></td></tr></table></figure><p>之后添加到系统启动项</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod <span class="number">755</span> /etc/init.d/tightvncserver</span><br><span class="line">$ sudo update-rc.d tightvncserver defaults</span><br></pre></td></tr></table></figure><p>然后我们下载一个 <a href="http://www.realvnc.com/download/viewer/" target="_blank" rel="noopener">VNC Viewer</a> ，它的使用非常简单，只需要输入IP地址和端口号就OK。</p><h2 id="娱乐派"><a href="#娱乐派" class="headerlink" title="娱乐派"></a>娱乐派</h2><p>这里我们简单说明一下如何配置Flash和音频输出以及中文环境。对于我们的娱乐来说很有帮助，有时候适当的消遣是必要的。不过就是树莓派的音质和画质都有限，不过也无所谓，毕竟对我们来说树莓派能做的已经够多了。</p><h3 id="Flash环境"><a href="#Flash环境" class="headerlink" title="Flash环境"></a>Flash环境</h3><p>因为树莓派是ARM架构的，所以我们如果要使用树莓派播放Flash的话，需要找到支持ARM架构的Flash插件。目前已知的有： <a href="http://odroidxu.leeharris.me.uk/PepperFlash-12.0.0.77-armv7h.tar.gz" target="_blank" rel="noopener">PepperFlash</a> ，这个插件的安装教程有朋友已经<a href="http://tieba.baidu.com/p/3587157171" target="_blank" rel="noopener">共享</a>了。因为用树莓派播放Flash不是一般的卡，所以如果仍然有兴趣尝试，可以安装并配置一下。Flash视频播放器的播放示例效果请见文章<a href="#">首部</a>。</p><h3 id="中文环境支持"><a href="#中文环境支持" class="headerlink" title="中文环境支持"></a>中文环境支持</h3><p>首先修改环境语言</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo raspi-config</span><br></pre></td></tr></table></figure><p>然后找到<code>Change locale</code>并且勾选：en_US.UTF-8 UTF-8；zh_CN.UTF-8 UTF-8；zh_CN.GBK GBK，确认后在终端中继续执行如下命令：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get -y install ttf-wqy-zenhei <span class="comment">#安装字体</span></span><br><span class="line">$ sudo apt-get -y install scim-pinyi     <span class="comment">#安装输入法</span></span><br><span class="line">$ sudo reboot</span><br></pre></td></tr></table></figure><p>上面个的字体和输入法安装都只是示例，如果有需求可以安装自己想要的任何字体和输入法。</p><h3 id="音频模块设置"><a href="#音频模块设置" class="headerlink" title="音频模块设置"></a>音频模块设置</h3><p>树莓派要想播放mp3文件除了安装必要的播放软件外，还要把音频模块加入到内核中去，这样音频输出才能正常工作。执行下述命令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install alsa-utils</span><br><span class="line">$ sudo modprobe snd_bcm2835</span><br><span class="line">$ sudo amixer cset numid=<span class="number">3</span> <span class="number">1</span>      <span class="comment">#如果要输出到HDMI那么就是 3 2</span></span><br><span class="line">$ sudo apt-get -y install mplayer <span class="comment">#安装播放软件</span></span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>上述就是最基本的树莓派上手配置了。如果要做开发的话，我们还有很多其他的事情要做，比方说安装一些支持ARM架构的语言和数据库等。树莓派本身有可以作为媒体中心的发行版Linux，有兴趣可以尝试安装相关版本。同时也有诸如RISC OS和激进的Arch Linux等待大家去探索。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/image/flash-rasp.jpg&quot; alt=&quot;Raspberry - Flash 播放器支持&quot;&gt;&lt;/p&gt;
&lt;p&gt;这些天上手了 Raspberry Pi 2 Model B，非常mini跟一张信用卡差不多大，适合学习Linux和做一些好玩的玩意儿。考虑到是ARM架构的设备，必然很多应用是用不了的。它非常吸引我的有两点，一是支持 &lt;a href=&quot;http://www.raspberrypi.org/tag/python/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python&lt;/a&gt; 和 &lt;a href=&quot;http://dev.windows.com/en-us/featured/raspberrypi2support&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Win10&lt;/a&gt; ，二是居然有树莓派版本的 &lt;a href=&quot;http://pi.minecraft.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Minecraft&lt;/a&gt; 。除了以上这些，因为树莓派本身很小巧，可以做很多玩具，比如遥控车之类的，作为一个开发工具也是一种选择。&lt;br&gt;
    
    </summary>
    
      <category term="Hardware" scheme="http://izhen.me/categories/Hardware/"/>
    
    
      <category term="Raspberry" scheme="http://izhen.me/tags/Raspberry/"/>
    
      <category term="wifi" scheme="http://izhen.me/tags/wifi/"/>
    
      <category term="vnc" scheme="http://izhen.me/tags/vnc/"/>
    
      <category term="Flash" scheme="http://izhen.me/tags/Flash/"/>
    
      <category term="Audio" scheme="http://izhen.me/tags/Audio/"/>
    
      <category term="中文" scheme="http://izhen.me/tags/%E4%B8%AD%E6%96%87/"/>
    
      <category term="Linux" scheme="http://izhen.me/tags/Linux/"/>
    
      <category term="ARM" scheme="http://izhen.me/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>海外留学申请计划</title>
    <link href="http://izhen.me/2015/03/10/graduate/"/>
    <id>http://izhen.me/2015/03/10/graduate/</id>
    <published>2015-03-10T12:01:21.000Z</published>
    <updated>2017-12-26T15:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>新春第一更。海外留学申请是一项系统工程，知己知彼，百战不殆。利用互联网做充分调查是必要的。比如国外大学的基本要求和申请流程等等。还需要通过一些早年申请者的结果来判断申请难易程度，正确的判断对于战略战术准备很有帮助，错误的判断可能导致最终全军覆没。</p><p>申请方式：DIY<br><a id="more"></a></p><h2 id="基本性能"><a href="#基本性能" class="headerlink" title="基本性能"></a>基本性能</h2><ul><li>硬 件：83%，本科排名: 大陆 Top 10</li><li>竞 赛：ASC世界大学生超级计算机竞赛一等奖与一项世界纪录；高中NOIP一等保送；ACM省赛水铜牌一枚；大学校级算法竞赛一等二等若干；全国数学建模竞赛三等两次；MCM三等。</li><li>科 研：无Paper；高中时代在OI竞赛杂志上发表过文章</li><li>实 习：省重点实验室研究助理</li><li>实 践：练手项目若干</li><li>奖学金：两次</li></ul><h2 id="目标探测"><a href="#目标探测" class="headerlink" title="目标探测"></a>目标探测</h2><p>要申请的专业是计算机科学，人工智能/机器学习也OK，主要目标英联邦。英国：G5中除了LSE都申请了，外加两个大众情人学校曼大和爱大。香港：基本就是两大名校中选择。非英联邦国家：有考虑慕尼黑工业、苏黎世联邦理工、洛桑联邦理工，另外因为法国的大学对于PL的研究非常重视，所以也考虑过。</p><table><thead><tr><th>学校名称</th><th></th><th>专业</th></tr></thead><tbody><tr><td>剑桥大学</td><td></td><td>MPhil in Advanced Computer Science</td></tr><tr><td>牛津大学</td><td></td><td>MSc in Computer Science</td></tr><tr><td>伦敦帝国学院</td><td></td><td>MSc in Advanced Computing</td></tr><tr><td>伦敦大学学院</td><td>两个志愿</td><td>MSc in Machine Learning &amp; MSc in CSML</td></tr><tr><td>爱丁堡大学</td><td>两个志愿</td><td>MSc in Computer Science &amp; MSc in Artificial Intelligence</td></tr><tr><td>香港大学</td><td></td><td>MSc in Computer Science</td></tr><tr><td>曼彻斯特大学</td><td></td><td>MSc in Advanced Computer Science</td></tr></tbody></table><p>*注：上述排名参照 <a href="http://www.usnews.com/education/best-global-universities/rankings?int=9cf408" target="_blank" rel="noopener">USNEWS</a> 世界大学(2015)综合排名。要注意，有些英国大学的CS硕士项目开设了「CS班」，这种专业是给「没有」计算机背景的人准备的，它会从零开始教授如何编程，所修的专业课包含部分本科课程，科班出身的同学申请时不要弄错了以免浪费一年的时间和财力。牛津和爱丁堡的CS项目都是普通的，可以放心申请。如果想去IC学普通的计算机科学，那么你要申请先进计算(Advanced Computing)或某些Specilism，UCL同理。</p><h2 id="文书加成"><a href="#文书加成" class="headerlink" title="文书加成"></a>文书加成</h2><p>需要有的文书有SoP/PS，CV/Resume，推荐信，RP(研究型需要，否则不用)，学位与绩点证明，实习证明，活动或竞赛参与证明。</p><p>如果能够找到牛推是最好的，不行的话凑齐三封就可以，我找最了解我的两位Prof和一位Dr，Dr是超算大赛的教练，而Prof都是我的课程老师，其中一位是我FYP的导师。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><table><thead><tr><th>学校名称</th><th>结果</th><th>专业</th></tr></thead><tbody><tr><td>剑桥大学</td><td>Rejected</td><td>MPhil in Advanced Computer Science</td></tr><tr><td>牛津大学</td><td>Rejected</td><td>MSc in Computer Science</td></tr><tr><td>爱丁堡大学</td><td>Con Offer</td><td>MSc in Artificial Intelligence</td></tr><tr><td>爱丁堡大学</td><td>Con Offer</td><td>MSc in Computer Science</td></tr><tr><td>伦敦大学学院</td><td>Rejected</td><td>MSc in CSML</td></tr><tr><td>伦敦大学学院</td><td>Con Offer</td><td>MSc in Machine Learning</td></tr><tr><td>伦敦帝国学院</td><td>Rejected</td><td>MSc in Advanced Computing</td></tr><tr><td>曼彻斯特大学</td><td>Con Offer</td><td>MSc in Advanced Computer Science</td></tr><tr><td>香港大学</td><td>Con Offer</td><td>MSc in Computer Science</td></tr></tbody></table><p>*注：上述排名参照 <a href="http://academic.research.microsoft.com" target="_blank" rel="noopener">Microsoft</a> 的 <a href="http://academic.research.microsoft.com/RankList?entitytype=7&amp;topdomainid=2&amp;last=0&amp;continentid=4" target="_blank" rel="noopener">Computer Science</a> 领域专业排名 (链接已经失效)。</p><h2 id="申请流程"><a href="#申请流程" class="headerlink" title="申请流程"></a>申请流程</h2><p>申请的流程一般如下：</p><p>填写申请表格，交报名费（如果有），然后会进入self-service系统（如果有），在系统中可以追踪申请结果以及后期需要提交的文件等，包括语言(Official)，护照和学位证明。</p><p>经过申请发现：</p><ul><li>UCL和Oxford用的申请系统长得很像</li><li>ICL和NYU用的申请系统长得很像</li><li>CamU和ManU用的申请系统长得很像</li></ul><p>不是所有的学校都会安排测试环节，有些学校只是通过上传的文书发offer。</p><h3 id="Cambridge"><a href="#Cambridge" class="headerlink" title="Cambridge"></a>Cambridge</h3><p>剑桥大学申请系统挺特别，里面限制不少，而且self-service系统设计的不怎么人性化，感兴趣可以自己试试。MPhil in ACS不需要PS和CV，替代它们的是一套调查问卷，这个问卷的重点是需要写个mini版的研究计划，我写了两份，第一志愿是人工智能相关课题，第二志愿则有关程序设计语言。同时还让你预演选课，也就是说不是真选课，是看看你的兴许点在哪里。都忙完后就可以等待面试通知了，因为官方说想要去剑桥读这个项目必须通过面试，如果很幸运没有面试，那么只能说……。我就是那个幸运的人:)</p><h3 id="Oxford"><a href="#Oxford" class="headerlink" title="Oxford"></a>Oxford</h3><p>他家有笔试和面试，笔试共四道题目，通过学校和学院筛选后会有笔试。第一题是简要介绍学术背景，第二题是概率，第三题是算法设计和证明，第四题是程序片段分析。都不算难，我在提交了笔试答案后过了一个多月等到了面试。面试问的问题也不算难，我看过以前同学的面经，相比之下，我的面试显得过于简单了。</p><p>一上来直接就问相关问题，没让我自我介绍，对方是个来自欧洲大陆的教授，英语有点口音但是说得很清楚，大部分还是听得明白的。首先是问我是不是计算机科学相关专业的(可能这么问的)，我没听到关键词说不是，我是软件工程的。他问有什么区别吗？我说了一堆，最后总结就是其实本科阶段学得很类似。他说我就是这个意思，结果你说NO。好吧，我听错了。</p><p>第一个专业问题是什么是P对NP，我回答的是在确定性图灵机中是否可以在多项式时间内解决等等，接着追问了什么是NP-hard，我举了一些例子，提到了八皇后问题。主要考察的是概念，没有让你现场分析NP问题。然后问了我喜欢什么课程，我说算法，数据结构，线性代数和高数等。然后他问，排序你了解吗，我说了解，可以分为稳定的和不稳定的两类。比如说快排不稳定，但是冒泡排序稳定。然后他追问，什么是稳定的排序。我举了个具体的例子解释稳定性。回答完后他问我归并排序的时间复杂度是多少？我说nlogn，他问，你是说Big O记号吗，我说没错。然后让我解释Big O，但是我听错了，分析了一遍为何是nlogn。结果教授说，我是说Big O你是怎么理解的，我反应过来了，他问的是关于大O记号的定义，然后我更正了自己的答案。</p><p>自由提问环节我问了一下牛津关于数学的看法，教授blahblah…说了一堆，其实就是说牛津当然觉得数学基础很重要。我也当然知道，只是一时没想起来有什么好问的，随便问了这个问题。以上就是面试全程了，自己的表现不是很好，尤其是有<strong>误解问题</strong>的情况发生，这是<strong>致命</strong>的。我也不太清楚面试的淘汰率究竟是多少，一路从申请、笔试、面试过来也明白一些问题，那就是有时候不要太在意别人给你的定位(尤其是中介，很多问题他们都不懂，而且不太会帮你什么)，要相信自己，想想在你自己看来你的自我定位是什么？有一丝一毫的希望也要勇于尝试，不论结果如何，挑战有时让你学得更多。</p><h3 id="Edinburgh"><a href="#Edinburgh" class="headerlink" title="Edinburgh"></a>Edinburgh</h3><p>爱大的专排挺高，<a href="http://academic.research.microsoft.com/RankList?entitytype=7&amp;topDomainID=2&amp;subDomainID=5&amp;last=0&amp;start=1&amp;end=100" target="_blank" rel="noopener">AI</a> 和理论计算机科学：比如「<a href="http://academic.research.microsoft.com/RankList?entitytype=7&amp;topDomainID=2&amp;subDomainID=24&amp;last=0&amp;start=1&amp;end=100" target="_blank" rel="noopener">Programming Language</a>」等尤其不错，是欧洲人工智能的中心。「信息学院」下设的专业都是UoE的王牌专业之一，我根据自身的兴趣爱好申请了Computer Science 和 AI。人工智能程序语言 <a href="http://zh.wikipedia.org/wiki/Prolog" target="_blank" rel="noopener">Prolog</a> 目前最主要的两个方言之一便是Edinburgh，函数式程序设计语言 <a href="http://en.wikipedia.org/wiki/ML_(programming_language)" target="_blank" rel="noopener">ML</a> 就是诞生于此。同时 <a href="https://www.haskell.org" target="_blank" rel="noopener">Haskell</a> 和 <a href="http://naftalin.info/maurice/professional/javaGenericsAndCollectionsReviews.html" target="_blank" rel="noopener">Generic Java</a> 的核心作者 <a href="http://homepages.inf.ed.ac.uk/wadler/" target="_blank" rel="noopener">Prof. Philip Wadler</a> 现在也在这里工作。申请的过程很简单，不需要额外参加面试和笔试，提交完申请表格后等待结果就好。</p><h3 id="UCL"><a href="#UCL" class="headerlink" title="UCL"></a>UCL</h3><p>UCL有笔试，我申请了两个项目，分别是ML和CSML，这两个项目是同一个委员会负责的，我更青睐后者，申请了一段时间后，UCL寄过来一套笔试题目，一共15道，全是数学题，感觉比牛津的笔试难度大。题目主要是概率论和数理统计，加上一点微积分和线性代数。概统的题目较多而且繁杂，存在相当一部分我没深入学习甚至没听过的概念，但是微积分和线性代数部分却非常简单，看来这也许是我们基础课学习的侧重点不同而导致的吧。答完笔试题目后就可以等待结果了。</p><h3 id="ICL"><a href="#ICL" class="headerlink" title="ICL"></a>ICL</h3><p>伦敦帝国学院挺不错的，质量很高而且只要是他家的专业领域，几乎都名列前茅。跟牛剑一样必须面试，所以提交完成申请材料后只要安静的等待好了。如果给了面试一般就是愿意录取，否则就没有下文了。</p><h3 id="Manchester"><a href="#Manchester" class="headerlink" title="Manchester"></a>Manchester</h3><p>老牌的理工强校，有兴趣可以自己查一下这所学校的历史。不需要申请费，推荐信可以自己提交的，提交完后等待结果就好。</p><h3 id="HKU"><a href="#HKU" class="headerlink" title="HKU"></a>HKU</h3><p>HKU有面试，他家的面试形式是最多8人一组进行群面，主要考察口语水平，积极性和英文逻辑思维能力等。我的面试过程大致是，没有自我介绍，第一个问题是Why港大。我说了Environment，包括语言、文化、学术等。第二个问题是开放性的编程问题，我觉得主要考察的是逻辑的完备性等等，问题本身挺简单。最后则是学生提问，整个流程40分钟，自我感觉还算OK。</p><h2 id="关于排名"><a href="#关于排名" class="headerlink" title="关于排名"></a>关于排名</h2><p>首先我们说到底要不要纠结于一个排名，这得见仁见智了，起码排名给了我们一个参考。具体来说，每个人的需求不同，追求的属性也不一样，有人只注重声誉，那么可以参照 <a href="http://www.timeshighereducation.co.uk/world-university-rankings/2015/reputation-ranking" target="_blank" rel="noopener">TIMES</a> <a href="http://www.topuniversities.com/qs-world-university-rankings" target="_blank" rel="noopener">QS</a> <a href="http://www.usnews.com/education/best-global-universities/rankings?int=9cf408" target="_blank" rel="noopener">USNEWS</a> 这三家的大学综合排名。而有的人则注重专排。我把我申请的大学的综排和专排都给了出来，以供参考。综排通常都是声誉排名，也就是这所大学的名气，一般这类排名浮动很大，一所学校今年25明年可能30+也可能前15了。这是因为主观因素比较多造成的，至于哪个排名比较靠谱，我个人认为很难说。另一方面，专业排名就相对稳定多了，因为学校的学术实力在那摆着，没那么轻易浮动，有变动也不至于大起大落。但是如果说综合排名「仅供娱乐」，那么专业排名有时候更需要小心，因为很多专业排名其实「不专业」，我只了解计算机科学，这里仅说计算机，判断计算机科学排名靠谱不靠谱就看排行榜的前四名，今年是2015年，到现在为止，如果前四名不是斯坦福、麻省理工、卡内基梅隆、加州大学伯克利那么这份排名几乎是不可信的，我想学计算机的同学都知道为什么。就个人而言，我<strong>通过综排决定要不要申这所学校，而通过专排决定最终去哪</strong>。以上只是一己之见，还请各位看官慎重决定。</p><p>附1：<a href="https://en.wikipedia.org/wiki/Research_Excellence_Framework#Performance_rankings" target="_blank" rel="noopener">英国官方学术排名REF</a>、<a href="http://www.shanghairanking.com/Shanghairanking-Subject-Rankings/computer-science-engineering.html" target="_blank" rel="noopener">ARWU计算机科学排名</a>、<a href="http://h5.iwuzhen.org/pdf/AI-China20170726.pdf" target="_blank" rel="noopener">2017全球大学人工智能Top30</a></p><p><img src="/image/arwu2017.jpg" alt="ARWU计算机科学排名"></p><p>当前人工智能广受追捧，要知道很多大学是开设独立AI学位的，感兴趣的同学可以参考下面的排名：</p><p><img src="/image/2017ai.jpg" alt="乌镇指数:全球人工智能发展报告(节选)"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>每个人出国的情况都不同，我的经验对于应届生更加合适。对于这些申请者来讲课外学术经历和课内GPA是核心，一切文书包括PS、CV、RL和RP等都是围绕着你自身的软硬条件来的。申请海外名校，GPA非常重要，不低于生死线3.0「约加权80%」是常识。如果有可能的话，收获3.7「约加权87%」以上的GPA是比较乐观的，其他情况只好尽人事、听天命了。但也不需要过分拘泥于这点GPA，有时候去或留就是那么回事，话说：宠辱不惊，闲看庭前花开花落；去留无意，漫随天外云卷云舒。另一方面，那些能让我们去挑战去收获更多的事物，例如学科竞赛、高质量的项目、科研和实习等，我是大力推荐的，如果你有创业的经历则更加锦上添花。这些活动能让你有大量机会接触业界前沿，认识一些强者，避免出现井底之蛙的情况。目前我们的基础学科教育「高数、线代等」还说得过去，但专业课程是大陆土本的弱势，谋事在人，成事在天，自己平时也要下足课内外的功夫，光指望学校的课程是不够的。</p><p>最后，祝天下出国党申请顺利，与君共勉。</p><p>附2：我用来辅助计算排名的小程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> num[<span class="number">10</span>][<span class="number">6</span>], par[] = &#123;<span class="number">0.125</span>, <span class="number">0.125</span>, <span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.125</span>, <span class="number">0.125</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swap</span>(<span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">T</span>&amp; <span class="title">b</span>)&#123;</span></span><br><span class="line">    T c = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//QS,THE,USNEWS,ARWU,ARWU_CS,QS_CS&amp;IS</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"QS,THE,USNEWS,ARWU,ARWU_CS,QS_CS&amp;IS"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i][<span class="number">0</span>] &gt;&gt; num[i][<span class="number">1</span>] &gt;&gt; num[i][<span class="number">2</span>] &gt;&gt; </span><br><span class="line">            num[i][<span class="number">3</span>] &gt;&gt; num[i][<span class="number">4</span>] &gt;&gt; num[i][<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j)</span><br><span class="line">            num[i][<span class="number">5</span>] += num[i][j] * par[j];</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">9</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i][<span class="number">5</span>] &gt; num[j][<span class="number">5</span>])&#123;</span><br><span class="line">                <span class="keyword">double</span> temp = num[i][<span class="number">5</span>];</span><br><span class="line">                num[i][<span class="number">5</span>] = num[j][<span class="number">5</span>];</span><br><span class="line">                num[j][<span class="number">5</span>] = temp;</span><br><span class="line">                swap(name[i], name[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[i][<span class="number">5</span>] &lt;&lt; <span class="string">" "</span>&lt;&lt; name[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新春第一更。海外留学申请是一项系统工程，知己知彼，百战不殆。利用互联网做充分调查是必要的。比如国外大学的基本要求和申请流程等等。还需要通过一些早年申请者的结果来判断申请难易程度，正确的判断对于战略战术准备很有帮助，错误的判断可能导致最终全军覆没。&lt;/p&gt;
&lt;p&gt;申请方式：DIY&lt;br&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="Edinburgh" scheme="http://izhen.me/tags/Edinburgh/"/>
    
      <category term="Oxbridge" scheme="http://izhen.me/tags/Oxbridge/"/>
    
      <category term="UCL" scheme="http://izhen.me/tags/UCL/"/>
    
      <category term="ICL" scheme="http://izhen.me/tags/ICL/"/>
    
      <category term="Commonwealth" scheme="http://izhen.me/tags/Commonwealth/"/>
    
  </entry>
  
  <entry>
    <title>编程珠玑第八章探讨</title>
    <link href="http://izhen.me/2014/12/02/ProgrammingPearlsCh8/"/>
    <id>http://izhen.me/2014/12/02/ProgrammingPearlsCh8/</id>
    <published>2014-12-02T08:38:58.000Z</published>
    <updated>2016-08-14T01:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一章节给出的问题让人从直觉上判断就是动态规划。不过，本章的分治算法也非常的巧妙，他们的优势都是避免了一些重复计算。动态规划本质也就是对于穷举法的优化。作者在指出这些算法时，由简单到困难的描述了复杂的算法有时能让效率大幅提高。对于O(n^2)的暴力来说，O(nlogn)的分治算法的确印证了这一点。但是O(n)的动态规划却不算复杂，相反，比起暴力他还来的简单些。而除了这道特定的题目以外，其他凡是用到DP的地方都能够反映出动态规划的简洁美，不失为一种优美且高效精巧的解决方案。<br><a id="more"></a></p><blockquote><p>复杂深奥的算法有时可以极大地提高程序性能</p></blockquote><h3 id="问题探讨"><a href="#问题探讨" class="headerlink" title="问题探讨"></a>问题探讨</h3><p>书中围绕着最大连续子串和分析了暴力，分治和DP的不同解决方案。这个问题是提出者对于二维模型的简化版本。我们可以只管判断，因为我们至少要扫描完整个子串才能断定最大的子串，所以这个算法的时间复杂度下界至少不小于O(n)：</p><p>先给出O(nlogn)的改进分治算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxsum</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> MAX(num[left], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    lmax = sum = <span class="number">0</span>;</span><br><span class="line">    lrec = mid;</span><br><span class="line">    rrec = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &gt;= left; i--)&#123;</span><br><span class="line">        sum += num[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; lmax)&#123;</span><br><span class="line">            lmax = sum;</span><br><span class="line">            lrec = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rmax = sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++)&#123;</span><br><span class="line">        sum += num[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; rmax)&#123;</span><br><span class="line">            rmax = sum;</span><br><span class="line">            rrec = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX(MAX(lmax + rmax, maxsum(left, lrec)), maxsum(rrec, right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是DP：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    temp = MAX(temp + num[i], <span class="number">0</span>);</span><br><span class="line">    ans = MAX(temp, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.试验表明，不是太容易看出来，取决于串的长度。</p><p>10.这道题目其实需要对判别条件做出理解，原本是MAX，我们要把这个MAX改为最接近0。但是其实我们可以得到任一区间的和，用累加数组num，那么从i到j的和就是num[j] - num[i - 1]，我们要求的就是num[j] - num[i - 1]最小。显然两个值越接近，他们的差就越小。直接找需要O(n^2)的复杂度，所以我们排个序，然后遍历找到最小的区间，O(nlogn)。</p><p>13.问题要求是求出矩形的数组，势必需要对行或者列进行遍历扫描。我们先划定一个维度，比如行。我们每次无重复的处理i到j行，所有的组合需要n^2的复杂度。然后每一对行组合，比如i1到j1行已经界定后，我们可以把它看成是一维的，用动态规划去处理。总的复杂度O(n^2m)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span>(col));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k++)</span><br><span class="line">            col[k] += num[j][k];</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k++)&#123;</span><br><span class="line">            temp = MAX(temp + col[k], <span class="number">0</span>);</span><br><span class="line">            tot = MAX(tot, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = MAX(ans, tot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="15"><li>T(1) = 0时，T(n) = 2nc。T(1) = c时，T(n) = nlognc。这里面有一定的启示，刚好印证着分治算法和动态规划的时间复杂度关系。</li></ol><h3 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h3><p>本章故事中的这些算法给出了几个重要的算法设计技术。</p><ul><li>保存状态，避免重复计算。算法2和算法4使用了简单的动态规划。通过使用一些空间来保存中间计算结果，我们避免了花时间对其重复计算。</li><li>将信息预处理至数据结构中。算法2b中得cumarr结构允许对子向量中的总和进行快速计算。</li><li>分治算法。算法3使用了简单地分治算法形式；有关算法设计的教科书介绍了更高级的分治算法形式。</li><li>扫描算法。与数组相关的问题经常可以通过思考“如何将x[0..i-1]的解扩展为x[0..i]的解”来解决。算法4通过同时存储已有的答案和一些辅助数据来计算新答案。</li><li>累积。算法2b使用了一个累积表，表中第i个元素的值为x中前i个值的总和；这一类表常用于处理有范围限制的问题。例如，业务分析师要确定3月份到10月份的销售额，可以从10月份的本年迄今销售额中减去2月份的销售额。</li><li>下界。只有在确定了自己的算法是所有可能算法中最佳的算法以后，算法设计师才可能踏踏实实地睡个好觉。为此，他们必须证明某个相匹配的下界。对问题线性下界的讨论见习题6，更复杂的下界证明可能会十分困难。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一章节给出的问题让人从直觉上判断就是动态规划。不过，本章的分治算法也非常的巧妙，他们的优势都是避免了一些重复计算。动态规划本质也就是对于穷举法的优化。作者在指出这些算法时，由简单到困难的描述了复杂的算法有时能让效率大幅提高。对于O(n^2)的暴力来说，O(nlogn)的分治算法的确印证了这一点。但是O(n)的动态规划却不算复杂，相反，比起暴力他还来的简单些。而除了这道特定的题目以外，其他凡是用到DP的地方都能够反映出动态规划的简洁美，不失为一种优美且高效精巧的解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="动态规划" scheme="http://izhen.me/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="下界" scheme="http://izhen.me/tags/%E4%B8%8B%E7%95%8C/"/>
    
      <category term="分治" scheme="http://izhen.me/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>再谈计算机的无上心法</title>
    <link href="http://izhen.me/2014/11/18/basic-skill-computer-con/"/>
    <id>http://izhen.me/2014/11/18/basic-skill-computer-con/</id>
    <published>2014-11-18T15:47:44.000Z</published>
    <updated>2016-08-14T01:51:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前说过<a href="http://izhen.me/2014/01/04/2014-01-18-basic-skill-computer/">这个</a>话题，现在看看当时真是肤浅了，首先这个问题挺空的，而且只有当时所诉说的技能很难称之为计算机的无上心法。单说代码实现的无上心法都差强人意，这里面需要的能力不仅仅是抽象，还包括设计。而设计恰恰又是很容易被忽略的，怎样定义一个好的设计我觉得这是因需求和领域而异的。参考艺术界，不同时代所流行的元素和主义在变化，比如最近备受推崇的极简主义。<br><a id="more"></a></p><p>我看到过的一个描述设计最简明扼要的文章就是<a href="http://www.yinwang.org" target="_blank" rel="noopener">王垠</a>写的谈创新(现在看不到了)。文中所说的创新其实是归结到设计层面的，我们不需要重复「造轮子」，搞出一些诡异的不能称之为创新的创新(造了一个方轮子，然后用在家用汽车上)。记得当时算法竞赛时知道的神牛胡伟栋也说过，所谓的创新是在充分了解前人已经做出的成果上出现的，而不是前人的东西看都不看就去凭空创造(原话记不清了)。记得高中的物理老师也说过：对以往知识的熟知和对新鲜事物及其发展前景的敏感，是一个人创造力的源泉。这里能举出的例子有很多，王垠专门拿出一些日常生活用品举例子，还推荐了一本书：<a href="http://www.amazon.cn/dp/0465050654/ref=wl_it_dp_o_pC_nS_ttl?_encoding=UTF8&amp;colid=2JWM5IEJYMWYS&amp;coliid=I35XSI3GN9ENRZ" target="_blank" rel="noopener">The Design of Everyday Things</a>。而有关于设计的书，那就太多了，可以看看讲复杂系统与架构的。</p><p>也可以看看<a href="http://www.amazon.cn/编程珠玑-本特利/dp/B003XH0L0Q/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1416326627&amp;sr=1-2&amp;keywords=编程珠玑" target="_blank" rel="noopener">编程珠玑</a>，书中<a href="http://izhen.me/2014/11/08/ProgrammingPearlsCh1/">第一章</a>就提出了作者所认可的好的设计。对于抽象与设计的理解上升到哲学高度自然就有了所谓的无上心法，「看似很多很难的问题，其中的道理其实很简单」，这种直觉不正是一种所谓的心法吗。而能够领悟这种直觉的过程和方式姑且可以称之为「无上」吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前说过&lt;a href=&quot;http://izhen.me/2014/01/04/2014-01-18-basic-skill-computer/&quot;&gt;这个&lt;/a&gt;话题，现在看看当时真是肤浅了，首先这个问题挺空的，而且只有当时所诉说的技能很难称之为计算机的无上心法。单说代码实现的无上心法都差强人意，这里面需要的能力不仅仅是抽象，还包括设计。而设计恰恰又是很容易被忽略的，怎样定义一个好的设计我觉得这是因需求和领域而异的。参考艺术界，不同时代所流行的元素和主义在变化，比如最近备受推崇的极简主义。&lt;br&gt;
    
    </summary>
    
      <category term="Think" scheme="http://izhen.me/categories/Think/"/>
    
    
      <category term="设计" scheme="http://izhen.me/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="抽象" scheme="http://izhen.me/tags/%E6%8A%BD%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>编程珠玑第七章探讨</title>
    <link href="http://izhen.me/2014/11/18/ProgrammingPearlsCh7/"/>
    <id>http://izhen.me/2014/11/18/ProgrammingPearlsCh7/</id>
    <published>2014-11-18T14:18:25.000Z</published>
    <updated>2016-08-14T01:53:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本书的粗略估计看起来肤浅实则非常重要，有些问题不是估着玩的，比如桥梁设计时。本书举出的估计内存的例子，结构体是有对齐的，这样简单的估计是会失准的。还有类似「舍9法」「72法则」「Little定律」这些小技巧，在「安全系数」这一节中，我想起了以前我的做法：比如写线段树的时候，因为写的是静态存储结构的，所以我用结点数乘以四来开辟数组空间，而不是用一个恰好精确的值。<br><a id="more"></a></p><h3 id="问题探讨"><a href="#问题探讨" class="headerlink" title="问题探讨"></a>问题探讨</h3><p>5.书中的提示相当巧妙：(1+x/100)^(72/x)得到(1+0.72/x)^x，然后根据lim(n-&gt;∞)(1+c/n)^n=e^c，2的自然对数约为0.693。</p><p>6.根据72法则，72/1.33 = 54.135，所以可以知道在2050年大约会翻倍。</p><p>10.利用Little定律，个体平均寿命r大约70到90年，然后当前城市的总人数n，因为 n = x * r。所以 x = n / r，然后 x / n = 1 / r就是死亡率。</p><h3 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h3><p>舍9法：加数的数字总和与和数的数字总和模9相等。</p><p>72法则：假设以年利率r%投资一笔钱y年，如果r * y = 72，那么你的投资差不多会翻倍。</p><p>Little定律：系统中物体的平均数量等于物体离开系统的平均速率和每个物体在系统中停留的平均时间的乘积。</p><p>任何事都应尽量简单，但不宜过于简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本书的粗略估计看起来肤浅实则非常重要，有些问题不是估着玩的，比如桥梁设计时。本书举出的估计内存的例子，结构体是有对齐的，这样简单的估计是会失准的。还有类似「舍9法」「72法则」「Little定律」这些小技巧，在「安全系数」这一节中，我想起了以前我的做法：比如写线段树的时候，因为写的是静态存储结构的，所以我用结点数乘以四来开辟数组空间，而不是用一个恰好精确的值。&lt;br&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="费米近似" scheme="http://izhen.me/tags/%E8%B4%B9%E7%B1%B3%E8%BF%91%E4%BC%BC/"/>
    
      <category term="Little定律" scheme="http://izhen.me/tags/Little%E5%AE%9A%E5%BE%8B/"/>
    
      <category term="72法则" scheme="http://izhen.me/tags/72%E6%B3%95%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>编程珠玑第六章探讨</title>
    <link href="http://izhen.me/2014/11/18/ProgrammingPearlsCh6/"/>
    <id>http://izhen.me/2014/11/18/ProgrammingPearlsCh6/</id>
    <published>2014-11-18T11:54:26.000Z</published>
    <updated>2016-08-14T01:53:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一章的内容刚好让我联想到以前参加过的<a href="./2014/04/20/2014-04-20-asc-2014-pre/">超算大赛</a>，优化是一个需要从理论层面直到硬件层面多个角度同时考虑的系统工程。作者也提到了设计层面的问题，有时候一个好的设计恰恰能避免很多问题，譬如说遇到一个问题，你看了一眼就开始写DFS，其实那个问题有规律可循，最终可以得到一条优雅的通项公式。<br><a id="more"></a></p><h3 id="问题探讨"><a href="#问题探讨" class="headerlink" title="问题探讨"></a>问题探讨</h3><p>4.这个题目就是说，比如程序的可靠性，一开始就要考虑进去，不然后期很难加上。这让我想到我曾经做过的一个项目，当时因为根本没有考虑到调试的问题，程序是用脚本语言写的，导致后期的维护任务异常艰巨。</p><p>6.这得看需求，在<a href="./2014/04/20/2014-04-20-asc-2014-pre/">超算大赛</a>时，我们优化的都是些科学或者大型工程软件，有精度上的要求，只要满足精度，怎么搞都可以。也就是说，如果精度允许，有几个小Bug无伤大雅。但是如果不能满足呢？再快又如何？古训还是得记得，不过我们也可以依情况行事。</p><h3 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h3><p>Gordon Bell:「计算机系统中最廉价、最快速且最可靠的元件是根本不存在的」</p><p>如果仅需要较小的加速。就对效果最佳的层面做改进。对于效率，大多数程序员都有自己的下意识反应：「改变算法」或「调整排队规则」会脱口而出。决定在某一特定层面着手之前，请先考虑一下所有可能的设计层面，然后选择「性价比」最高的哪一个：投入最小的精力就可以获得最大的加速系数的那个设计层面。</p><p>如果需要较大的加速，就对多个层面做改进。要取得Appel那样的大幅加速，必须从各个不同的方向对问题进行深入研究，这通常需要付出巨大的努力。如果在任一设计层面上的改进都独立于其他层面的改进，那么各个层面上的加速系数可以相乘。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一章的内容刚好让我联想到以前参加过的&lt;a href=&quot;./2014/04/20/2014-04-20-asc-2014-pre/&quot;&gt;超算大赛&lt;/a&gt;，优化是一个需要从理论层面直到硬件层面多个角度同时考虑的系统工程。作者也提到了设计层面的问题，有时候一个好的设计恰恰能避免很多问题，譬如说遇到一个问题，你看了一眼就开始写DFS，其实那个问题有规律可循，最终可以得到一条优雅的通项公式。&lt;br&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="性能优化" scheme="http://izhen.me/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="设计" scheme="http://izhen.me/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="超算大赛" scheme="http://izhen.me/tags/%E8%B6%85%E7%AE%97%E5%A4%A7%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>编程珠玑第五章探讨</title>
    <link href="http://izhen.me/2014/11/18/ProgrammingPearlsCh5/"/>
    <id>http://izhen.me/2014/11/18/ProgrammingPearlsCh5/</id>
    <published>2014-11-18T10:32:12.000Z</published>
    <updated>2016-08-14T01:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章着重谈论一些小事，测试、调试、计时。说是小事其实也是大事，想想自己曾经为调试一个程序而彻夜难眠的经历吧。这里面又有断言大法的叙述，「在测试时使用断言，而在产品发布时把断言关闭的程序员，就像是岸上操练时穿着救生衣，而下海时将救生衣脱下的水手」。在计时部分，作者展现了老练的洞察力，不过缓存溢出这种错误现在可能少见多了。<br><a id="more"></a></p><h3 id="问题探讨"><a href="#问题探讨" class="headerlink" title="问题探讨"></a>问题探讨</h3><p>1.为什么说编码风格重要，至少在实际工业环境中，好的编码风格能让人更清晰程序的表述，出了问题，也能快速发现问题所在，带来了很可观的好处。而且不同的语言的风格是很不同的，譬如Java与C++之间，Python与Lisp之间，这也暗含了由于语言本身特质所显现出的本质思想。至于什么算好的风格？写得多自然就知道什么是好的风格了。</p><p>3.突变测试，偶尔会用用这种方法。不过小程序还是打印大法好使。</p><p>5.如果说O(logN)的还可以说说的话，O(1)的就想不到了(确定不是在逗我？)，首先要明确是否要准确判断，还是一定概率下满足就可以。比如O(logN)可以尝试一个数字，取出来再用二分找位置，能放回去就说明很大概率有序(如果有相同数字还得另外考虑)。</p><p>7.参考访存局部性问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章着重谈论一些小事，测试、调试、计时。说是小事其实也是大事，想想自己曾经为调试一个程序而彻夜难眠的经历吧。这里面又有断言大法的叙述，「在测试时使用断言，而在产品发布时把断言关闭的程序员，就像是岸上操练时穿着救生衣，而下海时将救生衣脱下的水手」。在计时部分，作者展现了老练的洞察力，不过缓存溢出这种错误现在可能少见多了。&lt;br&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="测试" scheme="http://izhen.me/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="调试" scheme="http://izhen.me/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="打印大法" scheme="http://izhen.me/tags/%E6%89%93%E5%8D%B0%E5%A4%A7%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>编程珠玑第四章探讨</title>
    <link href="http://izhen.me/2014/11/13/ProgrammingPearlsCh4/"/>
    <id>http://izhen.me/2014/11/13/ProgrammingPearlsCh4/</id>
    <published>2014-11-13T11:56:04.000Z</published>
    <updated>2016-08-14T01:52:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，本章中再次提及了<a href="http://www.amazon.cn/The-Art-of-Computer-Programming-Volumes-1-4a-Knuth-Donald-E/dp/0321751043/ref=sr_1_5?ie=UTF8&amp;qid=1415971810&amp;sr=8-5&amp;keywords=taocp" target="_blank" rel="noopener">TAOCP</a>，可以说已经是一章提一次的节奏了，作者这么热衷于提到本书还是有一定道理的，详尽的数学证明让我们有值得一读的必要。第四章的主题是如何证明自己的程序是正确的，这是一个比较困难的问题，尤其是逻辑复杂的代码，对于不同的程序周期作者都针对性的提出了不同的方法和原理。比如二分搜索的停机证明，然后对于函数，作者介绍了重要的「契约编程」。其中还谈到了心理问题：「困难」的部分第一次就可以正确运行，而那些「容易」的部分往往会出毛病。所以呢，作者也鼓励使用验证技术开发。觉得本章最重要的应当就是对循环不变式的理解。<br><a id="more"></a></p><h3 id="问题探讨"><a href="#问题探讨" class="headerlink" title="问题探讨"></a>问题探讨</h3><p>2.因为返回的是第一个位置，所以思路是如果找到并且尚有未检查的区间，那么要再次深入迭代。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">left = <span class="number">-1</span>;</span><br><span class="line">right = n; <span class="comment">// 数组长度为n</span></span><br><span class="line"><span class="keyword">while</span>(left + <span class="number">1</span> != right)&#123;</span><br><span class="line">    mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(num[mid] &lt; target)</span><br><span class="line">        left = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        right = mid; <span class="comment">// ‘&lt;=‘ 只要 left + 1 != right 会一直迭代 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.只要可以验证计时程序运行是正确的，那么就可以证明运行时间确实是对数的。参考第五章。</p><p>6.每次都会减少一颗豆子，所以只要证明程序是正确运行的，则一定会终止。第二问的意思是每次减少的豆子因为不是两个白就是0个白，所以白色的豆子在初始时是偶数的，那么最后一定是个黑色的豆子；反之，是白色的。</p><p>7.线段已经有序，利用习题2的思路，我们可以先找到一条线段，判断其是上面、下面还是线段上。</p><p>9.(1)首先应当证明每一次的操作能够得到当前一步想要的结果，然后因为i是递增的，且每次都加1，所以从0开始直到最后计算结束，n个维度都得到了相加。且i每次都递增，所以一定会结束。</p><p>(2)一开始max是数组第一个数字，在循环中，数组中第i个数字会与max比较，如果比max大就更新，另一方面0到i-1也已经比较完了。i从1开始，每次比较后i都会增加1，所以循环会结束，数组中的数字也都会与max比较，从而得到正确的最大值。</p><p>(3)循环中每次i都会自增1，所以循环一定会终止。如果i超过了范围会终止，如果找到了也会终止。因为i是从0开始顺序递增的，所以如果找到了，那么一定是第一个，程序因此是正确的。</p><p>(4)每次如果满足条件递归下去，那么递归的定义域会一直缩小。要么减一，要么除以2，而且程序中给定了边界条件。每次递归的结果都是上一层需要的，所以程序可以结束且能得到正确答案。</p><h3 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h3><ul><li>初始化。循环初次执行的时候不变式为真。</li><li>保持。如果在某次迭代开始的时候以及循环体执行的时候，不变式都为真，那么，循环体执行完毕的时候不变时依然为真。</li><li>终止。循环能够终止，并且可以得到期望的结果(在本例中，期望的结果是p得到正确的值)。为说明这一点需要用到不变时所确立的事实。</li></ul><p>……</p><p>如果在前置条件满足的情况下调用函数，那么函数的执行将确立后置条件。一旦证明函数体具有该性质，在以后的应用中就可以直接使用前置条件和后置条件之间的关系而不再需要考虑其实现。该方法在软件开发中通常称为「契约编程」。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，本章中再次提及了&lt;a href=&quot;http://www.amazon.cn/The-Art-of-Computer-Programming-Volumes-1-4a-Knuth-Donald-E/dp/0321751043/ref=sr_1_5?ie=UTF8&amp;amp;qid=1415971810&amp;amp;sr=8-5&amp;amp;keywords=taocp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TAOCP&lt;/a&gt;，可以说已经是一章提一次的节奏了，作者这么热衷于提到本书还是有一定道理的，详尽的数学证明让我们有值得一读的必要。第四章的主题是如何证明自己的程序是正确的，这是一个比较困难的问题，尤其是逻辑复杂的代码，对于不同的程序周期作者都针对性的提出了不同的方法和原理。比如二分搜索的停机证明，然后对于函数，作者介绍了重要的「契约编程」。其中还谈到了心理问题：「困难」的部分第一次就可以正确运行，而那些「容易」的部分往往会出毛病。所以呢，作者也鼓励使用验证技术开发。觉得本章最重要的应当就是对循环不变式的理解。&lt;br&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="契约编程" scheme="http://izhen.me/tags/%E5%A5%91%E7%BA%A6%E7%BC%96%E7%A8%8B/"/>
    
      <category term="验证" scheme="http://izhen.me/tags/%E9%AA%8C%E8%AF%81/"/>
    
      <category term="断言" scheme="http://izhen.me/tags/%E6%96%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>编程珠玑第三章探讨</title>
    <link href="http://izhen.me/2014/11/11/ProgrammingPearlsCh3/"/>
    <id>http://izhen.me/2014/11/11/ProgrammingPearlsCh3/</id>
    <published>2014-11-11T14:53:38.000Z</published>
    <updated>2016-08-14T01:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章陈述了唯物辩证法的重要性，充分体现了经济基础(数据)决定上层建筑(程序结构)。而且也从侧面展示了语言的重要性，书中一位程序员因为语言的问题，不得不使用了350个变量而不是数组。有两个方法让我很在意：一个是打表大法，我们不必要用程序去产生所有数据，某些数据完全可以提前做好，能够节约大笔开发经费(代码量，时间)，这就是打表。第二个就是说我们不要重复造轮子，程序员应当善于使用已有的工具。作者给出了本章标题的真正含义：<br><a id="more"></a></p><blockquote><p>恰当的数据视图实际上决定了程序的结构</p></blockquote><h3 id="问题探讨"><a href="#问题探讨" class="headerlink" title="问题探讨"></a>问题探讨</h3><p>1.使用数组重构后，可以用二分查找优化。</p><p>7.这个题目其中一个任务要求实现单词的拼写检查。如果考虑到实现类似Google搜索引擎的那种难度还是相当大的，但是本题目给出了字典的提示，我们可以逆向利用习题2.1的变位词字典。只不过，这回我们要做的是把一个正确拼写的单词顺序打乱，一个简单的递归代码就可以实现，然后做出索引。显然这个笨重的方法不是现代工业界真正使用的，我们不多做讨论(会涉及机器学习，人工智能等领域)。这道题目余下的问题应该都是打表吧。</p><p>8.这道题目的编程思想可以用在很多方面，比如说骑士游历问题，提前把骑士可以走的步长写好。第3题也是类似的思路。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//骑士游历</span></span><br><span class="line"><span class="comment">//(1, 2) (-1, 2) (1, -2) (-1, -2)......</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str[] = &#123;<span class="string">"1011111"</span>, <span class="string">"0000101"</span>, <span class="string">"1110110"</span>, <span class="string">"1110101"</span>, <span class="string">"0101101"</span>,</span><br><span class="line"><span class="string">"1111001"</span>, <span class="string">"1111011"</span>, <span class="string">"0010101"</span>, <span class="string">"1111111"</span>, <span class="string">"1111101"</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h3><p>虽然本章中的故事横跨数十年并涉及多种编程语言，但是每个故事的精髓都是一致的：「能用小程序实现，就不要编写大程序」。许多结构都见证了Polya在《<a href="http://www.amazon.cn/How-to-Solve-it-A-New-Aspect-of-Mathematical-Method-Polya-George/dp/0140124993/ref=sr_1_2?ie=UTF8&amp;qid=1415721648&amp;sr=8-2&amp;keywords=How+to+Solve+It" target="_blank" rel="noopener">How to Solve It</a>》一书中提到的发明家悖论：「更一般性的问题也许更容易解决」。对于程序设计来说，这意味着直接编写解决23种情况的问题很困难；而编写一个处理n种情况的通用程序，再令n=23来得到最终结果，却相对要容易一些。</p><p>本章集中讨论了数据结构对软件的一个贡献：将大程序缩减为小程序。数据结构设计还有许多其他正面影响，包括节省时间和空间、提高可移植性和可维护性。……</p><p>程序员在节省空间方面无计可施时，将自己从代码中解脱出来，退回起点并集中心力研究数据，常常能有奇效。（数据的）表示形式是程序设计的根本。</p><p>退回起点思考时的几条原则：</p><ul><li><strong>使用数组重新编写重复代码。</strong></li><li><strong>封装复杂结构</strong></li><li><strong>尽可能使用高级工具</strong>。超文本、数据库、编程语言、键-值对、电子表格。</li><li><strong>从数据得出程序结构</strong>。本章主题就是：通过使用恰当的数据结构来替代复杂的代码，从数据可以得出程序的结构。万变不离其宗：在动手编写代码之前，优秀的程序员会彻底理解输入、输出和中间数据结构，并围绕这些结构创建程序。(有趣的是，第一次让我领悟到这件事的是一位OI神牛，一道提交答案的题目(NP-Complete)，他看了数据后发现了规律，用线性的算法针对数据编写了简单的程序。)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章陈述了唯物辩证法的重要性，充分体现了经济基础(数据)决定上层建筑(程序结构)。而且也从侧面展示了语言的重要性，书中一位程序员因为语言的问题，不得不使用了350个变量而不是数组。有两个方法让我很在意：一个是打表大法，我们不必要用程序去产生所有数据，某些数据完全可以提前做好，能够节约大笔开发经费(代码量，时间)，这就是打表。第二个就是说我们不要重复造轮子，程序员应当善于使用已有的工具。作者给出了本章标题的真正含义：&lt;br&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="数据结构" scheme="http://izhen.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="唯物主义" scheme="http://izhen.me/tags/%E5%94%AF%E7%89%A9%E4%B8%BB%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>编程珠玑第二章探讨</title>
    <link href="http://izhen.me/2014/11/09/ProgrammingPearlsCh2/"/>
    <id>http://izhen.me/2014/11/09/ProgrammingPearlsCh2/</id>
    <published>2014-11-09T15:48:26.000Z</published>
    <updated>2016-08-14T01:52:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一章给出了三个小问题，都非常有趣且实用，分别用来阐述<strong>二分法</strong>，<strong>递归与抽象</strong>，<strong>离散化思想</strong>。第一个问题可以认为是二分思想的巧妙运用，众所周知通常二分前数据应当是有序的，比如C++中的set或map容器的工作原理，都是维护一棵平衡树；大量常见的数据结构如：平衡二叉树、线段树、二叉堆、堆排序都合理发挥了二分法的威力。第二个问题紧扣主题，有哪些基本操作可以用来解决问题，「看起来很困难的问题也可以有一个简单的、意想不到的答案」。我觉得第二题给出的三个解决方案都很重要，第一个算法是看透了<strong>暴力</strong>算法的本质，最大限度减少了使用额外空间辅助移动带来的浪费；第二个算法的递归思想很通用也很重要；第三个最为精妙的算法向我们展示了抽象思维的可贵。第三题是一道不错的离散化题目，书中说排序也好，打标识也好都是离散化的体现。所以作者也说：<br><a id="more"></a></p><blockquote><p>算法与其他那些深奥的思想一样重要，但在更一般的编程层面上具有更重要的影响。</p></blockquote><h3 id="问题探讨"><a href="#问题探讨" class="headerlink" title="问题探讨"></a>问题探讨</h3><p>A.说一下我的理解，首先32位整数要多于40亿，所以一定存在至少一个整数不在这个随机的表中。我们按照32位整数的位来考虑，每一位不是0就是1，所以我们先按照第一个位01区分为两个集合，这样的话一定有一半最多包含2^31个整数，肯定有至少一个部分不到2^31，我们选择更少的那一半继续用这个方法取下一位，01二分下去，一定能找到至少一个缺失数字，当数据范围缩小到足以适应几百字节的内存时，遍历这个小范围就知道缺哪个数字了(也可以继续二分到底)，所以总的复杂度正比于N。在算法竞赛中还遇到过直接二分答案的题目，就是说直接二分可能的答案然后判断是否满足题目条件。</p><p>B.第一个杂技算法的实现中有一个规律可循，假设我们把这个字符串收尾相接，那么从第一个字母开始，我们每隔i个字母输出一个，直到返回到已经输出过的字母。假设返回到已经输出过的字母后，仍有剩余字母没有输出，我们就顺序找下一个继续跳，问总共几个这样的循环可以遍历完所有呢？</p><p>例如：abcde n = 5 i = 3 和 abcdef n = 6 i = 2</p><ol><li>第一个：<strong>a</strong>bc<strong>d</strong>ea<strong>b</strong>cd<strong>e</strong>ab<strong>c</strong>de<strong>a</strong>bcde，一趟访问了所有字母，也就是所有字母完成了旋转。</li><li>第二个：<strong>a</strong>b<strong>c</strong>d<strong>e</strong>f<strong>a</strong>bcdef，这一趟再次访问到a的时候还有一半没有访问到。我们继续：a<strong>b</strong>c<strong>d</strong>e<strong>f</strong>a<strong>b</strong>cdef，这样共用了两趟。</li></ol><p>这个趟数恰好等于GCD(n, i)，书中解释：所需置换群次数，「近世代数中表示旋转产生的置换群的陪集个数」。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> (a % b ? gcd(b, a % b) : b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acrobat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rot = <span class="number">2000</span>, temp, j, k, len = str.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gcd(rot, len); i++)&#123;</span><br><span class="line">        temp = str[i];</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            k = j + rot;</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= len)</span><br><span class="line">                k -= len; <span class="comment">//equal to k %= len</span></span><br><span class="line">            <span class="keyword">if</span>(k == i) <span class="comment">//find the same alpha</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            str[j] = str[k];</span><br><span class="line">            j = k;</span><br><span class="line">        &#125;</span><br><span class="line">        str[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种算法的递归思路挺好理解，第一个函数实现了递归的思路，需要给出头指针，两个串的长度；第二个迭代的方法更加巧妙，书中也指出，这个方法与求最大公约数的交叉相减法同构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123; <span class="comment">//分别从i,j位置开始，翻转k个字符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; k; p++)&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = str[p + i];</span><br><span class="line">        str[p + i] = str[p + j];</span><br><span class="line">        str[p + j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> leni, <span class="keyword">int</span> lenj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(leni == lenj)&#123;</span><br><span class="line">        swap(i, i + leni, leni);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(leni &gt; lenj)&#123;</span><br><span class="line">        swap(i, i + leni, lenj);</span><br><span class="line">        first(i + lenj, leni - lenj, lenj);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        swap(i, i + lenj, leni);</span><br><span class="line">        first(i, leni, lenj - leni);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, p;</span><br><span class="line">    i = p = rot;</span><br><span class="line">    j = str.size() - i;</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j)&#123;</span><br><span class="line">            swap(p - i, p, j);</span><br><span class="line">            i -= j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            swap(p - i, p + j - i, i);</span><br><span class="line">            j -= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(p - i, p, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>巧妙的数学模型可以帮助我们事半功倍，第三个「翻手」算法就是这样的例子，(a^r*b^r)^r = ba：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> ii,<span class="keyword">int</span> jj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ii; i &lt;= jj - (jj - ii + <span class="number">1</span>) / <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = str[i];</span><br><span class="line">        str[i] = str[jj - (i - ii)];</span><br><span class="line">        str[jj - (i - ii)] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    reverse(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    reverse(i, str.size() - <span class="number">1</span>);</span><br><span class="line">    reverse(<span class="number">0</span>, str.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.实践出真知，经过试验，在<strong>i=2000</strong>的情况下(Core i7 2.8GHz L3 4MB， 8GB 1600MHz)，使用了io流，可能占比较大。书中的图表反映了访存局部性问题，不过现代的机器性能比书中给定的Pentium II好很多，在如下规模的数据中不太显著。</p><table><thead><tr><th>算法名称</th><th>n = 100000</th><th>n = 1000000</th><th>n = 10000000</th></tr></thead><tbody><tr><td>杂技</td><td>0.034s</td><td>0.280s</td><td>2.799s</td></tr><tr><td>递归</td><td>0.038s</td><td>0.298s</td><td>2.950s</td></tr><tr><td>迭代</td><td>0.035s</td><td>0.297s</td><td>2.845s</td></tr><tr><td>求逆</td><td>0.035s</td><td>0.310s</td><td>2.862s</td></tr></tbody></table><p>C.离散化思想有时可以将很多问题化繁为简，正因为排序可以起到很多很好的作用，很多算法问题都反映了有序化带来的一些优良特性。这道题目还引出了打标识的想法，更高级的想法就是散列表。排序也给了问题7一些启发。</p><p>7.我不清楚磁带上的存储到底是怎样的，系统给出的排序程序应当比较高效了。这个想法很好，先提前给这个4000*4000的矩阵提前写好转置后的行号和列号，然后调用系统排序先按列排序，再按照行排序，最后删了这些行列号。(这个应该是考虑到了磁带上数据读取的特性，如果内存中转置就不用这么折腾了。)</p><p>8.这个题目就是说最小k个数加起来什么时候超过t，也就是我们要在一个无序的实数集合中快速定位第k小的数字。如何做呢？可以先排序，这样我们就得到一个正比于O(NlogN)的算法。不过我们灵活运用快排的分治策略就可以得到正比于N的线性时间算法，往后再说这个。</p><h3 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h3><p>问题定义。第1章指出确定用户的真实需求是程序设计的根本。本章的中心思想是问题定义的下一步：使用哪些基本操作来解决问题？在本章的每个例子中，啊哈！灵机一动都定义了一个新的基本操作使得问题得到简化。</p><p>问题解决者的观点。优秀程序员都有点懒：他们坐下来并等待灵机一动的出现而不急于使用最开始的想法编程。当然，这必须通过在适当的时候开始写代码来加以平衡。真正的技能就在于对这个适当时候的把握，这只能来源于解决问题和反思答案所获得的经验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一章给出了三个小问题，都非常有趣且实用，分别用来阐述&lt;strong&gt;二分法&lt;/strong&gt;，&lt;strong&gt;递归与抽象&lt;/strong&gt;，&lt;strong&gt;离散化思想&lt;/strong&gt;。第一个问题可以认为是二分思想的巧妙运用，众所周知通常二分前数据应当是有序的，比如C++中的set或map容器的工作原理，都是维护一棵平衡树；大量常见的数据结构如：平衡二叉树、线段树、二叉堆、堆排序都合理发挥了二分法的威力。第二个问题紧扣主题，有哪些基本操作可以用来解决问题，「看起来很困难的问题也可以有一个简单的、意想不到的答案」。我觉得第二题给出的三个解决方案都很重要，第一个算法是看透了&lt;strong&gt;暴力&lt;/strong&gt;算法的本质，最大限度减少了使用额外空间辅助移动带来的浪费；第二个算法的递归思想很通用也很重要；第三个最为精妙的算法向我们展示了抽象思维的可贵。第三题是一道不错的离散化题目，书中说排序也好，打标识也好都是离散化的体现。所以作者也说：&lt;br&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="二分" scheme="http://izhen.me/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="抽象思维" scheme="http://izhen.me/tags/%E6%8A%BD%E8%B1%A1%E6%80%9D%E7%BB%B4/"/>
    
      <category term="离散化" scheme="http://izhen.me/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
      <category term="数学思想" scheme="http://izhen.me/tags/%E6%95%B0%E5%AD%A6%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>编程珠玑第一章探讨</title>
    <link href="http://izhen.me/2014/11/08/ProgrammingPearlsCh1/"/>
    <id>http://izhen.me/2014/11/08/ProgrammingPearlsCh1/</id>
    <published>2014-11-08T06:56:06.000Z</published>
    <updated>2016-08-14T01:52:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一章陈述了一个算是在特定领域很好用的方法，中学时上编程课老师给出了这种方法，题目是一串不会重复的数字，最大的数字不会超过某个值，要求排序输出。其实根本不需要真去做排序，当时用Pascal语言的boolean数组很容易就解决了这个问题。也就是跟本章提到的位向量异曲同工。显然如果除了算法与数据结构外其他条件都一样的情况下，线性的算法要明显优于O(NlogN)的基于比较的排序算法。作者给出了问题本质和使用范围：<br><a id="more"></a></p><blockquote><p>该数据结构描述了一个有限定义域内的稠密集合</p></blockquote><h3 id="问题探讨"><a href="#问题探讨" class="headerlink" title="问题探讨"></a>问题探讨</h3><p>2.这道题目让我学会了int类型的位向量实现思路是什么，老实说我以前从没考虑过用位运算，要是我的话，估计直接上bool数组了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于编程珠玑原始程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MASK 0x1F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000000</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1</span> + (N &gt;&gt; SHIFT)]; <span class="comment">// equal to (N/32)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;        a[i &gt;&gt; SHIFT] |=  (<span class="number">1</span> &lt;&lt; (i &amp; MASK)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clr</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;        a[i &gt;&gt; SHIFT] &amp;= ~(<span class="number">1</span> &lt;&lt; (i &amp; MASK)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> a[i &gt;&gt; SHIFT] &amp;   (<span class="number">1</span> &lt;&lt; (i &amp; MASK)); &#125;</span><br></pre></td></tr></table></figure><p>4.这题我很喜欢，生成随机数据不必要<strong>真的</strong>生成，对于本题目，正确的做法是<strong>打乱</strong>本来有序的数据。</p><p>9.我从来没有想过类似的问题，解决方案是<strong>多道保险</strong>。一个top代表已经初始化了几个数字，从0开始。from数组代表当前被访问的i位置上是第top个被初始化的；to数组代表第top个被初始化的是i位置上的。这样的话必须满足</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from[i] &lt; top &amp;&amp; to[from[i]] == i</span><br></pre></td></tr></table></figure><p>才能说明被初始化了，而内存中的随机值要达到上面的条件几乎不可能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from[i] = top</span><br><span class="line">to[top] = i</span><br><span class="line">data[i] = <span class="number">0</span></span><br><span class="line">top = top + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这个技术在哪里有实用的意义呢？(资源寸土寸金的航天飞机上？)</p><p>12.这道题目让我想起了《3 idiots》这个电影，事实上早期真的是用铅笔解决问题的，但是确实危险，在失重环境下，铅笔的粉尘漂浮于精密的飞船中是一个不可想象的可怕情况。不过，本书作者在深入阅读中也提到了这个问题目的是要求我们打破概念壁垒。这是好的，打破思维的壁垒能让我们更容易看破一些问题，也就是典型的Hack思维方法。不过，<strong>Hack the problem</strong>不等同于<strong>Solve the problem</strong>。归根结底，宇航员还是要用几百万美元研发成本的太空笔，因为那是真正的解决了问题，「铅笔」这种想法只是绕过了问题，有这种意识挺好，说不定什么时候能帮上大忙。但是小聪明归小聪明，我们终究还是要踏踏实实的去解决问题的。</p><h3 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h3><p>Chuck Yeager将军(第一个超音速飞行的人)赞扬一架飞机的机械系统时用的词是「结构简单、部件很少、易于维护、非常坚固」。</p><p>Antonine de Saint-Exupéry是法国作家兼飞机设计师，他曾经说过：「设计者确定其设计已经达到了完美的标准不是不能再增加任何东西，而是不能再减少任何东西。」</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一章陈述了一个算是在特定领域很好用的方法，中学时上编程课老师给出了这种方法，题目是一串不会重复的数字，最大的数字不会超过某个值，要求排序输出。其实根本不需要真去做排序，当时用Pascal语言的boolean数组很容易就解决了这个问题。也就是跟本章提到的位向量异曲同工。显然如果除了算法与数据结构外其他条件都一样的情况下，线性的算法要明显优于O(NlogN)的基于比较的排序算法。作者给出了问题本质和使用范围：&lt;br&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="位向量" scheme="http://izhen.me/tags/%E4%BD%8D%E5%90%91%E9%87%8F/"/>
    
      <category term="位运算" scheme="http://izhen.me/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="思维壁垒" scheme="http://izhen.me/tags/%E6%80%9D%E7%BB%B4%E5%A3%81%E5%9E%92/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://izhen.me/2014/06/30/hello-world/"/>
    <id>http://izhen.me/2014/06/30/hello-world/</id>
    <published>2014-06-30T06:22:09.000Z</published>
    <updated>2016-08-14T01:51:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>我从 <a href="http://octopress.org" target="_blank" rel="noopener">Octopress</a> 迁移到了 <a href="http://hexo.io" target="_blank" rel="noopener">Hexo</a>。从8升级到了16 :)</p><p>单论博客来说，<a href="http://octopress.org" target="_blank" rel="noopener">Octo</a> 其实是够用的，但是因为长期没有更新，而且不能使用新版本的 <a href="https://www.ruby-lang.org/" target="_blank" rel="noopener">Ruby</a> 这让我不得不多版本共存。另一个原因就是 <a href="http://hexo.io" target="_blank" rel="noopener">Hexo</a> 本身持续发展中，是一位 <a href="http://zespia.tw/" target="_blank" rel="noopener">台湾老兄</a> 做的。如果 <a href="http://izhen.me/2013/11/07/basic-octopress-build/">部署过Octo</a>，那么 <a href="http://hexo.io" target="_blank" rel="noopener">Hexo</a> 也差不多。<br><a id="more"></a><br>我在原本的基础上进行迁移，很快就好了，按照官方的文档一步一步做就好，相对来说自己需要亲自动手的地方很少，自动化程度很高。需要注意几个问题：</p><ol><li>A记录和CNAME设置，要查看相应ip</li><li>网站图标和子页面链接的设定都是分离于整个Blog的，也就是有多个.yml文件</li><li>tags和categories的区别</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --no-optional <span class="comment">#安装指令</span></span><br></pre></td></tr></table></figure><p>部署好后，最基本的Blog功能就有了。一个问题就是:我原先的文章评论不能回归原位了。XD</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我从 &lt;a href=&quot;http://octopress.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Octopress&lt;/a&gt; 迁移到了 &lt;a href=&quot;http://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;。从8升级到了16 :)&lt;/p&gt;
&lt;p&gt;单论博客来说，&lt;a href=&quot;http://octopress.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Octo&lt;/a&gt; 其实是够用的，但是因为长期没有更新，而且不能使用新版本的 &lt;a href=&quot;https://www.ruby-lang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ruby&lt;/a&gt; 这让我不得不多版本共存。另一个原因就是 &lt;a href=&quot;http://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; 本身持续发展中，是一位 &lt;a href=&quot;http://zespia.tw/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;台湾老兄&lt;/a&gt; 做的。如果 &lt;a href=&quot;http://izhen.me/2013/11/07/basic-octopress-build/&quot;&gt;部署过Octo&lt;/a&gt;，那么 &lt;a href=&quot;http://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; 也差不多。&lt;br&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="Markdown" scheme="http://izhen.me/tags/Markdown/"/>
    
      <category term="Hexo" scheme="http://izhen.me/tags/Hexo/"/>
    
      <category term="Github" scheme="http://izhen.me/tags/Github/"/>
    
      <category term="Node.js" scheme="http://izhen.me/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>2014 ACM-ICPC China GDCPC</title>
    <link href="http://izhen.me/2014/05/12/2014-05-12-gdcpc2014/"/>
    <id>http://izhen.me/2014/05/12/2014-05-12-gdcpc2014/</id>
    <published>2014-05-11T16:18:57.000Z</published>
    <updated>2016-08-14T01:50:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="大赛的情况"><a href="#大赛的情况" class="headerlink" title="大赛的情况"></a>大赛的情况</h3><p>今年的比赛是本个竞赛史上最惨烈的一次了。没有队伍的过题数超过一半，但是其实总体比赛的难度不是特别大。好多DP，搜索也好，数学题也好，模型都是裸的。<br><a id="more"></a></p><h3 id="我们的情况"><a href="#我们的情况" class="headerlink" title="我们的情况"></a>我们的情况</h3><p>怎么说呢，因为不训练的缘故，<del>其实是找个借口啦</del>，我们水水的获得了一块Bronze，<del>这里英文显得格调更高</del>。话说我们队伍的组成是：Linpack世界第一人，未来的电影大导演，还有我(就不说什么了)。我和我的队友酱油的都很好，嗯。</p><h3 id="题目的概况"><a href="#题目的概况" class="headerlink" title="题目的概况"></a>题目的概况</h3><ul><li>三道水题A,J,K;分别是白送，数学公式，trie/AC自动机/Hash+DP</li><li>除三道水题外最简单的是E，DP</li><li>然后一道线段树B</li><li>一道LCA是D</li><li>一道高精度数学题C</li><li>一道简单的BFS是F</li><li>忘了G是什么了…</li><li>H是计算几何</li><li>最后I是一道DP</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>说是酱油，其实就是玩乐了一把，希望教练不要生气XD。以后还要开开心心的过日子，嗯，就这样 :)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;大赛的情况&quot;&gt;&lt;a href=&quot;#大赛的情况&quot; class=&quot;headerlink&quot; title=&quot;大赛的情况&quot;&gt;&lt;/a&gt;大赛的情况&lt;/h3&gt;&lt;p&gt;今年的比赛是本个竞赛史上最惨烈的一次了。没有队伍的过题数超过一半，但是其实总体比赛的难度不是特别大。好多DP，搜索也好，数学题也好，模型都是裸的。&lt;br&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="ACM-ICPC" scheme="http://izhen.me/tags/ACM-ICPC/"/>
    
      <category term="算法" scheme="http://izhen.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="省赛" scheme="http://izhen.me/tags/%E7%9C%81%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>ASC2014世界大学生超级计算机竞赛</title>
    <link href="http://izhen.me/2014/04/20/2014-04-20-asc-2014-pre/"/>
    <id>http://izhen.me/2014/04/20/2014-04-20-asc-2014-pre/</id>
    <published>2014-04-19T16:06:04.000Z</published>
    <updated>2016-08-14T01:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这个竞赛目前还是一个相对小众的竞赛。而且，因为其独特的竞赛准备条件——首先你得有一套高性能计算集群——我认为这个比赛短时间内不会发展成学科竞赛那样的大型竞赛项目，尤其是有着大学生的奥运会之称的ACM-ICPC这种比赛。</p><p>但是个人觉得，大学生超算大赛比较类似于F1。每个队伍都有一套自己的集群，但是集群总功耗不能超过3000W(方程式)，可以携带加速卡(Tesla/MIC)，这样一来与F1颇有几分相似。每支队伍都有自己的赛车(小型集群)，比赛不是一场定胜负，而是有很多场，每一个单独项目都有单设的冠军；这就好比F1的分站冠军，最终还有一个总冠军。<br><a id="more"></a><br>参加这个比赛是有一定门槛的。有两个方面：首先，不是有一个个人计算机就能搞定这一切的（如果从没接触过超算，或者加速卡的话）。更重要的是，超算应用所需要的专业知识都比较深奥。一般来说，这些应用侧重于高性能并发。涉及的方面很多，诸如：科学计算；流体力学；大气、海洋模式；其他的大规模模拟；等等。</p><p>超级计算机普遍来说都是具备通用计算能力的，但是也不一定每部都要设计成用来通用计算的。有的超算就是为了解决特定问题而专门定制的。这次比赛有一个项目会在我国的<a href="http://zh.wikipedia.org/wiki/%E5%A4%A9%E6%B2%B3%E4%BA%8C%E5%8F%B7" target="_blank" rel="noopener">天河2号</a>超级计算机上进行评测，这部机子就是一个通用机。</p><h3 id="比赛内容"><a href="#比赛内容" class="headerlink" title="比赛内容"></a>比赛内容</h3><p>本次比赛的题目如下所示：</p><ul><li><a href="http://www.quantum-espresso.org/" target="_blank" rel="noopener">Quantum Espresso</a>，量子分子动力学</li><li><a href="http://su2.stanford.edu/" target="_blank" rel="noopener">Stanford University Unstructured</a>， 流体力学</li><li><a href="#">3D-EW</a>， 三维纵横波分离的弹性波方程模拟方法(天河2号测试)</li><li><a href="http://www.lasg.ac.cn/FGOALS/ArticleShow.asp?BigClass=%C4%A3%D0%CD%CE%C4%B5%B5&amp;ArticleID=4220" target="_blank" rel="noopener">LICOM</a>，LASG气候海洋模式</li><li><a href="http://www.netlib.org/benchmark/hpl/" target="_blank" rel="noopener">HPL</a>，高性能浮点能力测试(每年必考)</li><li><a href="#">神秘应用</a></li></ul><p>目标只有一个：在保证正确性的情况下，让应用的加速比达到最高。可以使用的手段如下：</p><ul><li>优化算法，修改代码</li><li>硬件加速，使用加速卡，更多的计算节点</li><li>参数调试，MPI参数/编译参数等</li></ul><h3 id="专业技能与人员配比"><a href="#专业技能与人员配比" class="headerlink" title="专业技能与人员配比"></a>专业技能与人员配比</h3><p>很综合，首先上述应用若要能够看懂算法，最好有相关专业领域的队员。比如如果有一个环境/地理学院的同学，那么LICOM或者3D-EW就比较好办。如果有量子化学领域相关专业的人，那么对于QE也是如此。这些算法包括数值方法与ACM中的算法不太一样，它们大都侧重于连续数学(这样说不是很严格，领会精神)。</p><p>一个比较合理的队员配比应当是交叉学科。</p><p>有各种数学、自然科学与工程学院的同学负责理解优化应用算法，同时还要有计算机相关专业的同学负责系统方面的工作。你要知道基础的系统要是搭建的比较失败的话，就算前期应用做得再好，到比赛时跑不动就是0分了；同理，系统做得再好，对于应用的算法一窍不通，优化时无从下手也没得玩了。而且交叉学科可以专业优势互补。比如程序或者系统方面，计算机相关专业能够帮上忙，应用算法方面则有数学、自然科学与工程学院的同学能够帮上忙。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实大学生超级计算机大赛是做系统调试与应用调优的。并不是从很基础的层面去设计一套超级计算机。不过随着大赛的发展，也希望以后能够深化，让参赛队真的如同F1车队一样去设计自己独有的计算机。这样或许会更加有趣。</p><p>我们队伍最终的成绩是:总排名第六，Linpack测试破世界纪录。算是比较中规中矩的成绩了，但是通过比赛认识了海内外很多高校的优秀选手，也结交了很多朋友，所以总的来说还是挺好的，而且也刷新了我的三观，打开了眼界，更重要的是明确了自己未来的方向。期待这个比赛能够持续发展下去，让更多充满热情的大学生能够接触到这个领域，拓展自己的人生经历。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;这个竞赛目前还是一个相对小众的竞赛。而且，因为其独特的竞赛准备条件——首先你得有一套高性能计算集群——我认为这个比赛短时间内不会发展成学科竞赛那样的大型竞赛项目，尤其是有着大学生的奥运会之称的ACM-ICPC这种比赛。&lt;/p&gt;
&lt;p&gt;但是个人觉得，大学生超算大赛比较类似于F1。每个队伍都有一套自己的集群，但是集群总功耗不能超过3000W(方程式)，可以携带加速卡(Tesla/MIC)，这样一来与F1颇有几分相似。每支队伍都有自己的赛车(小型集群)，比赛不是一场定胜负，而是有很多场，每一个单独项目都有单设的冠军；这就好比F1的分站冠军，最终还有一个总冠军。&lt;br&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="asc" scheme="http://izhen.me/tags/asc/"/>
    
      <category term="parallel" scheme="http://izhen.me/tags/parallel/"/>
    
      <category term="speedup" scheme="http://izhen.me/tags/speedup/"/>
    
      <category term="contest" scheme="http://izhen.me/tags/contest/"/>
    
  </entry>
  
  <entry>
    <title>写在ASC2014决赛之前</title>
    <link href="http://izhen.me/2014/04/12/ASC14/"/>
    <id>http://izhen.me/2014/04/12/ASC14/</id>
    <published>2014-04-12T14:53:47.000Z</published>
    <updated>2018-09-20T12:20:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是4月12日。</p><p>我从2月16号来到学校，2月17号面试，然后一直要搞到4月27号。足足两个月的时间，这段时间收获的东西不少，需要批判的地方也不少。不敢说自己真的做了多少优化，至少装配计算集群环境以及安装应用和调试参数这些流程都略知一二了。没有学习太多的并行程序做法。我也认清了自己的学习模式，我不喜欢捡碎片的学习法，我比较适合体系式的学习，把一切都串在一起，有好处也有坏处。总之，先上图再说吧：</p><a id="more"></a><p>一个计算节点中的内存阵列：</p><p><img src="/image/asc/Node-ram.jpg" alt="内存"></p><p>节点的布局：</p><p><img src="/image/asc/Node.jpg" alt="A node"></p><p>Tesla-K40m:</p><p><img src="/image/asc/Tesla-K40m-1.jpg" alt="Tesla K40m"></p><p>Xeon-phi:</p><p><img src="/image/asc/Xeon-phi.jpg" alt="Xeon Phi"></p><p>然后我就很长一段时间忙乎SU^2:</p><p>可以说很长一段时间都在调节参数，甚至至今我都不明白SU^2在搞什么飞机(事实上他就是搞飞机的XD)。比如下面这个飞机的机翼空气动力模拟。至于他具体是怎么回事我没刻意去弄明白，也没这个必要。</p><p><img src="/image/asc/Screenshot3.png" alt="Xeon Phi"></p><p>附上网格边界的效果：</p><p><img src="/image/asc/Screenshot3-2.png" alt="Xeon Phi"></p><p>一个剖面的模拟：</p><p><img src="/image/asc/Screenshot1-2.png" alt="Xeon Phi"></p><p>2D平面的模拟：</p><p><img src="/image/asc/Screenshot-2.png" alt="Xeon Phi"></p><p>最近ASC这边终于压力开始陡增了，我稍微有点受不了了。预赛时的论文写的我很痛苦，非常的痛苦。所以本来以为如果进了决赛不会很乏味的。现在看来是我想多了。各方面的压力都很大，尤其今年是东道主，所以副校长给了我们一定的指示，至少不能让如此大笔的投资换回来一个很惨淡的结果就是了。</p><p>当然如果我自己能够看淡结果，置身于细枝末节之外就很好了。希望通过这个比赛得到一定的历练。我曾经有想过打ASC究竟让我得到了什么？难道就是那一点点很业余的算法？亦或是微不足道的一点小成就？有比这更重要的东西，我获得的是很重要的灵魂，很宝贵的思想。</p><p>同时，我收获的更多的应当是一种超脱。对比ACM和ASC，如果说ACM获得的是硬功夫，那么ASC更多的是一种软实力。超算是一个坑很大，而且不容易量化的东西，至少比ACM难量化。所谓ASC的坑，指的就是你不得不花很大的精力放在一些必要的细枝末节上去，这些细枝末节直接影响着你的最终优化成果。打ACM/OI所锻炼出来的那些东西完全可以应用在ASC上。而且ASC上也能获得更多其他的宝贵的东西。</p><p>在知识方面，比如硬件，作为一个学生你很少有机会能够碰到集群，GPU/MIC加速卡。甚至是真正的超级计算机，比如这届比赛我们会用到天河二号。同时也能让你更深入的了解并发计算，OpenMP/MPI/OpenACC等等。而且你还非常有必要深入学习Linux的基本操作。</p><p>跟ACM不同的是，ACM比较类似“养兵千日，用兵一时”。ASC的整个过程都是在竞赛，虽然两者对于最终结果的看重程度是一致的。不过ASC在比赛的准备过程中更加枯燥。ACM是有标准答案的，ASC没有，而且优化是无止境的。这就造成了如果没有经验很容易无头苍蝇乱撞。走错了方向不但白白努力不说，还完全没有成果。</p><p>这对于选手的考验更大。毕竟这就像搞科研一样，要耐得住寂寞。有意思的事情是：当你真的把一切都准备好的时候，一切都顺利跑起来以后，那才是有意思。然而现在来看，革命尚未成功，同志仍需努力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是4月12日。&lt;/p&gt;
&lt;p&gt;我从2月16号来到学校，2月17号面试，然后一直要搞到4月27号。足足两个月的时间，这段时间收获的东西不少，需要批判的地方也不少。不敢说自己真的做了多少优化，至少装配计算集群环境以及安装应用和调试参数这些流程都略知一二了。没有学习太多的并行程序做法。我也认清了自己的学习模式，我不喜欢捡碎片的学习法，我比较适合体系式的学习，把一切都串在一起，有好处也有坏处。总之，先上图再说吧：&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="ASC 2014" scheme="http://izhen.me/tags/ASC-2014/"/>
    
      <category term="Supercomputer" scheme="http://izhen.me/tags/Supercomputer/"/>
    
  </entry>
  
  <entry>
    <title>鬼谷子的数学难题</title>
    <link href="http://izhen.me/2014/03/10/2014-03-10-guiguzi-hard-problem/"/>
    <id>http://izhen.me/2014/03/10/2014-03-10-guiguzi-hard-problem/</id>
    <published>2014-03-10T06:39:46.000Z</published>
    <updated>2016-08-14T01:50:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>一天，鬼谷子随意从2~99中选取了两个数。他把这两个数的和告诉了庞涓， 把这两个数的乘积告诉了孙膑。孙膑和庞涓彼此不知到对方得到的数。第二天， 庞涓很有自信的对孙膑说：虽然我不知到这两个数是什么，但我知道你一定也不知道。随后，孙膑说： 那我知道了。庞涓说：那我也知道了。<br><a id="more"></a></p><h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><p>看了题目，思索一下，这是一个猜数字的游戏。那么该和从入手呢。假设这两个数字是a,b.那么令M=a+b;N=a•b;所以庞涓拿到了M，孙膑拿到了N.如此我们对他们的对话稍加研究。</p><ol><li>首先庞涓说：<strong>虽然我不知到这两个数是什么，但我知道你一    也不知道。</strong><ul><li>立即得到<strong>推论1</strong>:a和b不能同时为素。解释：同时为素说明N只能拆成两个素数的因子，素数本身不包含其他大于等于2的因子，所以有N必知这两个素数是什么。推论1得到。也就是说，<strong>庞涓手中的数字能够判断这两个数并不都是素数。</strong></li><li>对于推论1稍加思索，可得<strong>推论2</strong>：a和b若为一素一合，那么素数最大不得超过47。解释：比47再大的素数就是53，若另一个数有大于1的因子可拆出，最小是2，2•53&gt;99。所以推论2得到。</li><li>通过推轮1和推论2我们得知在5到197中可行的M有：11 17 23 27 29 35 37 41 47 51 194 197(通过程序计算得出)</li></ul></li><li>稍加观察，立即排除197,因为M=197,a,b只可能是98,99，这样的话庞涓和孙膑就都知道结果了。另外我们发现11到51基本连续，但是到达194产生了跳跃，所以对于194拆分。194=98+96，194=96+95；结合以上推论，立即排除194。</li><li>这时只剩下：11 17 23 27 29 35 37 41 47 51<ul><li>于是我们考虑他们的第二句对话：孙膑：<strong>那我知道了。</strong>而对于仅剩的数字我们再做分析：</li></ul><ul><li>11=2+9=3+8=4+7=5+6;</li><li>17=2+15=3+14=4+13=5+12=6+11=7+10=8+9；</li><li>23=2+21=3+20=4+19=5+18=6+17=7+16=8+15=9+14=10+13=11+12；</li><li>先观察这3组，我们看到5•6=2•15=30;5•12=3•20=60;如此，那么这样的话如果孙膑拿到了30，11，17均有可能，60的话17，23均有可能，所以要删掉相同的积，得到<strong>推论3</strong>：不得有相同的积存在。这时有下面这样有趣的结果：<ul><li>11: 2+9 3+8 4+7</li><li>17: 4+13</li><li>23: 4+19 7+16 10+13</li><li>27: 2+25 4+23 5+22 7+20 8+19 9+18 10+17 11+16</li><li>29: 2+27 4+25 6+23 7+22 8+21 10+19 11+18 12+17 13+16</li><li>35: 3+32 4+31 5+30 6+29 7+28 8+27 9+26 10+25 12+23 14+21 16+19</li><li>37: 5+32 6+31 8+29 9+28 14+23 16+21 17+20</li><li>41: 3+38 4+37 7+34 9+32 10+31 12+29 13+28 15+26 16+25 17+24 18+23 19+22</li><li>47: 4+43 6+41 7+40 10+37 11+36 13+34 14+33 15+32 16+31 17+30 18+29 19+28 21+26 22+25</li><li>51: 2+49 3+48 4+47 5+46 7+44 8+43 10+41 11+40 12+39 13+38 14+37 16+35 17+34 18+33 19+32 20+31 21+30 22+29 23+28 24+27</li></ul></li></ul></li><li>好了，敏锐的你应该发现了什么。根据庞涓和孙膑的最后一句对话，庞涓：<strong>那我也知道了。</strong></li></ol><p>庞涓知道什么了？如果庞涓拿到的是除了17以外的数字，例如11，那他有3个可能。孙膑对于18，24，28这三个任意的N，都能推出11是可行的和，也即都能知道是哪两个数字。要是这样庞涓做不出决定到底是哪个。问题是庞涓做出了决定，所以M一定17。而且此刻要Hack一下，因为我们已经找到了结果，所以不用考虑两个数字都是合数的情况了。XD</p><ul><li>M = 17; N = 52;</li><li>a + b = 17; a • b =52</li><li>a = 4; b = 13; (反之亦然)</li></ul><p>本题目计算量稍大，我借助了程序辅助做排除工作，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span>    nn[<span class="number">198</span>];</span><br><span class="line"><span class="keyword">int</span>     okay[<span class="number">198</span>],tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">short</span>   del[<span class="number">9703</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(num);i++)</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"output.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">29</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">51</span>,<span class="number">53</span>,<span class="number">57</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">87</span>,<span class="number">89</span>,<span class="number">91</span>,<span class="number">97</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">29</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;<span class="number">29</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(num[i]+num[j]&lt;<span class="number">198</span>)</span><br><span class="line">                nn[num[j]+num[i]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&lt;<span class="number">198</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(!nn[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">16</span>;j&lt;<span class="number">29</span>;j++)</span><br><span class="line">            <span class="comment">//两个数字要满足在界内，同时另一个数字是合数，然后剔掉这些数字。</span></span><br><span class="line">                <span class="keyword">if</span>((i-num[j]&lt;=<span class="number">99</span>) &amp;&amp; (!isprime(i-num[j])) &amp;&amp; (i-num[j]&gt;<span class="number">3</span>))&#123;</span><br><span class="line">                    nn[i]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&lt;<span class="number">198</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nn[i])&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">            okay[++tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//step2</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    tot-=<span class="number">2</span>;<span class="comment">//手动删除194,197;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=okay[i]/<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(del[j*(okay[i]-j)]==<span class="number">0</span>)</span><br><span class="line">                del[j*(okay[i]-j)]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(del[j*(okay[i]-j)]==<span class="number">1</span>)</span><br><span class="line">                del[j*(okay[i]-j)]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;okay[i]&lt;&lt;<span class="string">':'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;okay[i]/<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(del[j*(okay[i]-j)]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">' '</span>&lt;&lt;j&lt;&lt;<span class="string">'+'</span>&lt;&lt;okay[i]-j;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目概述&quot;&gt;&lt;a href=&quot;#题目概述&quot; class=&quot;headerlink&quot; title=&quot;题目概述&quot;&gt;&lt;/a&gt;题目概述&lt;/h2&gt;&lt;p&gt;一天，鬼谷子随意从2~99中选取了两个数。他把这两个数的和告诉了庞涓， 把这两个数的乘积告诉了孙膑。孙膑和庞涓彼此不知到对方得到的数。第二天， 庞涓很有自信的对孙膑说：虽然我不知到这两个数是什么，但我知道你一定也不知道。随后，孙膑说： 那我知道了。庞涓说：那我也知道了。&lt;br&gt;
    
    </summary>
    
      <category term="Think" scheme="http://izhen.me/categories/Think/"/>
    
    
      <category term="logic" scheme="http://izhen.me/tags/logic/"/>
    
      <category term="math" scheme="http://izhen.me/tags/math/"/>
    
      <category term="complete search" scheme="http://izhen.me/tags/complete-search/"/>
    
      <category term="hack方法" scheme="http://izhen.me/tags/hack%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MAC OS X 常用软件分享</title>
    <link href="http://izhen.me/2014/03/07/2014-03-07-my-mac-software-list/"/>
    <id>http://izhen.me/2014/03/07/2014-03-07-my-mac-software-list/</id>
    <published>2014-03-07T10:42:39.000Z</published>
    <updated>2019-11-27T15:02:36.950Z</updated>
    
    <content type="html"><![CDATA[<p>博主在使用 <a href="http://www.apple.com/cn/macbook-pro/" target="_blank" rel="noopener">RMBP</a> 一段时间后得到了大多数人对于 <a href="http://www.apple.com/cn/" target="_blank" rel="noopener">Apple</a> 产品的体验感。的确很好用，这一点主要是针对 <a href="http://www.linux.org/" target="_blank" rel="noopener">linux</a> 来说的。但是呢，工欲善其事，必先利其器。单纯的 <a href="http://www.apple.com/cn/macbook-pro/osx-retina/" target="_blank" rel="noopener">OS X</a> 能力毕竟有限，无论你是设计师还是Coder同样要懂得配置利于自己的环境。<del>我并不是设计师</del>，只简单聊聊我自己作为coder的环境体验：<br><a id="more"></a></p><h3 id="编程环境搭载"><a href="#编程环境搭载" class="headerlink" title="编程环境搭载"></a>编程环境搭载</h3><h4 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h4><p>OS X 默认已经安装了很多编译/解释环境，可以尝试输入如下命令查看版本信息：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br><span class="line">$ python</span><br><span class="line">$ gcc -v</span><br><span class="line">$ perl -v</span><br><span class="line"><span class="comment">#还有其他一些，这里不一一列举了</span></span><br></pre></td></tr></table></figure><p>如果想使用java或者其他没有自带的环境，可以自行安装。综上来看，<a href="http://www.apple.com/cn/macbook-pro/osx-retina/" target="_blank" rel="noopener">OS X</a> 还是很照顾程序员的，但是这仅仅是必要的一步，我们还有很多要做的事情。</p><h4 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h4><p>强烈推荐<a href="https://setapp.com" target="_blank" rel="noopener">setapp</a>，mac app届的steam。同时推荐 <a href="http://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 这个好用的包管理工具，可以自行上网搜索安装方法，使用起来也是很简单的:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew install [name]</span><br><span class="line">$ brew update</span><br><span class="line">$ brew upgrade [name]</span><br></pre></td></tr></table></figure><h4 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h4><p>想成为Hacker的Coder必备，可供选择的有很多：</p><ol><li><a href="http://aquamacs.org" target="_blank" rel="noopener">Aquamacs</a> Emacs for Mac OS X</li><li><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">Sublime</a> Text 很强大的编辑器，可以作为 TextMate 的替代品，商业软件</li><li><a href="https://code.google.com/p/macvim/" target="_blank" rel="noopener">MacVim</a> Mac下的Vim,要想实现漂亮的透明效果就要靠他了</li><li><del><a href="http://mouapp.com/" target="_blank" rel="noopener">Mou</a> 所见即所得 Markdown 编辑器</del></li><li><a href="https://code.visualstudio.com" target="_blank" rel="noopener">Visual Studio Code</a> 可以作为Atom的替代品</li></ol><h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><p>Editor不是全部，尽管圈内的Hacker精神崇拜者们做出了大力宣传，IDE还是可以用用的，毕竟不想让很多事情弄得很繁琐：</p><ol><li><a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener">Xcode</a> <a href="http://www.apple.com/cn/" target="_blank" rel="noopener">Apple</a> 自己出的的IDE,有时候需要他来编译东西</li><li><a href="http://www.jetbrains.com/" target="_blank" rel="noopener">Jetbrains</a> 的全部IDE产品</li><li><a href="http://haskellformac.com" target="_blank" rel="noopener">Haskell for Mac</a> 商业软件，很好用的Haskell IDE，本身Haskell的生态中成熟的集成开发环境就少，一般可以<a href="http://localhost:4000/2018/08/10/haskell_emacs/" target="_blank" rel="noopener">自己配置Emacs</a></li><li><a href="https://coq.inria.fr" target="_blank" rel="noopener">CoqIDE</a> Coq的官方IDE，免去了很多配置的麻烦</li><li><a href="http://isabelle.in.tum.de" target="_blank" rel="noopener">Isabelle</a> 定理证明工具，类似Coq，但是上手更友好</li></ol><h3 id="日常工作环境"><a href="#日常工作环境" class="headerlink" title="日常工作环境"></a>日常工作环境</h3><h4 id="办公与写作"><a href="#办公与写作" class="headerlink" title="办公与写作"></a>办公与写作</h4><ol><li><a href="http://www.apple.com/cn/macbook-pro/built-in-apps-retina/" target="_blank" rel="noopener">iWorks</a> 应该都已经有了，在10.9以后这已经是免费软件了（最强大的还是MS Office）</li><li><a href="https://www.yinxiang.com/?from=evernote" target="_blank" rel="noopener">Evernote</a> 云笔记爱好者强烈推荐</li><li><a href="http://tug.org/mactex/" target="_blank" rel="noopener">MacTex</a> 如果常写学术论文，这个是必备的，完整版包含了很多好用的写作工具，如：<a href="http://pages.uoregon.edu/koch/texshop/" target="_blank" rel="noopener">TexShop</a></li><li><a href="http://sparrowmailapp.com/" target="_blank" rel="noopener">Sparrow</a> 强烈推荐，很好用的邮件工具</li><li><a href="http://rime.github.io" target="_blank" rel="noopener">鼠鬚管</a> Mac上力荐的输入法，就个人感觉，是我用过的最好的汉字输入法，<a href="https://www.byvoid.com/blog/recommend-rime/" target="_blank" rel="noopener">相关介绍</a>，或者搜狗输入法</li><li><a href="https://www.macbartender.com" target="_blank" rel="noopener">Bartender</a> 如果Menu bar的图标太多，使用这款应用管理</li><li><a href="https://1password.com" target="_blank" rel="noopener">1Password</a> 最好用的密码管理软件</li><li><a href="https://mindnode.com" target="_blank" rel="noopener">MindNode</a> 思维导图</li><li><a href="https://www.omnigroup.com" target="_blank" rel="noopener">OmniGraffle</a> 流程图与矢量图形绘图软件，Mac上最好用的制图工具，Mac/iOS独占</li><li><a href="https://www.omnigroup.com" target="_blank" rel="noopener">OmniFocus</a> 时间管理，Mac/iOS独占</li><li><a href="https://www.omnigroup.com" target="_blank" rel="noopener">OmniOutliner</a> 任务拆分，思路拆分，Mac/iOS独占</li><li><a href="https://www.omnigroup.com" target="_blank" rel="noopener">OmniPlan</a> 计划管理，Mac/iOS独占</li><li><a href="https://smilesoftware.com/pdfpenpro/" target="_blank" rel="noopener">PDFpenPro</a> 非常强大的PDF软件</li><li><a href="https://getpocket.com" target="_blank" rel="noopener">Pocket</a> 碎片信息收集软件</li><li><a href="https://www.literatureandlatte.com/scrivener/overview" target="_blank" rel="noopener">Scrivener</a> 最强大的学术文献、小说写作软件</li><li><a href="https://www.atlassian.com/software/confluence/features" target="_blank" rel="noopener">Confluence</a> 文档协作服务</li></ol><h4 id="系统开发与调试"><a href="#系统开发与调试" class="headerlink" title="系统开发与调试"></a>系统开发与调试</h4><ol><li><a href="http://www.parallels.com/" target="_blank" rel="noopener">Parallel Desktop</a> Mac下很好用的虚拟机软件</li><li><a href="https://xscopeapp.com" target="_blank" rel="noopener">xScope</a> 界面设计</li><li><a href="https://www.pixelmator.com" target="_blank" rel="noopener">Pixelmator Pro</a> Mac上的Photoshop</li><li><a href="https://bjango.com/mac/istatmenus/" target="_blank" rel="noopener">iStat Menu</a> 监控系统与计算机状态</li><li><a href="https://www.sketchapp.com" target="_blank" rel="noopener">Sketch</a> App设计软件</li></ol><h4 id="娱乐与生活"><a href="#娱乐与生活" class="headerlink" title="娱乐与生活"></a>娱乐与生活</h4><ol><li><a href="https://itunes.apple.com/hk/app/movist/id461788075?mt=12" target="_blank" rel="noopener">Movist</a> Mac下最佳播放器，出色的 UI 设计和体验</li><li><a href="http://www.videolan.org/vlc/index.html" target="_blank" rel="noopener">VLC</a> 不错的开源播放器，与 <a href="https://itunes.apple.com/hk/app/movist/id461788075?mt=12" target="_blank" rel="noopener">Movist</a> 互补</li><li><a href="http://macitbetter.com/" target="_blank" rel="noopener">BetterZip</a> 很好用的压缩工具，支持RAR和中文，能够解决乱码问题</li><li><a href="http://wxbackup.imxfd.com" target="_blank" rel="noopener">微信备份</a> 用来备份微信生成网页文件</li><li><a href="https://www.cockos.com/licecap/" target="_blank" rel="noopener">LICEcap</a> 好用的屏幕录制工具</li><li><a href="https://telegram.org" target="_blank" rel="noopener">Telegram</a> 安全的聊天软件</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>博主还是个初学者，经验有限。以后随着了解的深入，会长期修改本文的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博主在使用 &lt;a href=&quot;http://www.apple.com/cn/macbook-pro/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RMBP&lt;/a&gt; 一段时间后得到了大多数人对于 &lt;a href=&quot;http://www.apple.com/cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apple&lt;/a&gt; 产品的体验感。的确很好用，这一点主要是针对 &lt;a href=&quot;http://www.linux.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;linux&lt;/a&gt; 来说的。但是呢，工欲善其事，必先利其器。单纯的 &lt;a href=&quot;http://www.apple.com/cn/macbook-pro/osx-retina/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OS X&lt;/a&gt; 能力毕竟有限，无论你是设计师还是Coder同样要懂得配置利于自己的环境。&lt;del&gt;我并不是设计师&lt;/del&gt;，只简单聊聊我自己作为coder的环境体验：&lt;br&gt;
    
    </summary>
    
      <category term="OS X" scheme="http://izhen.me/categories/OS-X/"/>
    
    
      <category term="OS X" scheme="http://izhen.me/tags/OS-X/"/>
    
      <category term="open source" scheme="http://izhen.me/tags/open-source/"/>
    
      <category term="software" scheme="http://izhen.me/tags/software/"/>
    
  </entry>
  
  <entry>
    <title>TAOMP第一章题目选解</title>
    <link href="http://izhen.me/2014/03/04/2014-03-04-taomp-chapter-1/"/>
    <id>http://izhen.me/2014/03/04/2014-03-04-taomp-chapter-1/</id>
    <published>2014-03-04T10:24:44.000Z</published>
    <updated>2016-08-14T01:49:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题概述1"><a href="#问题概述1" class="headerlink" title="问题概述1"></a>问题概述1</h3><p>习题4：假设你是最近被捕的P个囚犯之一。监狱长是个疯狂的计算机科学家，他给出了以下启示：</p><ol><li>你们今天可以在一起商定一个策略，但是从今天以后，你们将会被隔开关在不同的房间，相互间无法再进行交流。</li><li>我们建造了一种“开关房间”，里面有一个灯开关，这个开关只能为开和关，且没有和任何东西相连。</li><li>我将不时地从你们中间随机选择一位到“开关房间”里来。这名囚犯可以拨动开关（从开到关、或相反），也可保持开关的状态不变。其他人这时都不能进入房间。</li><li>每一名囚犯都将任意多次地进入开关房间。更确切地说，对于任意的N，你们中得每个人最终都至少进入这个房间N次。</li><li>任何时刻，任意一名囚犯都可以宣布：“我们所有的人都已经至少到过开关房间一次了。”如果该断言是对的，我将释放你们。如果错了，我就把你们全都送去喂鳄鱼。谨慎抉择吧！<a id="more"></a>提示：所有的囚犯不必做相同的动作。</li></ol><ul><li>在开关初始状态为<em>关</em>的情况下，设计一个可以成功取胜的策略。</li><li>在不知道开关初始状态的情况下，设计一个可以成功取胜的策略。</li></ul><h3 id="问题分析1"><a href="#问题分析1" class="headerlink" title="问题分析1"></a>问题分析1</h3><p>首先，我们每个人之间不能通信，因此“开关房间”是我们获取信息的唯一方法。而且能获取的信息只有开关的状态。提示指出了，每个囚犯做出的动作可以是非对称的。这样如果有一个人专门负责计数，其他人有统一的搬动开关的协议，这个问题是不难解决的。</p><h3 id="问题解答1"><a href="#问题解答1" class="headerlink" title="问题解答1"></a>问题解答1</h3><p>假设：依据条件4，每个囚犯有无穷多的机会进入房间，所以囚犯有无限长的寿命；每个囚犯呆在开关房中的时间有限；每个囚犯去开关房的间隔时间有限；计算机科学家寿命无限；囚犯只要没被喂鳄鱼就可以无限生存，不会生病等；开关房没有任何陷阱，不会出任何故障；开关不会损坏。</p><p>解答：</p><ul><li>如果初始状态是关，对囚犯编号为1~N(N &gt; 1, N是正整数)。<ul><li>1号囚犯每次进入房间时先观察开关，如果是关，不做任何事，否则心中的计数器自加1(初始为0)，并且反转开关状态。</li><li>2到N号囚犯每次进入房间，先观察开关状态，如果是关则打开，<strong>并且只能打开一次</strong>。如果曾执行过此操作，以后一概不执行。如果是开，则不动。</li><li>当1号囚犯的计数器累计到(N - 1)时就可以对着计算机科学家大喊“我们所有的人都已经至少到过开关房间一次了”</li></ul></li><li>如果初始状态不确定时<ul><li>当初始状态为关时，使用第一种方案可行。</li><li>当初时状态为开时，使用第一种方案可能会漏数一个人，所有人可能会被喂鳄鱼。<ul><li>如果已经数到了(N - 1)时，有两种可能：(a)所有人都到达过房间至少一次，有一人因为发现开关是开什么都没做就走了。(b)有一个人没到过房间，因为初始状态按照上述协议被计算了。</li><li>如果已经数到了(N - 1)时，假设还有一个始终未进入房间(初始的开状态被计数)。这个时候让负责计数的1号囚犯外所有囚犯重新获得一次搬动开关的机会，搬动协议如上述方案。而且可以得知此时开关状态一定是关闭状态。</li><li>上述假设始终未进入房间的人仍然未进入房间且其他人都进过时，1号所得总计数应当是 (N - 1) + (N - 2) = (2N - 3)，而这时如果此人进入一次则是 (2N - 2)。</li><li>所以，每个人有两次机会将开关由关改为开，并且计数器至少是(2N - 2)时才可断言“我们所有的人都已经至少到过开关房间一次了”。</li></ul></li></ul></li></ul><h3 id="问题概述2"><a href="#问题概述2" class="headerlink" title="问题概述2"></a>问题概述2</h3><p>习题5：上题中监狱长又有了另外一个想法。他命令囚犯们站成一排，每个人都戴着一顶红色或蓝色的帽子。没有人知道自己所戴帽子的颜色，也不知道他后面所有人帽子的颜色，但能看见前面所有人帽子的颜色。监狱长从队伍的后面开始询问每个囚犯，让他们猜测自己帽子的颜色。囚犯们自能回答“红色”或“蓝色”。如果他答错了，就会被送去喂鳄鱼。如果他答对了，则会被释放。每个囚犯都能听到后面所有人得回答，但不知道答案是否正确。</p><p>囚犯们在站队之前可以商讨一个策略（监狱长是听着的）。一旦站好队后，每个人除了能回答“红色”或“蓝色”以外，再也不能以其他任何方式进行交流。</p><p>设计一个能够保证P个囚犯中至少有(P - 1)个会被释放的策略。</p><h3 id="问题分析2"><a href="#问题分析2" class="headerlink" title="问题分析2"></a>问题分析2</h3><p>这里可以根据题目要求“P个囚犯中至少有(P - 1)个会被释放”小小的Hack一下。也就是说有一个人可以不保证他的死活，那么这个人将是其他人获救的关键。显然，如果这个人起到了作用，很大概率他就是站在最后一个位置的人。</p><h3 id="问题解答2"><a href="#问题解答2" class="headerlink" title="问题解答2"></a>问题解答2</h3><p>假设：那个不在乎生死的人的确大公无私，将自己的生死置之度外，并不会与其他人发生矛盾、背叛等。</p><p>解答：我们知道当前需要报出颜色的人的答案会全局广播，这是很重要的，也就是我们后面每个人都可以知道以前的人的帽子颜色。在当前的情境下，我们肯定能够得到的消息是：每个人眼前所有的囚犯的红色帽子数目及位置、蓝色帽子数目及位置、奇偶性。那么假设我能够解决这个问题，那么选择第一个人自我牺牲，从第二个人开始他们说的都会是对的。这样其实我也能得知从第二个到当前某个人身后的所有信息，因为说出红或蓝时会全局广播。这就够了。</p><p>第一个人首先要知道前面所有人中红色帽子的个数，如果红色帽子有奇数个就说“红色”，否则就说蓝色。</p><p>假设第一个人说了“红色”：</p><ul><li>这时候，第2个人如果是红色帽子会看到前方有偶数个红色的帽子，他一定会说红色。反之肯定会说蓝色，因为除了自己外一共有有奇数个红色，自己要是红色，第一个人就一定不会说红色，会产生矛盾。</li><li>而从第3个人(假设有第3个人)开始，都会知道第2个开始到他自己之前的人头顶上是什么颜色的帽子，并且可以统计红色帽子的奇偶性，可以推出如下协议：<ul><li>如果自己前面有偶数个红帽，自己之后也有偶数个红帽，自己就是红帽。</li><li>如果自己前面有奇数个红帽，自己之后也有奇数个红帽，自己就是红帽。</li><li>如果自己前面有奇数个红帽，自己之后也有偶数个红帽，自己就是蓝帽。</li><li>如果自己前面有偶数个红帽，自己之后也有奇数个红帽，自己就是蓝帽。</li></ul></li></ul><p>假设第一个人说了“蓝色”：</p><ul><li>那么，规则全部与上述相反。第二个人如果看到有奇数个帽子才会说红色，反之就是蓝帽。<ul><li>如果自己前面有偶数个红帽，自己之后也有偶数个红帽，自己就是蓝帽。</li><li>如果自己前面有奇数个红帽，自己之后也有奇数个红帽，自己就是蓝帽。</li><li>如果自己前面有奇数个红帽，自己之后也有偶数个红帽，自己就是红帽。</li><li>如果自己前面有偶数个红帽，自己之后也有奇数个红帽，自己就是红帽。</li></ul></li></ul><p>然而，第一个人则要碰碰运气，理论上他有50%的概率被喂鳄鱼或者50%的概率重获新生，人民会记住他的。(END)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题概述1&quot;&gt;&lt;a href=&quot;#问题概述1&quot; class=&quot;headerlink&quot; title=&quot;问题概述1&quot;&gt;&lt;/a&gt;问题概述1&lt;/h3&gt;&lt;p&gt;习题4：假设你是最近被捕的P个囚犯之一。监狱长是个疯狂的计算机科学家，他给出了以下启示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你们今天可以在一起商定一个策略，但是从今天以后，你们将会被隔开关在不同的房间，相互间无法再进行交流。&lt;/li&gt;
&lt;li&gt;我们建造了一种“开关房间”，里面有一个灯开关，这个开关只能为开和关，且没有和任何东西相连。&lt;/li&gt;
&lt;li&gt;我将不时地从你们中间随机选择一位到“开关房间”里来。这名囚犯可以拨动开关（从开到关、或相反），也可保持开关的状态不变。其他人这时都不能进入房间。&lt;/li&gt;
&lt;li&gt;每一名囚犯都将任意多次地进入开关房间。更确切地说，对于任意的N，你们中得每个人最终都至少进入这个房间N次。&lt;/li&gt;
&lt;li&gt;任何时刻，任意一名囚犯都可以宣布：“我们所有的人都已经至少到过开关房间一次了。”如果该断言是对的，我将释放你们。如果错了，我就把你们全都送去喂鳄鱼。谨慎抉择吧！
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="TAOMP" scheme="http://izhen.me/tags/TAOMP/"/>
    
      <category term="logic" scheme="http://izhen.me/tags/logic/"/>
    
  </entry>
  
  <entry>
    <title>CPU缓存命中优化之循环交换</title>
    <link href="http://izhen.me/2014/03/03/2014-03-03-cache-optimize-1/"/>
    <id>http://izhen.me/2014/03/03/2014-03-03-cache-optimize-1/</id>
    <published>2014-03-03T09:07:29.000Z</published>
    <updated>2016-08-14T01:49:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这是一道来自《多处理器编程的艺术》(TAOMP)的题目：习题222：</p><p>考虑一个具有16个缓存块的直接映射高速缓存，索引为0~15，每个缓存块包含32个字。考虑一个32x32的二维字数组a。该数组在内存中被排列为a[0,0]的下一个元素时a[0,1]，以此类推。假设该高速缓存初始为空，但a[0,0]被映射到0号缓存块的第一个字。(注意字与字节的不同之处)<br><a id="more"></a><br>考虑下面的列优先遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">sum += a[i,j]; <span class="comment">// 2nd dim changes fastest</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及下面的行优先遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">sum += a[j,i]; <span class="comment">// 1st dim changes fastest</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较两次遍历的缓存缺失个数，假设最早的缓存块被最优先替换。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>结果等价：首先这两段代码的实现上有不同，但最后的结果是等价的。</li><li>实现不等价：但是实现上却不等价，容易想到二者的缓存缺失率不一样。</li><li>原因：题目的描述”该数组在内存中被排列为a[0,0]的下一个元素时a[0,1]，以此类推”说明了，在内存中数据是按照列优先存储的。按照一般的缓存抓取原则，一般会把当前所使用的数据附近的数据一并抓入。所以，问题就来了：第二段代码被抓取的整个数据块几乎都是同行不同列的数据，当缓存失效时，会造成大量的缓存缺失。定量分析看，第一段的缓存缺失会小于第二段。</li><li>定性计算，假设使用LRU置换策略：(<del>我不太会算，请大神指出错误，计组没学好</del>)<ul><li>因为每个block包含有32个字，所以列优先存储的数组的一行附近连续的部分都会被抓取到缓存块中。这么看在第一次处理数组内层循环时没有缺失，也就是第一块除a[0,0]外完全命中。以此类推，缓存共有32次缺失。a[0,0]~a[31,0]共32个。</li><li>第二段程序不同在于缓存仍然抓取了按照列优先存储的一整行，但是缓存从内存中抓取的整个数据块几乎都是同行不同列的数据，而这些数据在接下来的内循环中完全无法被重复利用(来自wiki)，所以缺失是 32 * 32 = 1024 个。(如果说缓存不是16个块而是32个块就不一样了，二者的缺失数是一致的)</li></ul></li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>循环顺序交换，首先要知道，c/c++语言是按照行优先存储数组数据的；而fortran正相反是列优先。当使用行优先存储时，列优先遍历会快一些，反之亦然。所以如果遇到这个问题需要合理的进行循环顺序交换。对于不同语言交换方式不同，c/c++与fortran正好相反。总的来说，这是个不难解决的问题。(END)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;这是一道来自《多处理器编程的艺术》(TAOMP)的题目：习题222：&lt;/p&gt;
&lt;p&gt;考虑一个具有16个缓存块的直接映射高速缓存，索引为0~15，每个缓存块包含32个字。考虑一个32x32的二维字数组a。该数组在内存中被排列为a[0,0]的下一个元素时a[0,1]，以此类推。假设该高速缓存初始为空，但a[0,0]被映射到0号缓存块的第一个字。(注意字与字节的不同之处)&lt;br&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="cache" scheme="http://izhen.me/tags/cache/"/>
    
      <category term="TAOMP" scheme="http://izhen.me/tags/TAOMP/"/>
    
  </entry>
  
  <entry>
    <title>计算机界的无上心法</title>
    <link href="http://izhen.me/2014/01/04/2014-01-18-basic-skill-computer/"/>
    <id>http://izhen.me/2014/01/04/2014-01-18-basic-skill-computer/</id>
    <published>2014-01-04T07:43:00.000Z</published>
    <updated>2016-08-14T01:49:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h2><p>我觉得这个话题说大不大，说小不小。引发我思考的根源是无意中看到的一篇<a href="http://www.zhihu.com/question/21406792" target="_blank" rel="noopener">知乎</a>上的讨论，有人推荐<a href="http://coolshell.cn/articles/8275.html" target="_blank" rel="noopener">酷壳</a>中的一篇相关的文章可以参考。对于他人的回答我不做过多评论，怎么看待就见仁见智了。回过头说话，无上心法终究是谁提出的不太清楚，但是来源于武林这是八九不离十。武林中的武功修为与现在大多数技术圈的修炼异曲同工，都是需要一定的积累方可成就，怎么去积累就有怎样的成就。也会延伸出诸多的领域，就说计算机科学无外乎以下几类(参考Wiki)：</p><ul><li>理论计算机科学<ul><li>计算理论</li><li>算法与数据结构</li><li>程序设计语言理论</li><li>信息与编码</li><li>并发与分布式系统</li><li>数据库与检索</li><li>形式化方法<a id="more"></a></li></ul></li><li>应用计算机科学<ul><li>AI</li><li>计算机体系结构</li><li>计算机视觉</li><li>计算机安全与密码学</li><li>计算科学</li><li>信息科学</li><li>软件工程</li></ul></li></ul><h2 id="谈谈数学"><a href="#谈谈数学" class="headerlink" title="谈谈数学"></a>谈谈数学</h2><p>首先，既然名为<strong>计算</strong>机，与计算相关就离不了数学，这是本源。没错我的出发点并非你所学所用需要的技巧，而是本身对于计算机整个体系构建的形态为何，就是数学。上面可以看出，计算机科学至少有两大分支，一是理论，一是应用。我不确定这样分是否科学，我自己的经验是：计算机乃一门实践性质很强的学科，如果创造的理论没有应用价值其意义就不大，包括传说中的量子计算，一定得是我们看的着的，努力努力也能摸得到的。</p><p>这些理论基础细分到不能细分，简化到不能简化，归其本质，无非<strong>数学</strong>二字。假如计算机的代表就是编程，不管什么程序，不管多么初级且简单亦或是多么高深且复杂，都是由数学所积淀。汇编语言若没有优秀的数理逻辑写出来就是一团乱麻；再观函数式编程，其所包含的便是一种很优秀的<strong>抽象</strong>思想。既然都叫<strong>函数式</strong>了，就算不知其所以然，也要知其然，编制函数式程序，很容易就体会得到那种数学的形式美，<del>但是你是否真的能够做到充分的理解也许不算是重点</del>。</p><h2 id="谈谈表达"><a href="#谈谈表达" class="headerlink" title="谈谈表达"></a>谈谈表达</h2><p>表达能力是一个外向的能力，如同你编程，实际上是把自己心中的想法说出来，告诉一台机器要怎么做。表达的准确，得到的结果就会接近预期。请想一想，在你的学生生涯中，你是否对于作文课感到头痛？基本的语文素养怎么样？最重要的是每当你像他人阐述想法时，是否足够准确，且高效。记得有人说代码就像诗歌，也有人把一个优秀的coder称作是创作家，比如说画家(参考黑客与画家)，文艺工作者或艺术家们都是善于表现与表达的人群，把自己的想法通过文字、音符或者色彩、造型表达出来就是他们所擅长的。</p><p>而在计算机界，表达的媒介是代码，仅仅是在形式上与艺术家们不同而已。我强调作为圈内人士应当注重自己的这种能力，与优秀的数学素养同样重要，一个占据右脑，一个占据左脑，左右搭配干活不累。</p><h2 id="回到计算机"><a href="#回到计算机" class="headerlink" title="回到计算机"></a>回到计算机</h2><p>其实数学所体现的价值就好比计算机的所需要的内功一样，是一种后劲，也许不能够帮助你完成漂亮的招式，但其的确是漂亮招式的大前提。不是所有接触编程的人都想成为计算机科学家，甚至很多人连算法之类的都不想去碰。不过我却认为假如受过比较系统的训练，在这些方面你表现的会比一般的程序员好些。说白了就是抽象能力与建模能力会强一些，体现在编程上就是代码会清晰简洁，简单就是美。</p><p>而优秀的表达能力则是让你把存在于大脑中想法高效且准确的通过某种形式转化出来，想想一个人表达能力很差劲，写出的代码或许就会脱离自己本来的想法，甚至很混乱繁复。如果不是编程，而是单纯的系统设计也是如此，建筑师的图纸画得跟涂鸦一样，那么很难想象那栋建筑是否能真的能被建造出来，即便可以，中间也必然会浪费很多被迫与土木工程师协调沟通的精力。不过这种情况不太可能发生就是了，在这里仅打个比方。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以综上所述，我认为计算机界的无上心法无非就是数学与表达。不过若想做好，仅仅会内功是不行的，有时候还需要一些高明的<strong>招式</strong>，比如做事的感觉与对事物的品味等等，很多有多年经验的顶级Hacker都表达出了相似的内容，这不与我所说的矛盾。先打好基础，其他的事自然会水到渠成。有<a href="https://github.com/LTaoist" target="_blank" rel="noopener">同学</a>给出了建议：不如在谈论这个话题之前，先把下面的书都读懂。注意是读<strong>懂</strong>，而不是读<strong>过</strong>哦：</p><ul><li>Code Complete (2nd edition) <strong>by</strong> Steve McConnell</li><li>The Pragmatic Programmer</li><li>Structure and Interpretation of Computer Programs</li><li>The C Programming Language <strong>by</strong> Kernighan and Ritchie</li><li>Introduction to Algorithms <strong>by</strong> Cormen, Leiserson, Rivest &amp; Stein</li><li>Design Patterns <strong>by</strong> the Gang of Four</li><li>Refactoring: Improving the Design of Existing Code</li><li>The Mythical Man Month</li><li>The Art of Computer Programming <strong>by</strong> Donald Knuth</li><li>Compilers: Principles, Techniques and Tools <strong>by</strong> Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman</li><li>Gödel, Escher, Bach <strong>by</strong> Douglas Hofstadter</li><li>Clean Code: A Handbook of Agile Software Craftsmanship <strong>by</strong> Robert C. Martin</li><li>Effective C++</li><li>More Effective C++</li><li>CODE <strong>by</strong> Charles Petzold</li><li>Programming Pearls <strong>by</strong> Jon Bentley</li><li>Working Effectively with Legacy Code <strong>by</strong> Michael C. Feathers</li><li>Peopleware <strong>by</strong> Demarco and Lister</li><li>Coders at Work <strong>by</strong> Peter Seibel</li><li>Surely You’re Joking, Mr. Feynman!</li></ul><p>注：以上列表来自 <a href="http://stackoverflow.com/" target="_blank" rel="noopener">StackOverflow</a> 关于 <a href="http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read" target="_blank" rel="noopener">程序员该读的书</a> 投票的前20名。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引论&quot;&gt;&lt;a href=&quot;#引论&quot; class=&quot;headerlink&quot; title=&quot;引论&quot;&gt;&lt;/a&gt;引论&lt;/h2&gt;&lt;p&gt;我觉得这个话题说大不大，说小不小。引发我思考的根源是无意中看到的一篇&lt;a href=&quot;http://www.zhihu.com/question/21406792&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知乎&lt;/a&gt;上的讨论，有人推荐&lt;a href=&quot;http://coolshell.cn/articles/8275.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;酷壳&lt;/a&gt;中的一篇相关的文章可以参考。对于他人的回答我不做过多评论，怎么看待就见仁见智了。回过头说话，无上心法终究是谁提出的不太清楚，但是来源于武林这是八九不离十。武林中的武功修为与现在大多数技术圈的修炼异曲同工，都是需要一定的积累方可成就，怎么去积累就有怎样的成就。也会延伸出诸多的领域，就说计算机科学无外乎以下几类(参考Wiki)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理论计算机科学&lt;ul&gt;
&lt;li&gt;计算理论&lt;/li&gt;
&lt;li&gt;算法与数据结构&lt;/li&gt;
&lt;li&gt;程序设计语言理论&lt;/li&gt;
&lt;li&gt;信息与编码&lt;/li&gt;
&lt;li&gt;并发与分布式系统&lt;/li&gt;
&lt;li&gt;数据库与检索&lt;/li&gt;
&lt;li&gt;形式化方法
    
    </summary>
    
      <category term="Think" scheme="http://izhen.me/categories/Think/"/>
    
    
      <category term="SICP" scheme="http://izhen.me/tags/SICP/"/>
    
      <category term="Math" scheme="http://izhen.me/tags/Math/"/>
    
      <category term="Algorithm" scheme="http://izhen.me/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Octopress的搭建与撰写</title>
    <link href="http://izhen.me/2013/11/07/2014-01-18-basic-octopress-build/"/>
    <id>http://izhen.me/2013/11/07/2014-01-18-basic-octopress-build/</id>
    <published>2013-11-07T13:46:00.000Z</published>
    <updated>2016-08-14T01:48:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/octopress.jpg" alt="Octopress"></p><p>维护自己的日志是一个很有意思的活动，我第一次接触个人独立Blog是在高三的的下学期，因为大学有了着落，借此机会抛弃掉以前的什么XX空间，就把Blog搬到了 <a href="http://wordpress.com/" target="_blank" rel="noopener">WordPress</a> 上，还为此买了虚拟主机和域名（<del>对于个人网站来说备案真是一件既麻烦又浪费时间的事儿</del>）。但是呢，移植完文章后的很长一段时间都没有好好更新，域名到期后就关闭掉那个旧的Blog了。</p><a id="more"></a><p>所以这个 <a href="http://octopress.org/" target="_blank" rel="noopener">Octopress</a> 是时隔很长时间的第二个个人独立Blog，不同的是这个press只能Geek用，一般用户不会用。第二点，我没有买虚拟主机只买了域名，整个Blog托管在 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 上。此前，我用 <a href="http://wordpress.com/" target="_blank" rel="noopener">Wordpress</a> 最大的感触就是臃肿，其Bug一样的富文本编辑器弄得我的格式混乱不堪，不过最为重要的是使用 <a href="http://wordpress.com/" target="_blank" rel="noopener">Wordpress</a> 不够酷炫，不能令我一直心动。</p><p>而且我没有那么多功能需要使用。Blog无非就是放上一篇有文有图的文章，加上个评论，足矣。</p><blockquote><p>A blogging framework for hackers.</p></blockquote><p>这是 <a href="http://octopress.org/" target="_blank" rel="noopener">Octopress</a> 自己的宣传，我觉得真正的Hacker会自己弄一个Blog，起码会用 <a href="http://jekyllrb.com/" target="_blank" rel="noopener">Jekyll</a> 甚至是 <a href="http://jaspervdj.be/hakyll/" title="基于Haskell模仿Jekyll的blog系统" target="_blank" rel="noopener">Hakyll</a> (原理大同小异)，那么我们这些使用 <a href="http://octopress.org/" target="_blank" rel="noopener">Octopress</a> 的用户算是初级的Geek这种程度吧。不说这些了，轻量的Blog用起来确实比 <a href="http://wordpress.com/" target="_blank" rel="noopener">Wordpress</a> 酷炫多了。接下来我会一步一步说明如何在MAC OS X中搭建这个日志系统：</p><p>第一步是最重要的一步：我们要弄清楚octopress的运行环境是在 <a href="https://www.ruby-lang.org/zh_cn/" target="_blank" rel="noopener">ruby</a> -1.9.2以上的版本中，但是在OS X 10.9中已经安装了2.0版本，亲自实验，如果使用过高的版本会产生无法正确生成静态页面的问题。我们要安装一个低版本，这里推荐1.9.3，然后我们说明如何多版本共存：</p><h3 id="先安装Ruby-1-9-3"><a href="#先安装Ruby-1-9-3" class="headerlink" title="先安装Ruby-1.9.3"></a><strong>先安装Ruby-1.9.3</strong></h3><p>1.安装 <a href="https://itunes.apple.com/cn/app/xcode/id497799835?mt=12" target="_blank" rel="noopener">Xcode</a> ，这是为了以后安装需要编译。</p><p>2.安装 <a href="https://github.com/Homebrew/homebrew" target="_blank" rel="noopener">Homebrew</a> ，非常推荐这个包管理，以后我们就多多利用它了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L <span class="symbol">http:</span>/<span class="regexp">/github.com/mxcl</span><span class="regexp">/homebrew/tarball</span><span class="regexp">/master | tar xz –strip 1 -C /usr</span><span class="regexp">/local</span></span><br><span class="line"><span class="regexp">$ export PATH=/usr</span><span class="regexp">/local/bin</span><span class="symbol">:</span>$PATH</span><br></pre></td></tr></table></figure><p>3.安装 <a href="http://rvm.io/" target="_blank" rel="noopener">rvm</a> ，这是一个很出色的 <a href="https://www.ruby-lang.org/zh_cn/" target="_blank" rel="noopener">Ruby</a> 包管理软件，同时安装1.9.3并设定为默认版本：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ \curl -sSL <span class="symbol">https:</span>/<span class="regexp">/get.rvm.io | bash -s stable</span></span><br><span class="line"><span class="regexp">$ rvm install 1.9.3</span></span><br><span class="line"><span class="regexp">$ rvm use 1.9.3 --default</span></span><br></pre></td></tr></table></figure><h3 id="好的，接下来是Octopress"><a href="#好的，接下来是Octopress" class="headerlink" title="好的，接下来是Octopress"></a><strong>好的，接下来是Octopress</strong></h3><p>1.一般情况下最新的 OS X 已经包含 <a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a> ，我们直接安装 <a href="http://octopress.org/" target="_blank" rel="noopener">Octopress</a> ：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone <span class="symbol">git:</span>/<span class="regexp">/github.com/imathis</span><span class="regexp">/octopress.git octopress</span></span><br></pre></td></tr></table></figure><p>2.安装 <a href="https://github.com/sstephenson/rbenv" target="_blank" rel="noopener">rbenv</a> ，可以理解为同样是一种包管理：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew install rbenv</span><br><span class="line">$ brew install ruby-build</span><br><span class="line">$ rbenv rehash</span><br></pre></td></tr></table></figure><p>3.安装必要插件：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd octopress</span><br><span class="line">$ gem install bundler</span><br><span class="line">$ bundle install</span><br><span class="line">$ rbenv rehash</span><br></pre></td></tr></table></figure><p>4.安装主题：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rake install</span><br></pre></td></tr></table></figure><p>按照上面的步骤去做就全部安装完毕，接下来是如何生成与发布，但是再次之前，如果你的算把博客安置在 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 上面，我们有必要的一步要做。</p><h3 id="发布准备与部署"><a href="#发布准备与部署" class="headerlink" title="发布准备与部署"></a><strong>发布准备与部署</strong></h3><p>1.本机创建ssh:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~<span class="regexp">/.ssh</span></span><br><span class="line"><span class="regexp">$ ssh-keygen -t rsa -C 你注册github用的邮箱地址</span></span><br></pre></td></tr></table></figure><p>按照提示一步一步来，最后获得ssh后把它添加到你的 <a href="https://github.com/" target="_blank" rel="noopener">github</a> 账户中去，可以参考<a href="https://help.github.com/articles/generating-ssh-keys" target="_blank" rel="noopener">这个</a>链接。</p><p>然后你需要测试是否成功：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>返回如下提示就成功了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ Hi username! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>2.建立一个仓库后我们开始部署，按照提示输入你的仓库网址：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rake setup_github_pages</span><br></pre></td></tr></table></figure><p>3.生成博客资料：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rake generate</span><br></pre></td></tr></table></figure><p>4.把source(原始文件)传上去：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">'your message'</span></span><br><span class="line">$ git push origin source</span><br></pre></td></tr></table></figure><p>注意那个origin可以为你想起的任何名字。</p><p>5.上传正式发布的博客：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rake deploy</span><br></pre></td></tr></table></figure><p>有可能会遇到上传不成功的情况，这个时候需要在项目的<code>.git/config</code>目录中添加如下代码，必要时可以重新启动系统(<del>怎么有M$的遗风</del>)：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line"> remote = origin</span><br><span class="line"> merge = refs/heads/master</span><br></pre></td></tr></table></figure><p>好了，到此为止你就可以发布一个博客了，注意到，如果想要自定义自己的域名要在<code>source/CNAME</code>中添加你的一级域名，比如<code>izhen.me</code>，同时在你的域名服务商那里添加一条A记录，有关具体的地址内容请到 <a href="http://octopress.org/" target="_blank" rel="noopener">Octopress</a> 中查看文档，遵守官方指示：不要使用CNAME记录。</p><h3 id="文章撰写与分页"><a href="#文章撰写与分页" class="headerlink" title="文章撰写与分页"></a><strong>文章撰写与分页</strong></h3><p>1.创建一篇新文章，默认在<code>source/_posts</code>中，以<code>markdown</code>格式存在：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rake new_post[<span class="string">'your-title'</span>]</span><br></pre></td></tr></table></figure><p>2.用文本编辑器，这里推荐 <a href="http://mouapp.com/" target="_blank" rel="noopener">Mou</a> 来打开新创建的文件，并且使用Markdown来撰写文章，其中有关于标签分类，这里说明下有以下几种格式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分类形式1</span></span><br><span class="line"><span class="symbol">categories:</span> [Octopress, Phase, Markdown, Ruby, Git]</span><br><span class="line"><span class="comment"># 分类形式2</span></span><br><span class="line"><span class="symbol">categories:</span> Octopress, Phase, Markdown, Ruby, Git</span><br><span class="line"><span class="comment"># 分类形式3</span></span><br><span class="line"><span class="symbol">categories:</span> </span><br><span class="line">- Octopress</span><br><span class="line">- Phase</span><br><span class="line">- Markdown</span><br></pre></td></tr></table></figure><p>3.分页：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准分页</span></span><br><span class="line">$ rake new_page[your-page]</span><br><span class="line"><span class="comment"># 创建子分页</span></span><br><span class="line">$ rake new_page[your-page/sub-page.html]</span><br></pre></td></tr></table></figure><p>然后要让这个分页的链接显示在主页上面需要在<code>source/_include/custom/navigation.html</code>中自行添加链接。</p><p>要达到「详细内容」的效果，使用<code>&lt;!-- more --&gt;</code>标记就可以了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>这里只是草草介绍了如何搭建和简单的写作，感觉很简洁，没有太多累赘，页面也是静态的，诸如评论等内容需要额外配置<code>_config.yml</code>。写文章使用<code>Markdown</code>这一点真是太好了， <a href="http://wordpress.com/" target="_blank" rel="noopener">Wordpress</a> 的富文本编辑器实在是…</p><p>不过，这里没有讲解如何具体写文章，但是也非常简单，可以参考文档去查阅相关资料，如果想要更进一步了解比如自定义博客主题，也请多多学习文档，推荐刚入门的朋友们来学习使用 <a href="http://octopress.org/" target="_blank" rel="noopener">Octopress</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/image/octopress.jpg&quot; alt=&quot;Octopress&quot;&gt;&lt;/p&gt;
&lt;p&gt;维护自己的日志是一个很有意思的活动，我第一次接触个人独立Blog是在高三的的下学期，因为大学有了着落，借此机会抛弃掉以前的什么XX空间，就把Blog搬到了 &lt;a href=&quot;http://wordpress.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WordPress&lt;/a&gt; 上，还为此买了虚拟主机和域名（&lt;del&gt;对于个人网站来说备案真是一件既麻烦又浪费时间的事儿&lt;/del&gt;）。但是呢，移植完文章后的很长一段时间都没有好好更新，域名到期后就关闭掉那个旧的Blog了。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="Octopress" scheme="http://izhen.me/tags/Octopress/"/>
    
      <category term="Phase" scheme="http://izhen.me/tags/Phase/"/>
    
      <category term="Markdown" scheme="http://izhen.me/tags/Markdown/"/>
    
      <category term="Ruby" scheme="http://izhen.me/tags/Ruby/"/>
    
      <category term="Git" scheme="http://izhen.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>USACO 6.1.2 Vans</title>
    <link href="http://izhen.me/2013/05/26/usaco_612/"/>
    <id>http://izhen.me/2013/05/26/usaco_612/</id>
    <published>2013-05-26T15:39:27.000Z</published>
    <updated>2018-09-30T06:33:18.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>找规律。第一张图和第二张图其实已经暗示了这道题目的潜在规律。注意到从一个第一行的点横向出发再回到这个点只有从这个点下面的点回来。定义F[i]表示从前i列中第i列的第2个点到第1个点共有多少合法路径，根据这个定义F[n]即为所求。G[i]表示前i列中第i列的第1个点到第4个点共有多少路径。因此可以推出F[i] = F[i-1] + G[i-1] (画图找规律)。</p><p>下面我们仔细观察这两个方程的定义，从而化简方程，如下图：</p><p>G[i] = F[i-1] * 2 + G[i-2] + G4[i] (1)</p><p>G4[i] = F[i-2] * 2 + G4[i-1] (2)</p><p>由(1)化简(2)式得到：G4[i] = G[i-1] - G1[i-1] - G2[i-1] - G3[i-1] + F[i-2] * 2 = G[i-1] - G[i-3]</p><p>所以G[i] = F[i-1]*2 + G[i-1] + G[i-2] - G[i-3] (3)</p><p>又由F[i] - F[i-1] = G[i-1] (4)</p><p>最终我们得到 F[n] = 2F[n-1] + 2F[n-2] - 2F[n-3] + F[n-4] (n&gt;=5)</p><p>初始值：F[1] = 0; F[2] = 2; F[3] = 4; F[4] = 12。</p><a id="more"></a><p><img src="/image/idealnova/612.png" alt="USACO 6.1.2"></p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>Compiling…<br>Compile: OK</p><p>Executing…<br>   Test 1: TEST OK [0.000 secs, 3388 KB]<br>   Test 2: TEST OK [0.000 secs, 3388 KB]<br>   Test 3: TEST OK [0.000 secs, 3388 KB]<br>   Test 4: TEST OK [0.000 secs, 3388 KB]<br>   Test 5: TEST OK [0.000 secs, 3520 KB]<br>   Test 6: TEST OK [0.000 secs, 3784 KB]<br>   Test 7: TEST OK [0.000 secs, 4048 KB]<br>   Test 8: TEST OK [0.000 secs, 4576 KB]<br>   Test 9: TEST OK [0.000 secs, 6952 KB]<br>   Test 10: TEST OK [0.011 secs, 9328 KB]<br>   Test 11: TEST OK [0.032 secs, 15136 KB]</p><p>All tests OK.</p><p>YOUR PROGRAM (‘vans’) WORKED FIRST TIME!  That’s fantastic<br>– and a rare thing.  Please accept these special automated<br>congratulations.</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (a &gt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  Node()&#123;</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> num[<span class="number">500</span>], len;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">friend</span> Node <span class="keyword">operator</span> +  (<span class="keyword">const</span> Node &amp;A, <span class="keyword">const</span> Node &amp;B)&#123;</span><br><span class="line">    Node *C = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="keyword">int</span>  LEN = MAX(A.len, B.len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LEN; i++)&#123;</span><br><span class="line">      C-&gt;num[i] += A.num[i] + B.num[i];</span><br><span class="line">      C-&gt;num[i + <span class="number">1</span>] += C-&gt;num[i] / <span class="number">10</span>;</span><br><span class="line">      C-&gt;num[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(C-&gt;num[LEN + <span class="number">1</span>]!= <span class="number">0</span>) C-&gt;len = ++LEN;</span><br><span class="line">    <span class="keyword">else</span>  C-&gt;len =LEN;</span><br><span class="line">    <span class="keyword">return</span>  *C;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> Node <span class="keyword">operator</span> -  (<span class="keyword">const</span> Node &amp;A, <span class="keyword">const</span> Node &amp;B)&#123;</span><br><span class="line">    Node *C = <span class="keyword">new</span> Node;</span><br><span class="line">    *C = A;</span><br><span class="line">    <span class="keyword">int</span>  LEN = A.len, jinwei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LEN; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(C-&gt;num[i] &lt; B.num[i])&#123;</span><br><span class="line">        C-&gt;num[i] += <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= LEN; j++)&#123;</span><br><span class="line">          C-&gt;num[j]--;</span><br><span class="line">          <span class="keyword">if</span>(C-&gt;num[j] &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">else</span> C-&gt;num[j] += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      C-&gt;num[i] -= B.num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!C-&gt;num[LEN]) C-&gt;len;</span><br><span class="line">    <span class="keyword">return</span>  *C;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span> =  (<span class="keyword">const</span> Node &amp;A)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= A.len; i++)  num[i] = A.num [i];</span><br><span class="line">    len = A.len ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i--) </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d"</span>, num[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;dp[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"vans.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"vans.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">dp[<span class="number">1</span>].len = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">2</span>].len = <span class="number">1</span>, dp[<span class="number">2</span>].num[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">dp[<span class="number">3</span>].len = <span class="number">1</span>, dp[<span class="number">3</span>].num[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">dp[<span class="number">4</span>].len = <span class="number">2</span>, dp[<span class="number">4</span>].num[<span class="number">1</span>] = <span class="number">2</span>, dp[<span class="number">4</span>].num[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(n &gt;= <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dp[<span class="number">5</span>] = dp[<span class="number">4</span>] + dp[<span class="number">4</span>] + dp[<span class="number">3</span>] + dp[<span class="number">3</span>] + dp[<span class="number">1</span>] - dp[<span class="number">2</span>] - dp[<span class="number">2</span>];</span><br><span class="line">dp[<span class="number">1</span>] = dp[<span class="number">2</span>], dp[<span class="number">2</span>] = dp[<span class="number">3</span>], dp[<span class="number">3</span>] = dp[<span class="number">4</span>], dp[<span class="number">4</span>] = dp[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line">dp[(n &gt;= <span class="number">5</span> ? <span class="number">5</span> : n)].print();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本文是百度空间的移植，附：全部<a href="https://github.com/i-zhen/USACO-training" target="_blank" rel="noopener">USACO题目解答</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;找规律。第一张图和第二张图其实已经暗示了这道题目的潜在规律。注意到从一个第一行的点横向出发再回到这个点只有从这个点下面的点回来。定义F[i]表示从前i列中第i列的第2个点到第1个点共有多少合法路径，根据这个定义F[n]即为所求。G[i]表示前i列中第i列的第1个点到第4个点共有多少路径。因此可以推出F[i] = F[i-1] + G[i-1] (画图找规律)。&lt;/p&gt;
&lt;p&gt;下面我们仔细观察这两个方程的定义，从而化简方程，如下图：&lt;/p&gt;
&lt;p&gt;G[i] = F[i-1] * 2 + G[i-2] + G4[i] (1)&lt;/p&gt;
&lt;p&gt;G4[i] = F[i-2] * 2 + G4[i-1] (2)&lt;/p&gt;
&lt;p&gt;由(1)化简(2)式得到：G4[i] = G[i-1] - G1[i-1] - G2[i-1] - G3[i-1] + F[i-2] * 2 = G[i-1] - G[i-3]&lt;/p&gt;
&lt;p&gt;所以G[i] = F[i-1]*2 + G[i-1] + G[i-2] - G[i-3] (3)&lt;/p&gt;
&lt;p&gt;又由F[i] - F[i-1] = G[i-1] (4)&lt;/p&gt;
&lt;p&gt;最终我们得到 F[n] = 2F[n-1] + 2F[n-2] - 2F[n-3] + F[n-4] (n&amp;gt;=5)&lt;/p&gt;
&lt;p&gt;初始值：F[1] = 0; F[2] = 2; F[3] = 4; F[4] = 12。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="DP" scheme="http://izhen.me/tags/DP/"/>
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="运算符重载" scheme="http://izhen.me/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="高精度" scheme="http://izhen.me/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>USACO 5.5.1 Picture</title>
    <link href="http://izhen.me/2013/05/24/usaco_551/"/>
    <id>http://izhen.me/2013/05/24/usaco_551/</id>
    <published>2013-05-23T21:39:37.000Z</published>
    <updated>2018-09-23T16:25:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>其实边界需要统计的是上下左右4个方向没有被覆盖到的边长的总和。这个问题的难点是怎样使得需要判断检索重叠的复杂度尽量小，我们先简化问题，假设所有矩形都是A情况的，也就是宽度都一样并且垂直排列，这样的话我们就将矩形的情况分为不相交，交叠，包含几种情况。先从横向的边开始看，如图所示，如果只考虑蓝色和浅绿色这两个矩形因为没有任何与其相交的其他矩形，直接统计横向边长，然而交叠和包含要怎么办呢。如图红色和黄色的矩形有橙色的部分，那么也就是说我们只用统计红色的上边长和黄色的下边长了。而浅蓝色和紫色的关系也是类似只用统计紫色的两个边。</p><p>从这里我们得到一些启发，假设所有边长都是1个单位长度，显然我们只是统计一个覆盖域的上下两个边界，那么这从抽象意义上很类似括号匹配的问题，下面的这些矩形块可以抽象成<font color="aqua">()</font><font color="lime">()</font><font color="red">(</font><font color="yellow">(</font><font color="red">)</font><font color="yellow">)</font><font color="purple">(</font><font color="blue">()</font><font color="purple">)</font>注意观察它们的特点，可以发现跟真实的配对没有关系，也就是()()(())(())，我们用一个栈依次压入括号，每次出现()的配对就出栈。然后要统计这些，当压入后(且栈只有这一个元素)时计数器加一，当弹出元素后栈空时计数器加一。这样我们就相当于统计出了所有的该纳入计算的边界，由这个思考点出发，我们要对所有的矩形边进行离散化，同时要区别上下边界，抽象成“左右括号”。这个时候有个细节，对于横向边我们按纵标排序，如果纵标一样谁在前？其实这也是交叠的一种情况，如果纵标一样，先要把左括号排在前，也就是如果我们按纵标由小到大排，下边界应在前，不然会使得周长变大。</p><p>具体实现时我们看B图，因为配对不只是一种情况，而且坐标很大，这时候我们可以使用线段树来辅助数据结构的部分，需要横着纵着处理两次。也就是对于类似括号匹配中栈的操作，真正实现用的是线段树。</p><p>这样本问题就解决了，算法是<strong>离散化+线段树</strong>。这个算法的正确性是我们已经排好了序，而且每个方向的边都是成对出现的。</p><a id="more"></a><p><img src="/image/idealnova/usaco551.png" alt="离散化+线段树"></p><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p>Compiling…<br>Compile: OK</p><p>Executing…<br>   Test 1: TEST OK [0.011 secs, 5100 KB]<br>   Test 2: TEST OK [0.011 secs, 5100 KB]<br>   Test 3: TEST OK [0.011 secs, 5100 KB]<br>   Test 4: TEST OK [0.011 secs, 5100 KB]<br>   Test 5: TEST OK [0.011 secs, 5100 KB]<br>   Test 6: TEST OK [0.011 secs, 5100 KB]<br>   Test 7: TEST OK [0.043 secs, 5100 KB]<br>   Test 8: TEST OK [0.011 secs, 5100 KB]<br>   Test 9: TEST OK [0.043 secs, 5100 KB]<br>   Test 10: TEST OK [0.011 secs, 5100 KB]<br>   Test 11: TEST OK [0.259 secs, 5100 KB]</p><p>All tests OK.</p><p>YOUR PROGRAM (‘picture’) WORKED FIRST TIME!  That’s fantastic<br>– and a rare thing.  Please accept these special automated<br>congratulations.</p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (a &gt; b ? a : b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> recv recvh</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rech recvh</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">long</span> lch, rch, l, r, clr, mid, all, tot;  <span class="comment">//clr表示当前颜色,all表示整体的颜色</span></span><br><span class="line">        <span class="keyword">bool</span> mark;    <span class="comment">//mark是True时杂色，False则纯色。</span></span><br><span class="line">&#125;tree[<span class="number">40005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectVH</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> s, t, vh, start;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> rectVH &amp;cmp)<span class="keyword">const</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(vh == cmp.vh) <span class="keyword">return</span> cmp.start &lt; start;</span><br><span class="line">                <span class="keyword">return</span> vh &lt; cmp.vh;</span><br><span class="line">        &#125;       </span><br><span class="line">&#125;recvh[<span class="number">20005</span>];</span><br><span class="line"><span class="keyword">long</span> tot = <span class="number">1</span>, n, ans;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">regtree</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right, <span class="keyword">long</span> index)</span></span>&#123;</span><br><span class="line">                        tree[index].l = left;</span><br><span class="line">                        tree[index].r = right;</span><br><span class="line">                        tree[index].mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">                        tree[index].all = right - left + <span class="number">1</span>;</span><br><span class="line">                        tree[index].mark = tree[index].clr = tree[index].tot = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                                tree[index].lch = ++tot;</span><br><span class="line">                                build(left, tree[index].mid, tot);</span><br><span class="line">                                tree[index].rch = ++tot;</span><br><span class="line">                                build(tree[index].mid + <span class="number">1</span>, right, tot);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right, <span class="keyword">long</span> index, <span class="keyword">int</span> delta)</span></span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(tree[index].l &gt;= left &amp;&amp; tree[index].r &lt;= right) </span><br><span class="line">                                <span class="keyword">if</span>(!tree[index].mark)&#123; <span class="comment">//lazy</span></span><br><span class="line">                                        tree[index].clr += delta;</span><br><span class="line">                                        <span class="keyword">if</span>(tree[index].clr == <span class="number">1</span> &amp;&amp; delta &gt; <span class="number">0</span>)</span><br><span class="line">                                                ans += tree[index].all;</span><br><span class="line">                                        <span class="keyword">if</span>(tree[index].clr == <span class="number">0</span> &amp;&amp; delta &lt; <span class="number">0</span>)</span><br><span class="line">                                                ans += tree[index].all;</span><br><span class="line">                                        <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!tree[index].mark &amp;&amp; tree[index].all != <span class="number">1</span>)&#123; <span class="comment">//下放</span></span><br><span class="line">                                tree[tree[index].lch].clr = tree[index].clr;</span><br><span class="line">                                tree[tree[index].lch].mark = <span class="literal">false</span>;</span><br><span class="line">                                tree[tree[index].rch].clr = tree[index].clr;</span><br><span class="line">                                tree[tree[index].rch].mark = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(tree[index].all == <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">//不递归叶子结点</span></span><br><span class="line">                        <span class="keyword">if</span>(left &lt;= tree[index].mid &amp;&amp; tree[index].lch != <span class="number">0</span>)</span><br><span class="line">                                insert(left, right, tree[index].lch, delta); </span><br><span class="line">                        <span class="keyword">if</span>(right &gt; tree[index].mid &amp;&amp; tree[index].rch != <span class="number">0</span>)</span><br><span class="line">                                insert(left, right, tree[index].rch, delta);</span><br><span class="line">                        tree[index].mark = <span class="literal">true</span>;    <span class="comment">//先归为杂色，因为递归后有可能是杂色</span></span><br><span class="line">                        <span class="keyword">if</span>(!tree[tree[index].lch].mark &amp;&amp; !tree[tree[index].rch].mark &amp;&amp; </span><br><span class="line">                                (tree[tree[index].lch].clr == tree[tree[index].rch].clr)) <span class="comment">//恢复统一色，如果可能</span></span><br><span class="line">                                tree[index].mark = <span class="literal">false</span>, </span><br><span class="line">                                tree[index].clr = tree[tree[index].lch].clr;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;line;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tree[<span class="number">0</span>].mark = <span class="literal">false</span>;       <span class="comment">//边界条件     </span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> N2 = n * <span class="number">2</span>, N3 = n * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> lx, ly, rx, ry;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;lx, &amp;ly, &amp;rx, &amp;ry);</span><br><span class="line">                lx += <span class="number">10000</span>, ly += <span class="number">10000</span>, rx += <span class="number">10000</span>, ry += <span class="number">10000</span>;</span><br><span class="line">                recv[i].s = ly, recv[i].t = ry - <span class="number">1</span>;</span><br><span class="line">                recv[i].vh = lx, recv[i].start = <span class="literal">true</span>;</span><br><span class="line">                recv[i + n].s = ly, recv[i + n].t = ry - <span class="number">1</span>;</span><br><span class="line">                recv[i + n].vh = rx, recv[i + n].start = <span class="literal">false</span>;</span><br><span class="line">                rech[i + N2].s = lx, rech[i + N2].t = rx - <span class="number">1</span>;</span><br><span class="line">                rech[i + N2].vh = ly, rech[i + N2].start = <span class="literal">true</span>;</span><br><span class="line">                rech[i + N3].s = lx, rech[i + N3].t = rx - <span class="number">1</span>;</span><br><span class="line">                rech[i + N3].vh = ry, rech[i + N3].start = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(recvh + <span class="number">1</span>, recvh + N2 + <span class="number">1</span>);</span><br><span class="line">        sort(recvh + N2 + <span class="number">1</span>, recvh + n + N3 + <span class="number">1</span>);</span><br><span class="line">        tot = <span class="number">1</span>, line.build(<span class="number">0</span>, <span class="number">20000</span>, <span class="number">1</span>);   <span class="comment">//纵向的边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N2; i++)</span><br><span class="line">                line.insert(recvh[i].s, recvh[i].t, <span class="number">1</span>, (recvh[i].start ? <span class="number">1</span> : <span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="keyword">sizeof</span>(tree));</span><br><span class="line">        tot = <span class="number">1</span>, line.build(<span class="number">0</span>, <span class="number">20000</span>, <span class="number">1</span>);   <span class="comment">//横向的边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N2 + <span class="number">1</span>; i &lt;= N3 + n; i++)</span><br><span class="line">                line.insert(recvh[i].s, recvh[i].t, <span class="number">1</span>, (recvh[i].start ? <span class="number">1</span> : <span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果排序时出现一样值的情况，要处理优先级。</p><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>Hard down(省选/NOI)</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本文是原Wordpress博客的移植，附：全部<a href="https://github.com/i-zhen/USACO-training" target="_blank" rel="noopener">USACO题目解答</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;其实边界需要统计的是上下左右4个方向没有被覆盖到的边长的总和。这个问题的难点是怎样使得需要判断检索重叠的复杂度尽量小，我们先简化问题，假设所有矩形都是A情况的，也就是宽度都一样并且垂直排列，这样的话我们就将矩形的情况分为不相交，交叠，包含几种情况。先从横向的边开始看，如图所示，如果只考虑蓝色和浅绿色这两个矩形因为没有任何与其相交的其他矩形，直接统计横向边长，然而交叠和包含要怎么办呢。如图红色和黄色的矩形有橙色的部分，那么也就是说我们只用统计红色的上边长和黄色的下边长了。而浅蓝色和紫色的关系也是类似只用统计紫色的两个边。&lt;/p&gt;
&lt;p&gt;从这里我们得到一些启发，假设所有边长都是1个单位长度，显然我们只是统计一个覆盖域的上下两个边界，那么这从抽象意义上很类似括号匹配的问题，下面的这些矩形块可以抽象成&lt;font color=&quot;aqua&quot;&gt;()&lt;/font&gt;&lt;font color=&quot;lime&quot;&gt;()&lt;/font&gt;&lt;font color=&quot;red&quot;&gt;(&lt;/font&gt;&lt;font color=&quot;yellow&quot;&gt;(&lt;/font&gt;&lt;font color=&quot;red&quot;&gt;)&lt;/font&gt;&lt;font color=&quot;yellow&quot;&gt;)&lt;/font&gt;&lt;font color=&quot;purple&quot;&gt;(&lt;/font&gt;&lt;font color=&quot;blue&quot;&gt;()&lt;/font&gt;&lt;font color=&quot;purple&quot;&gt;)&lt;/font&gt;注意观察它们的特点，可以发现跟真实的配对没有关系，也就是()()(())(())，我们用一个栈依次压入括号，每次出现()的配对就出栈。然后要统计这些，当压入后(且栈只有这一个元素)时计数器加一，当弹出元素后栈空时计数器加一。这样我们就相当于统计出了所有的该纳入计算的边界，由这个思考点出发，我们要对所有的矩形边进行离散化，同时要区别上下边界，抽象成“左右括号”。这个时候有个细节，对于横向边我们按纵标排序，如果纵标一样谁在前？其实这也是交叠的一种情况，如果纵标一样，先要把左括号排在前，也就是如果我们按纵标由小到大排，下边界应在前，不然会使得周长变大。&lt;/p&gt;
&lt;p&gt;具体实现时我们看B图，因为配对不只是一种情况，而且坐标很大，这时候我们可以使用线段树来辅助数据结构的部分，需要横着纵着处理两次。也就是对于类似括号匹配中栈的操作，真正实现用的是线段树。&lt;/p&gt;
&lt;p&gt;这样本问题就解决了，算法是&lt;strong&gt;离散化+线段树&lt;/strong&gt;。这个算法的正确性是我们已经排好了序，而且每个方向的边都是成对出现的。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="离散化" scheme="http://izhen.me/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
      <category term="USACO" scheme="http://izhen.me/tags/USACO/"/>
    
      <category term="线段树" scheme="http://izhen.me/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>USACO 5.4.4 Betsy</title>
    <link href="http://izhen.me/2013/05/21/usaco_544/"/>
    <id>http://izhen.me/2013/05/21/usaco_544/</id>
    <published>2013-05-20T21:39:37.000Z</published>
    <updated>2018-09-23T16:36:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>问题的本质是求所有的可能的哈密顿路径的情况，可以使用DFS+剪枝求解。<br>本问题的考点也是剪枝，有以下两种情况：</p><ol><li><p>孤立区域的形成:<br>如图所示，孤立区域也就是被划分成了两个域的情况，这个时候无论走哪个区域另一个区域都无法访问，那么一个剪枝就可以是判断当前有无孤立区域的形成，这个产生条件比较多，有一种基本情况就是如果当前点上下（包括边界）被访问过了，而左右没被访问则必产生孤立，另一个情况则正好相反。理由是当前点上下如果被访问了，而这两个访问过的点都是由起点走过来的，也就是都连通到起点，意义就是这两个点本身是连通的。我们不能穿过被访问过的路径走交叉路线，所以说这样无论走哪里都会被包住再也出不来了。这是一个情况。</p></li><li><p>进入死胡同:<br>我们考虑类似围棋中的气，每个格子不需要一进一出，也就是至少有两个度，如果只有一个度则走进去后就再也出不来了，我们不必要碰到度为一的点再去回溯。而是一开始就避免度为一的点产生。剪枝方式是：除去起点和终点外如果当前点的周围未被访问的格子中有度为一的点(也就是连通到另外一个未被访问的格子)，那么这个点必须要访问，理由是这个点如果被访问，就相当于他的一个入度被利用了，如果不访问则就浪费掉了。浪费之后他的度为1，以后则会只进不出。因此必须要访问，所以可以推出另一个关于度的剪枝，如果存在两个以上的度为1的点则回溯，因为不能两个同时都选，选了一个，另一个必然是死胡同。</p></li></ol><a id="more"></a><p><img src="/image/idealnova/usaco544.png" alt="各种情况"></p><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p>Compiling…<br>Compile: OK</p><p>Executing…<br>   Test 1: TEST OK [0.000 secs, 3376 KB]<br>   Test 2: TEST OK [0.000 secs, 3376 KB]<br>   Test 3: TEST OK [0.000 secs, 3376 KB]<br>   Test 4: TEST OK [0.000 secs, 3376 KB]<br>   Test 5: TEST OK [0.000 secs, 3376 KB]<br>   Test 6: TEST OK [0.000 secs, 3376 KB]<br>   Test 7: TEST OK [0.119 secs, 3376 KB]</p><p>All tests OK.</p><p>YOUR PROGRAM (‘betsy’) WORKED FIRST TIME!  That’s fantastic<br>– and a rare thing.  Please accept these special automated<br>congratulations.</p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">map</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">int</span> pos[][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;, n, total;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getlive</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">map</span>[x + pos[k][<span class="number">0</span>]][y + pos[k][<span class="number">1</span>]])</span><br><span class="line">                        t++;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n &amp;&amp; y == <span class="number">1</span>)&#123;    <span class="comment">//剪枝1,不能提前到达终点</span></span><br><span class="line">                <span class="keyword">if</span>(sum == n * n) total++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">map</span>[x][y<span class="number">-1</span>] &amp;&amp; <span class="built_in">map</span>[x][y+<span class="number">1</span>] &amp;&amp; !<span class="built_in">map</span>[x<span class="number">-1</span>][y] &amp;&amp; !<span class="built_in">map</span>[x+<span class="number">1</span>][y]) || </span><br><span class="line">           (!<span class="built_in">map</span>[x][y<span class="number">-1</span>] &amp;&amp; !<span class="built_in">map</span>[x][y+<span class="number">1</span>] &amp;&amp; <span class="built_in">map</span>[x<span class="number">-1</span>][y] &amp;&amp; <span class="built_in">map</span>[x+<span class="number">1</span>][y])) <span class="comment">//剪枝2，孤立区域剪枝</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mx, my, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;               <span class="comment">//剪枝3,格子的度的处理      </span></span><br><span class="line">                <span class="keyword">int</span> X = x + pos[i][<span class="number">0</span>], Y = y + pos[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[X][Y] || (X == n &amp;&amp; Y == <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(getlive(X, Y) &lt; <span class="number">2</span>) count++, mx = X, my = Y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="built_in">map</span>[mx][my] = <span class="number">1</span>;</span><br><span class="line">                        dfs(mx, my, sum + <span class="number">1</span>);</span><br><span class="line">                        <span class="built_in">map</span>[mx][my] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">                                <span class="keyword">int</span> X = x + pos[i][<span class="number">0</span>], Y = y + pos[i][<span class="number">1</span>];</span><br><span class="line">                                <span class="keyword">if</span>(!<span class="built_in">map</span>[X][Y])&#123;</span><br><span class="line">                                        <span class="built_in">map</span>[X][Y] = <span class="number">1</span>;</span><br><span class="line">                                        dfs(X, Y, sum + <span class="number">1</span>);</span><br><span class="line">                                        <span class="built_in">map</span>[X][Y] = <span class="number">0</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)       <span class="comment">//处理边界</span></span><br><span class="line">                <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">map</span>[<span class="number">0</span>][i] = <span class="built_in">map</span>[n + <span class="number">1</span>][i] = <span class="built_in">map</span>[i][<span class="number">0</span>] = <span class="built_in">map</span>[i][n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>剪枝的消耗也要考虑在内。</p><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>Medium Up(NOIP the 4th)</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>基于SCC的状态压缩动态规划，参考陈丹琦集训队论文。</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本文是原Wordpress博客的移植，附：全部<a href="https://github.com/i-zhen/USACO-training" target="_blank" rel="noopener">USACO题目解答</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;问题的本质是求所有的可能的哈密顿路径的情况，可以使用DFS+剪枝求解。&lt;br&gt;本问题的考点也是剪枝，有以下两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;孤立区域的形成:&lt;br&gt;如图所示，孤立区域也就是被划分成了两个域的情况，这个时候无论走哪个区域另一个区域都无法访问，那么一个剪枝就可以是判断当前有无孤立区域的形成，这个产生条件比较多，有一种基本情况就是如果当前点上下（包括边界）被访问过了，而左右没被访问则必产生孤立，另一个情况则正好相反。理由是当前点上下如果被访问了，而这两个访问过的点都是由起点走过来的，也就是都连通到起点，意义就是这两个点本身是连通的。我们不能穿过被访问过的路径走交叉路线，所以说这样无论走哪里都会被包住再也出不来了。这是一个情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入死胡同:&lt;br&gt;我们考虑类似围棋中的气，每个格子不需要一进一出，也就是至少有两个度，如果只有一个度则走进去后就再也出不来了，我们不必要碰到度为一的点再去回溯。而是一开始就避免度为一的点产生。剪枝方式是：除去起点和终点外如果当前点的周围未被访问的格子中有度为一的点(也就是连通到另外一个未被访问的格子)，那么这个点必须要访问，理由是这个点如果被访问，就相当于他的一个入度被利用了，如果不访问则就浪费掉了。浪费之后他的度为1，以后则会只进不出。因此必须要访问，所以可以推出另一个关于度的剪枝，如果存在两个以上的度为1的点则回溯，因为不能两个同时都选，选了一个，另一个必然是死胡同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="USACO" scheme="http://izhen.me/tags/USACO/"/>
    
      <category term="DFS" scheme="http://izhen.me/tags/DFS/"/>
    
      <category term="剪枝" scheme="http://izhen.me/tags/%E5%89%AA%E6%9E%9D/"/>
    
  </entry>
  
  <entry>
    <title>转：俄罗斯TC三冠王ACM顶尖选手Petr感悟</title>
    <link href="http://izhen.me/2012/04/02/petr_think/"/>
    <id>http://izhen.me/2012/04/02/petr_think/</id>
    <published>2012-04-02T10:57:35.000Z</published>
    <updated>2018-09-22T08:35:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Do not spend all your time on training or studying - this way you will probably become very exhausted and unwilling to compete more. Whatever you do - have fun. Once you find programming is no fun anymore – drop it. Play soccer, find a girlfriend, study something not related to programming, just live a life - programming contests are only programming contests, and nothing more. Don’t let them become your life - for your life is much more interesting and colorful.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Do not spend all your time on training or studying - this way you will probably become very exhausted and unwilling to compete more. What
      
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="Petr" scheme="http://izhen.me/tags/Petr/"/>
    
      <category term="ACM" scheme="http://izhen.me/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2012新年前最后的文章</title>
    <link href="http://izhen.me/2012/01/21/2012_new_year/"/>
    <id>http://izhen.me/2012/01/21/2012_new_year/</id>
    <published>2012-01-20T19:48:54.000Z</published>
    <updated>2018-09-23T08:08:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里说的新年特指中国农历龙年，明天就是除夕夜，所以在此说说。很久不更新blog是因为的确没什么好更新的。我喜欢将自己的研究项目，解题报告发到博客上，可是，上了大学，这方面的事情少很多。要说研究还是有的，但是直观价值不大。我不想总结这一学期，ms是小小的延续了一下高中的状态。可是愈到期末愈好了。所以可以预见到下个学期会好很多。</p><p>要说我特别想说的就是，在某些方面有预见性的进步。对于个人能力，潜力我都表示无所顾忌。也不需要，不必要。能开心的“娱乐”、“玩”就很好了（想不到有什么其他更好的词了，如果想到我一定会写上的）。然后呢，说说成果，这个学期积累多成果少。这种状态就很不错，至少我比较满意了，比高中强。高中嘛积累不算少，成果也不多，可就是不及大学。</p><a id="more"></a><p>老规矩，不说点我认为有用的，我就认为这篇blog价值不大。什么是有用的？特指我认为有用的。</p><p>当然，在这里我不想附上 Cauchy不等式的证明，这个的价值还不如<a href="https://izhen.me/2014/03/10/2014-03-10-guiguzi-hard-problem/">鬼谷子的数学难题</a>价值大。网上有的是。也不想公布适用范围很小的某某定理。更不想证明连续数项和以及方和方差公式（估计以我国奥数水平小学生都会XD）。特别是，这些其实比较无聊。所以，就当是复习，论述一下二叉树吧。</p><p>二叉树的检索价值显而易见，原理就是二分检索。复杂度logN。我们在使用线性的二分检索时，不可避免的要使用有序化操作，考虑到一些抽象的离散模型，这个操作进行完成后，也就是有序化后从宏观角度看（如果是一系列数串）可以认定为最小（最大）表示。所以我个人认为也可看作是最小（大）表示法的离散抽象序列。</p><p>那么m次检索有O(MlogN).可是很少见实际问题中是有序的数列，所以加上排序O(NlogN+MlogN)=O(ClogN),M与N给定后视作一个较大的常数。所以乍一看，也不是logN阶的，是吧。要是二叉检索树（因为是线性二分，要是平面的四分，立体的8分另外考虑），插入是logN,其实每次插入N都不一样，每次的阶都是上次+1。所以呢插入后再去检索的时间复杂度的阶会有和线性二分一样的结果。一个特殊的例子是线段树，也是二叉树一大类的。</p><p>不过二叉检索树的一个巨大优势是他的在线效应。普通的二分是离线的，每次插入新的检索元都要重新排序造成不必要的损耗（有人说链表，链表实现二分会得不偿失的，Hash吧，不过不想讨论Hash）。这是一大弊端，可是他稳定。二叉树是不稳定的，有时会退化成一条链，这就是成了线性检索了= =。因此要让其平衡，最初有科学家发明了AVL，很强大的自平衡二叉树，之后什么红黑，什么AA什么BB都有了。可是偏偏我们要讨论一个性价比很高的Treap，Treap的诞生归功于实验，大量的实验表明随机的一串离散抽象数数据有超过96%的可能在构造二叉树时是平衡的，那么就让Treap有个权值假设是随机的赋予的，这样的话用构建堆的形式去建树就是理论上96%的可能是平衡树了。</p><p>这要归功于随机数，即便是伪随机，他的分布很均匀。事实上在用时，不止96%的可能（这个问题留给读者），那么显然要高于96%,说不定99%。实现简单是Treap的优点，因为Treap=BST+Heap。我国的一位OI界天才发明的SBT也是类似于Treap的非严格平衡树(AVL和红黑是严格平衡的)，不过SBT却结合了Splay（AVL的衍生，非严格）的优点，对于区间数据的操作很好，这是Treap没有的。</p><p>但是如果只是一般的检索而不是有什么特殊处理的话那些<strong>几十行上百行的代码可以替代为<code>#include&lt;set&gt;</code></strong></p><p>到此为止，一堆文字，祝愿大家龙年吉祥！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里说的新年特指中国农历龙年，明天就是除夕夜，所以在此说说。很久不更新blog是因为的确没什么好更新的。我喜欢将自己的研究项目，解题报告发到博客上，可是，上了大学，这方面的事情少很多。要说研究还是有的，但是直观价值不大。我不想总结这一学期，ms是小小的延续了一下高中的状态。可是愈到期末愈好了。所以可以预见到下个学期会好很多。&lt;/p&gt;
&lt;p&gt;要说我特别想说的就是，在某些方面有预见性的进步。对于个人能力，潜力我都表示无所顾忌。也不需要，不必要。能开心的“娱乐”、“玩”就很好了（想不到有什么其他更好的词了，如果想到我一定会写上的）。然后呢，说说成果，这个学期积累多成果少。这种状态就很不错，至少我比较满意了，比高中强。高中嘛积累不算少，成果也不多，可就是不及大学。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="New year" scheme="http://izhen.me/tags/New-year/"/>
    
  </entry>
  
  <entry>
    <title>IIROOM技术可行性分析</title>
    <link href="http://izhen.me/2011/11/18/iiroom/"/>
    <id>http://izhen.me/2011/11/18/iiroom/</id>
    <published>2011-11-17T21:38:37.000Z</published>
    <updated>2018-09-27T14:46:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>全名：Intelligent Interaction Room<br>Writer：钟王偲 Z.Y.</p><a id="more"></a><h3 id="整体技术架构分析"><a href="#整体技术架构分析" class="headerlink" title="整体技术架构分析"></a>整体技术架构分析</h3><p><img src="/image/iiroom/1.png" alt="Basic hierachy"></p><h4 id="IIROOM技术可行性分析"><a href="#IIROOM技术可行性分析" class="headerlink" title="IIROOM技术可行性分析"></a>IIROOM技术可行性分析</h4><p>IIRoom系统本身含有3个层次：GUI层、内核层、网络层。同时必须要硬件层辅助（硬件层非重点内容）。IIRoom包含特殊的文件系统，以及特殊的应用程序组织（有DNA特征[ZY1] ）。其中实现的主要难点在于算法和数据结构的选择，必要时必须自主开发新的算法，现有算法均是成熟的可行的算法 。本系统的智能主要体现在主DNA内核和集成DNA内核，这两个内核以及客户-服务端的模式构成了IIRoom的主体。层次中具体架构图式如下（虚线表示一定条件下非必需）：</p><p><img src="/image/iiroom/2.png" alt="Framework"></p><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><ol><li>编程语言和数据库：<br> C/C++[ZY2]   PHP/MySQL/JAVA[ZY3]  汇编[ZY4] ；</li><li>硬件环境与系统环境：<br> 系统环境：FreeBSD/Ubuntu Linux/Red Hat(服务器版)/Mac(放弃Windows环境，需要Mac强大的图形处理能力)<br> CPU: Intel Xeon 6核 或 AMD同等级别处理器。<br> RAM:32GB DDR5<br> GPU:FX3800级别以上<br> 存储：1TB(不需要太大容量，要求速度)15000 r/s以上传统硬盘，或者基于DRAM芯片的SSD。<br> 带宽：10Gbp/s(LAN)<br> *用户使用时的配置低于开发环境的配置，配置要求主要在全息投影和体感设备上。</li></ol><h4 id="下面我们对所涉及的技术与算法做具体分析"><a href="#下面我们对所涉及的技术与算法做具体分析" class="headerlink" title="下面我们对所涉及的技术与算法做具体分析"></a>下面我们对所涉及的技术与算法做具体分析</h4><h4 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h4><p><img src="/image/iiroom/3.png" alt="GUI"></p><ol><li><p>图形识别（动作识别）：<br> <em>使用微软kinect作为我们的识别设备，下面是我们假想的一些算法：</em><br> 输入摄像头端口具备红外感应，可以扫描到红外视图，然后识别时执行以下几步：</p><ol><li>扫描筛图，把红外感应的图层从整体的影像中筛选出来，可能涉及到的算法有离散FFT.</li><li>撒点，已被扫描的图像进行整体抽象，依据精度把图形抽象为给定坐标中的点。必须为离散型方便计算机处理。</li><li>凸包围图：如果是2D的平面，使用Graham扫描法，对于3D空间可以扩展立体的凸包。此种扫描主要使用叉乘，核心是判断两个线段的相对位置。需要一开始找到原点。</li><li>近似匹配：利用近似搜索把动作做成离散的分解，由以上几步，模式匹配后近似搜索动作组合（可能依靠k-d树），并最终抽象成真正的指令。模式匹配可能用到的算法有KMP（基本），AC-自动机[ZY5] ，后缀树或者后缀数组[ZY6] 。</li></ol><p><strong>技术难点</strong>：模式匹配，凸包，近似搜索，K-d树的实现。</p></li><li><p>语音识别：<br> 语音识别负责识别用户的语音，并做出指令，识别后的处理放式与图形识别非常类似，具体如下：</p><ol><li>录入语音，整合波形，抽象成离散的点，点的密度视识别精度而定，之所以抽象是为了匹配时方便处理，计算机仅可处理离散的数据，与图形识别撒点相同。</li><li>模式匹配类似的语音指令，涉及到的算法有：KMP，AC-自动机，后缀数组等。</li></ol><p><strong>技术难点</strong>：模式匹配。</p></li><li><p>输入数据抽象：<br> <em>我们仍然在这个步骤使用kinect:</em><br> 语音识别后的数据和图形识别后的数据或者直接输入的数据等统称为输入数据，输入数据分段为各个数据组，数据组再次抽象为斐波那契堆，堆是一种优先队列，可以很好的满足我们的处理需求。而斐波那契堆具有相当好的特点：删除是O(logN)，<br> 除了删除，其他的插入和查找的时间复杂度理论为O(1)的，具体实现时可以使用Pair-Heap，Pair-Heap[ZY7] 是基于斐波那契堆的一种实用性实现，具体实现时效果优于斐波那契堆。<br> <strong>技术难点</strong>：配对堆（Pair-Heap）。</p></li><li><p>输出：<br> 使用裸眼3D技术。（视差障壁技术或更为先进的MLD技术）<br> 使用眼镜屏幕隔空操作（具体参见麻省理工学校学生普拉纳夫发明第六感装置）<br> 输出时将信息流译码，然后交与硬件层，如全息投影设备等进行输出。本部分不涉及创新内容，与当先的技术没有太大区别，无非是全息投影。<br> <strong>技术难点</strong>：涉及硬件，有全息投影等输出设备即可。</p></li></ol><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层在IIRoom中具体指网络套件(与TCP/IP协议中的网络层意义不同)，是具有具体网络功能的一些套件：包括加密与解密包，WEB层面浏览解析包，网络安全包，网络组织包这4个基本包，其他包功能可以由主DNA内核在基本包基础上由用户自行进行重组。包中的内容含在各个内核中。<br>具体包功能技术可行性分析：</p><ol><li><p>加密与解密包：<br> 结合<strong>RSA密钥，MD5，SHA1</strong>等加密技术对“脑波[ZY8] ”加密、做数字签名等，加密后的流称作“密脑波”与“脑波签名”、非加密的脑波叫“原脑波”，解密后的流叫“失密脑波”。<br> 流中的数据先被分块，被切割成有树状结构的数据组，数据组再被加密，并被赋予随机分阶的权[ZY9] ，然后传输。解密时，必须按照数据组的树状结构的顺序解密，否则将失败，因此“脑波”具有很高的安全性。而且支持流的随机化算法加密，即同样的信息可以被不同流程的加密传送，再由公钥给出指示，做具体解密。<br> 失密脑波与原脑波能表示完全一样的信息，但是可能具有不同的结构，解密时按照树状结构的顺序，查看随机分阶的权，在不破坏信息流的情况下被重组为等价的树结构，能保证不破坏原信息的指标就是先前的随机分阶的权，但是如果结构特殊，可能只有唯一的树满足，那么失密脑波与原脑波就会完全一致。<br> <strong>技术难点</strong>：各种加密、Hash和随机化算法。</p></li><li><p>WEB层面浏览解析包：<br> 我们已经具备的web2.0技术和基于http与ftp等相关协议传输的信息，均可以直接整合为“脑波”，系统接收到这种脑波后，对于脑波先用加解密包做出解密，然后将这种信息流先经由主DNA内核处理整合，最后输出到GUI层。<br> <strong>技术难点</strong>：暂无。</p></li><li><p>网络安全包：<br> 本包直接采取Linux/Unix式安全方式，这是由系统本身的机制所决定的，unix式的安全机制使得无需安装任何杀毒工具，因此对于用户权限的把控IIRoom非常严格。我们采取软防火，这个模块可以使用开源的（GNU协议，法律支持）Linux/Unix机制，而Linux/Unix的机制也是相当成熟的。但是我们并不是架构在*nix体系上的东西，网络安全包将封闭化，这是保证安全的一个必要渠道。<br> <strong>技术难点</strong>：与unix安全机制的整合。</p></li><li><p>网络组织包：<br> 这是网络层与主DNA直接嫁接的包，他隶属于通信内核。在超级服务端可以自由组织私有类神经的网络信道（用以共享DNA）。网络组织也是完成加密会议的必要，网络网络通路需要检查组织的可行性和最短链路。实现时，对于可行性采用网络流算法，因为网络可以被抽象成隐式图，所以使用HLPP预流-推进算法[ZY10] 和匈牙利–二分图算法，这两种算法主要做匹配以快速检查可行性。对于最短链路使用D-star算法，D-star是A-star的强化，一种启发式搜索算法，组织式这两步都非常必要。<br> <strong>技术难点</strong>：网络流，二分图，D-star.</p></li></ol><h4 id="内核层"><a href="#内核层" class="headerlink" title="内核层"></a>内核层</h4><p><img src="/image/iiroom/4.png" alt="Kernel"></p><ol><li><p>I/O内核：<br> I/O内核要对输入的抽象数据[ZY11] 与主DNA内核进行交互，首先要分析堆的内容，然后依次弹出到主DNA内核层，通讯内核层等。而接收到主DNA内核层的指示与信息流时，他会依照指令与具体的数据类型进行最适当的输出，是GUI层的直属功能内核。<br> <strong>技术难点</strong>：对于堆的信息分析。</p></li><li><p>主DNA 内核：<br> 这是IIRoom的“首脑”，首先他作为整个系统的“领导”，负责最高权限的指令下达，直接控制其他任何内核，但是不能垮层控制[ZY12] 。对于任何指令其内嵌堆、栈结构，拥有检索模块，可以直接对存储内核检索。并支持超精度计算。<br> DNA的定义：DNA是指IIRoom的文件制式和程序组织，IIRoom的文件结构不再是线性的，而是类似超文本同时又有独立的拓扑结构的。程序的组织中每个子段均有特征DNA,特征DNA的构造又主DNA内核采用Hash完成，同时不同类型的文件和程序满足相统一的加密标准，并流化。因此程序可以自由依照DNA重组。首先按照特定的Hash抽取特征DNA.然后将文件结构信息与DNA整合，加密DNA并被组织到文件中，文件按照DNA的结构组织顺序。解密时先解密DNA，获取DNA中的信息读取出文件的结构顺序，接着对于程序或文件进行执行即可。<br> DNA重组：这是由用户自选的重组，首先分析至少2个软件的对等模块是否存在并反馈，如果存在，主DNA内核先解密DNA，更改并交换DNA，加密DNA。这样新的软件便被组织完成。<br> DNA自重组：这是IIRoom自行的智能行为，它本身具备一定的智能性。每当用户运行服务或者软件时，都有一个指标测试对于同类服务进行比较，如若这次的服务优于之前的则自行进行改良，改良方式是神经网络算法。而对于IIRoom本身对用户的操作反馈和指令执行的能力，用户可以直接反馈自己对IIRoom的理解指令的意见，IIRoom也能自行发觉，发觉后改良方式是遗传算法，这样再结合神经网络能做到定向进化，是系统的智能性自我提高。<br> <strong>技术难点</strong>：遗传算法，神经网络，Hash。</p></li><li><p>集成DNA内核：<br> 集成DNA内核就像一个DNA复制工厂，但是与主DNA内核不同的是，他可以并有权限去整合并记录很多个“DNA流[ZY13] ”，并使用类似“病毒”的超速进化方式，加速进化并大规模淘汰，这种方式与遗传算法不同，是非定向不可控的指数级进化，因此“淘汰”至关重要，而且对于DNA以基因突变为主：先随机一个子代，然后做淘汰检验，这样就加速了“进化”，培养出更智能的超级服务端的人机交互功能。<br> <strong>技术难点</strong>：类似于加入随机化的遗传算法[ZY14] 。</p></li><li><p>通信内核：<br> 通信内核由很多功能包[ZY15] 间接的组成一个通信子系统，而通信内核就是直接控制各个功能包，同时它被主DNA内核直接控制，并无选择的执行主DNA内核的各种指令，指令被接受后，通信内核就并行的控制和协调各个功能包，因此它的主要算法是并行计算和懒惰计算。并行计算是对于网络端子的协调，懒惰计算则是协调问题的主要手段。<br> <strong>技术难点</strong>：并行计算，懒惰计算。</p></li><li><p>必要存储内核：<br> IIRoom的客户端存储不再是重点，因此本内核主要用于服务端。内部组织采用仿生学原理，模仿人脑中枢神经的类神经的网络，与自身主内核的DNA匹配，采用动态自增自删减的神经元存储模式。用“立体”数据模式存储，相比传统介质有海量提升。存储时数据结构使用B树，AVL和线段树。B树与AVL决定存储的结构，而线段树对神经元做了抽象，专门存储一段“神经区域[ZY16] ”的地址。这样，可以很高效的存取数据，时间复杂度对于各个操作均为O(logN).<br> <strong>技术难度</strong>：AVL，B树，线段树。</p></li><li><p>*硬件层(Not important)：<br> <strong>kinect</strong>:主要的输入设备。抛弃键盘鼠标等传统输入设备。<br> <strong>＊全息投影仪</strong>：它们将被安装在空间区域里的各个角落，每一个投影仪都通过若干个投影灯泡进行照射，使光线发生干涉或衍射，最终生成3D立体影像。每一个投影仪都被系统同步并接受来自于系统的最新动态数据，投影出最实时的动态场景。理论上讲，全息投影仪的空间分布设计、个数与质量、投影仪上的投影灯泡个数与质量（颜色范围和照射路程）和真实空间（包括被虚拟的空间）的情况会影响投影质量，但是GUI层会智能调节至用户希望的最佳画质。这个硬件支持第三方产家的研发和生产，用户可有多种选择。</p><p> <strong>＊全息声音收录及虚拟设备</strong>：可以与全息投影仪合为一体进行全息声音收录和虚拟，也提供用户机会取购买第三方生产的具有更强大功能的全息声音收录及虚拟设备，以自我设计更加合理的位置，使收录和虚拟效果更加舒适。它们将被安装在空间的各个方位形成比一般单方位设备更加立体环绕效果。这个硬件支持第三方产家的研发和生产，有利于把全息声音功能发挥得淋漓尽致。</p><p> <strong>超级计算机</strong>：作为区域服务端和总超级服务端的服务器，有强大的计算功能和海量存储功能，能对内核文件进行高密度智能管理和更新，并与网络全时段同步，进行高流量的输入与输出操作。</p><p> <strong>带宽</strong>：10G/bps的基本要求到100G/bps或以上的推荐要求，便可满足对各种数据和“脑波”的传输，大大降低网络延迟值，使得同步实时场景时流畅无阻，清晰。</p><p> <strong>体感接收设备</strong>：首先，全息摄影仪传输的信息流到了系统内核中是会进行一次分辨并把人体动作信息流感应出来，把它从总的信息流分离出来做动作分析并进行反馈到GUI上，这是最基本的体感接收。而体感接收设备可由第三方开发和生产，以适应客户的各种不同需求，如大型全息游戏，残疾人辅助体感设备，专业人士专用体感设备等，只要在保证设备与系统同步良好的状况下，几乎可以完成任何的体感接收。</p><p> <strong>*技术难点</strong>：以上难点均为物理层面，我们不过多分析，仅知目前都可行，并已有相关技术即可。</p></li></ol><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol><li>《算法导论》  作者： （美）科曼（Cormen,T.H.） 等著</li><li>《数据结构与算法分析(C++描述)》 作者：(美)(MarkAllenWeiss)维斯</li><li>《操作系统:精髓与设计原理》 斯托林斯(William Stallings) (作者)</li><li>《计算机组成及汇编语言原理》 卓拉(Patrick Juola) (作者)</li><li>《计算机网络与因特网》 Douglas E.Comer (作者)</li><li>《算法:C语言实现(第5部分)图算法》 塞奇威克(Robert Sedgewick) (作者)</li><li>《计算机程序设计艺术（1-3卷）》 作者：Donald E. Knuth</li><li>计算机图形学相关书籍</li><li>GNU协议</li></ol><h4 id="法律支持与运营体制"><a href="#法律支持与运营体制" class="headerlink" title="法律支持与运营体制"></a>法律支持与运营体制</h4><p>本软件完全原创，符合当地法律标准与GNU协议，技术完全自主开创，没有任何侵权行为。IIRoom版权及最终解释权归5th Planet所有，侵权必究。</p><p>运营时，IIRoom的客服端完全免费，但不开源，不可复制[ZY17] ，我方保留版权。用户只需要购买硬件设备即可。收入来源依靠广告和第三方，并掌管超级服务端等[ZY18] 。用户对于IIRoom无需支付升级等任何费用，同时第三方也有免费和收费服</p><p>[ZY1] IIRoom的主要记录与传递信息流的文件制式。<br>[ZY2] 写系统的主要语言<br>[ZY3] 服务端必要语种<br>[ZY4] 写底层部件的<br>[ZY5] AC-自动机基于Knuth等的KMP算法实现，本质上类似于Trie与KMP的结合。<br>[ZY6] 均为多串的模式匹配，具有很高的效率。<br>[ZY7] 非二叉的堆，效果远优于二项。<br>[ZY8] IIRoom中的专属信息流。<br>[ZY9] 这种权值是局部随机，整体满足树结构层次关系的。<br>[ZY10] HLPP在实际操作时不一定比ISAP快（我本人亲自验证过，并做过相关报道），但是预流不得不说是个好办法。<br>[ZY11] 在GUI层已经抽象好的数据。<br>[ZY12] 即只能控制其他内核和处理信息，不能控制输入输出设备，不能直接与网络交互等。<br>[ZY13] “脑波”的子系。<br>[ZY14] 原创算法，是遗传算法的改进版本。<br>[ZY15] 具体请见网络层的各种功能包。<br>[ZY16] 数据的子段。<br>[ZY17] 用户需要注册，注册后将记录个人信息，不得随意拷贝。<br>[ZY18] 详见《创意设计简介》开发模式与管理模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全名：Intelligent Interaction Room&lt;br&gt;Writer：钟王偲 Z.Y.&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="技术可行性分析" scheme="http://izhen.me/tags/%E6%8A%80%E6%9C%AF%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90/"/>
    
      <category term="IIROOM" scheme="http://izhen.me/tags/IIROOM/"/>
    
  </entry>
  
  <entry>
    <title>IIROOM创意简介</title>
    <link href="http://izhen.me/2011/11/18/iiroom_intro/"/>
    <id>http://izhen.me/2011/11/18/iiroom_intro/</id>
    <published>2011-11-17T19:17:14.000Z</published>
    <updated>2018-09-27T14:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>团队：5th Planet</p><p>从只能用灯泡显示数字，用打孔纸带传递信息的“老爷”计算机，到现在成熟的网络化的多媒体的含有先进体感的各种类型的计算机和平板电脑。我们越来越高效的使用20世纪最伟大的发明来辅助我们完成各种工作和挑战。同时操作模式也愈来愈方便，甚至超乎想象。从人类本能的角度讲,没有学习过计算机操作，一般是不会使用甚至精通计算机的。庆幸的是随着技术的发展，交互性的提高，从原本MS-DOS时代复杂繁琐的命令行，到Windows图形化界面只用点点鼠标，再到ipad触触屏幕就可行的高效的用户体验。我们一次又一次的简化我们的交互操作，而且也越来越依靠无所不在，无所不离的互联网。</p><a id="more"></a><p>但是，现有产品仍然不能满足人类的“自然”需求。我们更想看到实物，这样才能察觉是否合适，而不是枯燥的文字，和永远看不到背面的2D图片。或者依据你的个人喜好和习惯，智能“组织”一个最适合你的绘图软件进行全体感的绘画。这些可以都在你的家庭，教室，场馆等等小空间内进行，于是，下一代全方位体感交互式OS即将诞生。</p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>你除了用过鼠标、键盘、触摸屏、手柄、操控杠，还用过更有新意的操作辅助工具吗？IIRoom简化了操作这一功能，实现智能化语音和手势等体感操作，让用户的操作体验更直接更方便！</p><p><strong>★智能语音操作</strong>：“给我一句像样点的命令，我就可以为您服务。”IIRoom的智能语音系统融合了多国语言及多地区方言，用户可以在初次使用时选择并加载。只要告诉系统你需要什么，系统可以通过智能搜索给你提供你希望的服务。当然，你也可以让系统虚拟出一名秘书，亲切地问你：“主人，您需要什么”。</p><p><strong>★残疾人辅助操作</strong>：假如用户不擅长说话？假如他耳朵有点背？假如他是一位手语者？那么IIRoom可以扫描你写在纸上的命令，为你提供更大音量，识别手语，甚至判断你是不是假装脑残乱发命令。</p><p><strong>★动作操作</strong>：这不能不说是IIRoom的一大卖点，试过招招手就可以使远处的物体飞到你面前吗？就像《哈利波特》里的魔法一样，有时候连咒语也不需要，只是几个简单动作，就可以使虚拟场景角度变换，选择虚拟物体，使用并操控虚拟物体的各项功能，更改属性等。</p><p><strong>★记忆模式</strong>：不论对于那个操作方式，IIRoom都提供用户一个记忆模式的功能，可以记录用户的操作习惯和各种兴趣爱好，方便了用户操作性，让系统就像一个熟悉你的各种习惯的助理一样！比如“Come on，Alice”是把虚拟的秘书调出来，右手打响指是调出菜单。</p><h4 id="网络模块"><a href="#网络模块" class="headerlink" title="网络模块"></a>网络模块</h4><p>IIRoom的网络模块是系统整体架构的核心，其中又包含服务端的模块与终端的模块。首先IIRoom的通用服务流是一系列传输流簇，他们对于不同信息的传输有不同的制式，但满足统一的“脑波”标准，使得我们能够既避免不同信号的干扰，又能对相同的信息方便的整合，这样也提高了信息安全性。整个模块由“IIRoom通用云”支撑，下面我们具体介绍服务端模块和终端模块。</p><p>服务端模块是负责各个终端或服务端之间沟通的必须，有2级组成：超级服务端，区域服务端。超级服务端使用巨型机甚至超级计算机组建，目的在于先前所陈述的：存储大量的高度加密的用户信息，负责组建安全的虚拟网络通道，传送支持与总体管理等。同时它拥有专属的“IIRoom-集成DNA”内核，这种内核可以收集用户终端的可以公开的，非私密的DNA重组信息和反馈，并汇集信息，进行自我反馈和改良，而在各个超级服务终端之间构成专属的类神经的网络通路，加强交流。超级服务端是管理权限最大终端，拥有直接管理区域服务端和用户终端的权力。</p><p>区域服务端提供具体服务和在线软件，可以由第三方提供，服务器类型没有限制。区域服务端也是“脑波”最大发射端，无论是购物，会议，即时通讯，在线软件，均可以由区域服务端来负责。区域服务端对于超级服务端是透明的，对于用户端没有直接管理的权限，且每次与用户端发生会话，必须经由超级服务端批准。区域服务端不具备特殊“DNA内核”，内核情况与用户端类似，但是拥有专属的高带宽，超线程的虚拟“脑波”路径的扩展权限。</p><p>所有服务端和终端均不可离开IIRoom通用云，云也是IIRoom的存在环境。服务端，用户端共同组成云，因此也有共同的“DNA云”，DNA云实时代表了当现的IIRoom“最聪明”的一刻，也即对于用户可以分离出无尽多个独立的大脑。</p><h4 id="DNA-amp-内核模块"><a href="#DNA-amp-内核模块" class="headerlink" title="DNA&amp;内核模块"></a>DNA&amp;内核模块</h4><p><strong>主DNA内核</strong>：这是用户端最重要的内核，它负责所有数据分析和DNA重组，智能自我改进等，其实这也是用户端的核心计算内核，之所以叫做DNA内核是由于他本身具有DNA自重组能力的特点决定。数据分析和计算是他的主要功能，也是IIRoom的“首脑”内核，它直接控制其他各个内核，且只能直接控制其他内核。其他各个内核将数据或操作计算请求，命令等交与主DNA内核，主DNA内核做作为中央领导其他内核完成各种任务。而对于主DNA内核，他所具备功能如下：收集数据（I/O，通信，DNA信息），处理命令，与其他内核内部交互，传达请求。同时也是唯一的具备自我DNA重组能力的内核。可以在不改变自己体系的情况下自由组织由DNA表达的功能。</p><p><strong>集成DNA内核</strong>：这是超级服务端才具有的内核，负责收集由用户“脑波”的DNA反馈流，并智能分析集成新的自适应总DNA，以方便自我改进，帮助用户和区域服务端更好的用户体验，自我“进化”。而且通过通信有云层共享能力，是多个超级服务端并行扩大能力。把这种共同自改进的能力，称为“扩散波场”，只有超级服务端可以访问“扩散波场”，类似一个专属子网。</p><p><strong>必要存储内核</strong>：用户端本身除了备份资料外，无需存储内核，所以这里存储内核主要指各个服务端的内核。服务端需要存储大量的用户资料和终端软件，包括服务，因此存储内核在IIRoom为了迎合体制，与传统的存储模块做了改良，内部组织采用仿生学原理，模仿人脑中枢神经的类神经的网络，与自身主内核的DNA匹配，采用动态自增自删减的神经元存储模式。网络中用“立体”数据模式存储，相比传统介质有海量提升。</p><h4 id="IIRoom用户开发体制"><a href="#IIRoom用户开发体制" class="headerlink" title="IIRoom用户开发体制"></a>IIRoom用户开发体制</h4><ul><li>IIRoom的用户开发体制相当于用户有权也有能力自主创造一款最有个性化的，最适合自己的虚拟空间。在区域服务端上，第三方开发商已经制作并上载了大量的虚拟模板供用户免费或者付费使用，但最让人心动的还是IIRoom的用户自主开发，既可以虚拟自己定义的最舒适场景，而且还可以上载到区域用户端上与他人共享，或作为自定义的东西保存在用户的保密数据库中，随时调用。</li></ul><h4 id="EXAMPLE"><a href="#EXAMPLE" class="headerlink" title="EXAMPLE"></a>EXAMPLE</h4><p><img src="/image/iiroom/2.jpeg" alt="IIROOM"></p><p>作为工程师的你在某一个晚上突然有了灵感，一个无比美妙的建筑结构。可是要怎样快速地描述它呢？</p><p><img src="/image/iiroom/1.jpeg" alt="IIROOM"></p><p>是用笔画下来？还是用电脑制作？不，太慢了。灵感稍纵即逝。不想让你的灵感淹没在大量准备工作中？IIROOM绝对可以帮你的忙。</p><p><img src="/image/iiroom/3.jpeg" alt="IIROOM"></p><p>过程十分简单，通过你喜爱的指令方式调出绘图软件。不同于以往的，IIROOM为你提供全新的3D绘图软件。你可以在一个空间上作画，而这个空间完全由你自己设计。很想看看图片的背面？不仅是背面，任意平面你都可以用手轻轻一挥而达成构造和旋转。完成后可将作品或其它信息存入服务端的存储内核，再次使用时调出即可。除此之外，对于部分官方软件（第三方收费软件预计不具有此种功能），DNA内核可以根据你的要求综合多个绘图软件的功能，比如你分别喜欢A和B软件的某些功能，IIROOM就可以为你把两个软件的不同模块进行重组来满足你的需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;团队：5th Planet&lt;/p&gt;
&lt;p&gt;从只能用灯泡显示数字，用打孔纸带传递信息的“老爷”计算机，到现在成熟的网络化的多媒体的含有先进体感的各种类型的计算机和平板电脑。我们越来越高效的使用20世纪最伟大的发明来辅助我们完成各种工作和挑战。同时操作模式也愈来愈方便，甚至超乎想象。从人类本能的角度讲,没有学习过计算机操作，一般是不会使用甚至精通计算机的。庆幸的是随着技术的发展，交互性的提高，从原本MS-DOS时代复杂繁琐的命令行，到Windows图形化界面只用点点鼠标，再到ipad触触屏幕就可行的高效的用户体验。我们一次又一次的简化我们的交互操作，而且也越来越依靠无所不在，无所不离的互联网。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="IIROOM" scheme="http://izhen.me/tags/IIROOM/"/>
    
  </entry>
  
  <entry>
    <title>Hanoi Tower</title>
    <link href="http://izhen.me/2011/10/29/hanoi/"/>
    <id>http://izhen.me/2011/10/29/hanoi/</id>
    <published>2011-10-29T04:48:02.000Z</published>
    <updated>2018-09-23T07:33:49.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在19世纪有一种hanoi游戏，游戏的装置是一块铜板，上面有三根金刚石的针，针上放着从小到达64个盘子。游戏的目标是从一根针上移到另一根针上，还有一个针作为中间过渡。游戏规定每次只能够动一个盘子，而且大盘子永远在小盘子下面。问题： 由于移动的次数太多，标志着世界末日的到来，所以计算机不要求你计算如此多的移动方式，只要你可以算出7以内即可,<br>输入n =3   输出：A-&gt;C A-&gt;B  C-&gt;B  A-&gt;C  B-&gt;A  B-&gt;C  A-&gt;C</p><a id="more"></a><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>我们考虑一般的情况：如果想将n个盘子从a移动到c,可以划分阶段，先将n-1个盘子从a通过c移动到b,然后将a中剩下的一个盘子移动到c,最后再将n-1个盘子从b通过a移动到c。这样本来是n个盘子的问题，变成了与n-1个盘子有关的问题。所以本题可以使用递归，重复这个过程，每次n减1，直到n=1时，直接移动盘子就可以了。</p><p><img src="/image/hanoi.png" alt="Hanoi Tower"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //这道题目很基础，只是大学学C语言，于是我就把它翻出来了。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> a,<span class="keyword">char</span> b,<span class="keyword">char</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    move(n,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> a,<span class="keyword">char</span> b,<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">"-&gt;"</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        move(n<span class="number">-1</span>,a,c,b);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">"-&gt;"</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        move(n<span class="number">-1</span>,b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;在19世纪有一种hanoi游戏，游戏的装置是一块铜板，上面有三根金刚石的针，针上放着从小到达64个盘子。游戏的目标是从一根针上移到另一根针上，还有一个针作为中间过渡。游戏规定每次只能够动一个盘子，而且大盘子永远在小盘子下面。问题： 由于移动的次数太多，标志着世界末日的到来，所以计算机不要求你计算如此多的移动方式，只要你可以算出7以内即可,&lt;br&gt;输入n =3   输出：A-&amp;gt;C A-&amp;gt;B  C-&amp;gt;B  A-&amp;gt;C  B-&amp;gt;A  B-&amp;gt;C  A-&amp;gt;C&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="hanoi" scheme="http://izhen.me/tags/hanoi/"/>
    
  </entry>
  
  <entry>
    <title>转：科学家的小故事</title>
    <link href="http://izhen.me/2011/10/05/scientists/"/>
    <id>http://izhen.me/2011/10/05/scientists/</id>
    <published>2011-10-05T12:19:46.000Z</published>
    <updated>2018-09-23T07:22:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>伊藤清（Kiyoshi Ito）是当代最伟大的数学家之一。他将微积分方法扩展到随机过程，建立了伊藤微积分。该方法被广泛应用到随机微分方程、金融数学等领域。我在日本京都大学读本科生时，正值伊藤先生从京大退休。去聆听了他的<strong>最终讲义</strong>。伊藤先生报告的结束语让我至今记忆犹新。他说：“我做数学，是因为数学太有趣了。”全场响起了经久不息的掌声。</p><a id="more"></a><p>笛阿孔尼斯(Persi Diaconis)是著名的统计学家。他14岁开始当魔术师，18岁时买了一本概率书，发现根本读不懂，于是24岁时开始在夜校学习数学。后来他在哈佛大学拿到数学博士，成为斯坦福大学教授，还当上了美国科学院院士。笛阿孔尼斯的一个著名研究成果是他证明洗扑克牌七次才能洗干净，不愧是魔术师出身的数学家。听过笛阿孔尼斯的关于排序学习的讲演。印象深的是他很投入，讲演中会时不时地闭上眼睛，完全进入自己的世界。</p><p>Leo Breiman是杰出的统计学家，曾发明CART与Bagging算法。Breiman认为现在的数学教育大多是失败的。重要的是要让孩子们喜欢数学，因为数学是非常有趣的。他曾亲自去小学五年级教数学。Breiman生前回忆那段经历时说：“我们一起做了各种游戏。他们在游戏中学习了解析几何、代数以及其他各种复杂的东西。”</p><p>Peter Bartlett创立了学习泛化能力的分析手法，是机器学习理论的领军人物。Peter的机器学习讲义思路清晰、证明严谨、叙述简明，读起来让人觉得是一种享受。有一次，Peter儿子的学校请他给小学生们讲一堂课，内容是微积分！他说花了很大功夫备课，但也可见他理论功底之深。 </p><p>Ross Quinlan 2011年获得了数据挖掘领域最高荣誉奖KDD创新奖。十多年前听过Quinlan先生的报告。即将结束时，一位听众冒昧地问：“什么是方差？”这位相貌酷似林肯的澳大利亚绅士耐心地解释说：“我不是统计学家。方差是…”八十年代末九十年代初，当人们还在用手工的方法构建专家系统时，Quinlan发明了著名决策树学习算法ID3、C4.5，闯出一条数据驱动、统计学习的新路，实在难能可贵。</p><p>Michael Jordan是机器学习领域最有影响的学者之一，贝叶斯学习的代表人物。Jordan培养出了许多优秀的学生，他和学生们做的许多工作都是里程碑性的。Jordan并不出身于名校，但是靠自己的聪明才智与刻苦努力，成为MIT、伯克利的教授，2011年还当选为美国科学院院士。Jordan多年来养成了一个习惯，晚上就寝前一定读一篇论文。</p><p>Rakesh Agrawal提出了许多数据挖掘的重要概念与方法，例如关联规则挖掘算法。他说：“我做研究选题时一定考虑会不会对十年以后产生影响。”有一次陪他去北京一家餐厅吃饭。刚进门，就见他放慢了脚步，像小孩一样好奇地探着头，凑到旁边的玻璃柜前。原来那里摆着许多穿着民族服装的玩偶。Rakesh在那儿端详了半天，用带着印度口音的英语说：“It is nice”，脸上露出了开心的笑容。像许多科学家一样，Rakesh也是一个精力旺盛，充满好奇心的人。</p><p>Robert Schapire因为发明了著名的机器学习算法AdaBoost与Yoav Freund一起获得了计算理论界最高奖歌德尔奖。我曾问Rob：“你们当初是怎么想到AdaBoost的？”他的回答非常简单：“因为我们之前证明了可以把弱分类器提升为强分类器，所以后来就想到了AdaBoost。”好像一切都在情理之中。他的表情也像平时一样从容淡定。一流科学家思想都达到了极高境界，很多发明发现都是他们通过自然推理，而非灵光一现，产生出来的。</p><p>有人说爱德华·威滕（Edward Witten）是有史以来最伟大的理论物理学家，还有人说他是当今的爱因斯坦。威滕建立和发展了诸多物理学理论，特别是弦理论（string theory）。他曾撰写了两百多篇论文，在物理学中论文引用H指数排名第一。他获得过多个大奖，包括数学的菲尔兹奖。威滕思维敏捷，经常会思若泉涌，想出很多idea。正因如此，他也从不吝惜自己的idea，只将最好的idea付诸于研究。他说：“我年轻的时候，每天早上起来都会有一种感觉，今天会有从来没有过的好idea。”[1] </p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>曾经有同学问我：“做一个好的科学家需要有什么样的素质？” 从以上的小故事中，我们或许可以总结出一些：</p><ul><li>酷爱研究</li><li>勤奋好学</li><li>思想深刻</li><li>想象丰富</li><li>功底扎实</li><li>为人谦和</li></ul><p>我接触过许多世界一流的科学家，他们几乎无一例外。 分享一点体会，愿与大家共勉。 </p><p>参考文献 [1] The Puzzle of Genius, Newsweek 1993.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;伊藤清（Kiyoshi Ito）是当代最伟大的数学家之一。他将微积分方法扩展到随机过程，建立了伊藤微积分。该方法被广泛应用到随机微分方程、金融数学等领域。我在日本京都大学读本科生时，正值伊藤先生从京大退休。去聆听了他的&lt;strong&gt;最终讲义&lt;/strong&gt;。伊藤先生报告的结束语让我至今记忆犹新。他说：“我做数学，是因为数学太有趣了。”全场响起了经久不息的掌声。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="maths" scheme="http://izhen.me/tags/maths/"/>
    
  </entry>
  
  <entry>
    <title>很久不更新了</title>
    <link href="http://izhen.me/2011/09/28/no_more_update/"/>
    <id>http://izhen.me/2011/09/28/no_more_update/</id>
    <published>2011-09-28T07:12:38.000Z</published>
    <updated>2018-09-23T07:30:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近也没什么事情，不想为了更新而更新，因为刚刚拾起来一些东西，况且最近条理不过来，值得说的，真是不多。而且上课要交的作业都交不利索，有时找不到网站，社团也时不时的有很多无聊的事情。老师上课随便那么一通灌，然后走人，课本是留给自己自学的，老师把要你自学的东西再琐碎讲上两句。这样我对课程什么的不期待了，特别是要找准自己感兴趣的东西去自学。很多时候突然想去一个很有意思的博客上看看，或者说一个非常好的资源网站上学习，感到某方面欠缺是常有的事情。</p><a id="more"></a><p>而现在在这究竟也说不出什么。特别是很久不编程了，连最基本的都忘干净了。必须要去拾起来，从C到C++，再到Java，我还想研究一下会汇编着，总觉得是非常有用的，对于底层的实现更是感兴趣；又不能放下原理，再到应用、设计。很多事情可以去做，没事做很不幸的，有事就去吧。一个月再回来，希望这里能至少多一些题解。</p><p>================================ 我是很久的分割线 ============================</p><p>从这一篇以前的博客文章时间都是不对的，我们的时区是UTC+8，之前一直没设置是UTC+0，所以要想计算我的真正发布时间需要+8。以后的Blog就都改过来了。</p><p>注：时区是之前Wordpress的设置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近也没什么事情，不想为了更新而更新，因为刚刚拾起来一些东西，况且最近条理不过来，值得说的，真是不多。而且上课要交的作业都交不利索，有时找不到网站，社团也时不时的有很多无聊的事情。老师上课随便那么一通灌，然后走人，课本是留给自己自学的，老师把要你自学的东西再琐碎讲上两句。这样我对课程什么的不期待了，特别是要找准自己感兴趣的东西去自学。很多时候突然想去一个很有意思的博客上看看，或者说一个非常好的资源网站上学习，感到某方面欠缺是常有的事情。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="update blog" scheme="http://izhen.me/tags/update-blog/"/>
    
  </entry>
  
  <entry>
    <title>Android SDK的Eclipse配置，刷GMS，改Hosts手札</title>
    <link href="http://izhen.me/2011/07/13/android_host/"/>
    <id>http://izhen.me/2011/07/13/android_host/</id>
    <published>2011-07-13T06:17:53.000Z</published>
    <updated>2018-09-23T08:15:11.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h4><p>写下这个是因为我最初的目的并不是一次把这些都配置好，我只是对Google+感兴趣，于是仅仅打算Hosts之，可以正常登陆，结果一波三折，我先Root了Android 2.2.2，接着安装并调配了JDK、Android SDK、Eclipse，并且刷了GMS，还知道了怎么用Root Explorer…得到的远远大于我的预期，在此写下这个手札。仅供新手参考。</p><a id="more"></a><h4 id="环境以及软件"><a href="#环境以及软件" class="headerlink" title="环境以及软件"></a>环境以及软件</h4><ul><li>手机：MOTO ME811</li><li>Windows 7 64bit</li><li>Android 2.2.2(国行)</li><li>相应的 USB device</li><li>Root Explorer （简称RE）</li><li>Terminal emulator(可以用adb代替，简称TE)</li><li>Gingerbreak 1.2 .apk(Z4root也可以)</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>首先使用Gingerbreak将Android Root掉，这时取得了权限，细节是要将Superuser(骷髅标志)的通知打开，免得以后SU不了。然后下载安装各种SDK（文件路径不可以有空格，后文详解和Eclipse。完成后要配置环境变量，对于Java SE有三个：<code>PATH=&lt;jdk&gt;/bin;%PATH%，CLASSPATH=.%CLASSPATH%，JAVA_HOME=&lt;jdk&gt;</code>。然后是Android SDK,就只有PATH,把tools和platform_tools加进去即可。</p><p>接着要用Eclipse安装ADT，在help选择install new software，点击ADD…加入新的网址<code>&lt;a href=&quot;https://dl-ssl.google.com/android/eclipse/&quot;&gt;https://dl-ssl.google.com/android/eclipse/&lt;/a&gt;</code>，然后安装，有了这个才能使用eclipse开发Android程序，然后在windows里配置preferences找到Android ,设置SDK location不然无法使用AVD调试。</p><p>在手机上装载TE和RE，在re里有一个按钮可以更改权限，改为RW然后就能改hosts了！（大功告成）。使用re还可以删除需要root的软件，在app文件夹里。</p><h4 id="其他刷机事项"><a href="#其他刷机事项" class="headerlink" title="其他刷机事项"></a>其他刷机事项</h4><p>使用adb获得权限：打开cmd 键入adb shell，接着出现$,键入su，在手机中选择允许，出现#。表明成功获得权限，这时使用mount命令可以更改文件权限，删除软件等等，在手机里就是te可以完成同样的功能。</p><p>其实开发时可以使用AVD调试，这是一个模拟器，在eclipse的windows菜单里，点开明显的AVD之类的选项，然后NEW配置，配置好后就可以用这个模拟终端了，但是记住Android SDK的安装路径不可以有空格，不然无法开启AVD!在建立好一个Android项目后就可以使用AVD模拟，方式是在run选项中，配置run configurations,在target选项中选中你建立的模拟器即可。</p><p>国行要想使用Android Market必须要刷机，有一种简单的方法只把GMS刷进去，首先下载GMS的zip包，更名为update.zip，然后放置在sd卡根目录下，关机，按住房子键或者返回键（视不同手机而定）再按开机键，看到三角和机器人界面即可，接着按住音量+和相机进入recovery界面，选择sd card相关的选项开始安装，成功后重启，重启后会有一系列的Google账户配置，这时即使是国行也有google的服务啦！</p><p><del>GMS的刷机包和Gingerbreak已经放在博客主页的“共享文件”链接中了。</del></p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>想不到收获不小，在此感谢H4x教我如何改hosts，Fritz_Li帮我解答了一些疑难问题，这样才能很好的完成上述配置。最好从android.com上找到你相应机型的USB驱动装上，希望其中的细节能够对新手有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;心路历程&quot;&gt;&lt;a href=&quot;#心路历程&quot; class=&quot;headerlink&quot; title=&quot;心路历程&quot;&gt;&lt;/a&gt;心路历程&lt;/h4&gt;&lt;p&gt;写下这个是因为我最初的目的并不是一次把这些都配置好，我只是对Google+感兴趣，于是仅仅打算Hosts之，可以正常登陆，结果一波三折，我先Root了Android 2.2.2，接着安装并调配了JDK、Android SDK、Eclipse，并且刷了GMS，还知道了怎么用Root Explorer…得到的远远大于我的预期，在此写下这个手札。仅供新手参考。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="android" scheme="http://izhen.me/tags/android/"/>
    
      <category term="GMS" scheme="http://izhen.me/tags/GMS/"/>
    
      <category term="hosts" scheme="http://izhen.me/tags/hosts/"/>
    
      <category term="刷机" scheme="http://izhen.me/tags/%E5%88%B7%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>轻时代</title>
    <link href="http://izhen.me/2011/07/08/light_age/"/>
    <id>http://izhen.me/2011/07/08/light_age/</id>
    <published>2011-07-07T18:58:03.000Z</published>
    <updated>2018-09-23T16:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开篇，其实我也不是具体知道什么是轻时代，不能对“轻”下具体的定义，“轻”时代也是我个人浅薄的看法。但是这是着实存在于我们身边的并且已经渗透于我们生活之中的。当互联网跨入Web 2.0 时开始，博客得到普及，社交网络应运而生，我们的通讯手段，社交深度与广度都发生着颠覆性的变化，好像是从博客开始，那时我对社交网络还没什么兴趣，现在也基本是。。。不过目前对Google+产生了浓厚的兴趣，可以的话希望能体验一下。。。后来社交平台广泛流行，人们也更加追求更快，更便利，更“轻”的新环境与新事物。</p><p>在这样的大背景下，智能手机、3G、微博等等相继出现，“轻”时代到来，尽管某些事物的出现让人们鄙夷，但是时代的变迁是无法改变的，就好比曾经有一位IT业的名人，他认为博客这种东西不过是昙花一现，可当他开始写上自己的博客时，便欲罢不能，一发不可收拾。写到这里我想起了一位著名科技杂志的编辑，他老人家曾经多次预测IT业的发展，并且全部估对，这其中就有互联网的走向，以及我还清晰记得的他对于蜜蜂的观测——蜜蜂的群体行为一定能产生新的可以应用于未来新事物的的仿生学科技，结果不出所料，Google公司发布的Android 3.0智能设备系统就是运用了蜂巢算法。</p><p>那么，这与“轻”时代有什么关系？这难道不就是“轻”时代的脊梁吗。有了诸如智能手机，平板电脑等便携设备（记得之前还有上网本），加上配得上这样设备的智能系统，IOS也好，Android也好，WP也罢，系统本身的重要性稍微有点模糊了，就好比人们购买这样的一个设备，所关注的重点不再单单是系统的功能是否足够复杂，是否有足够多的功能；而是他的扩展性，他的应用。这些扩展应用强化了系统本身的那点简单功能，体系发达的发布平台，数量成千上万的应用，高度可开发性。能充分满足客户的需求，而他们共同的特性就是“轻”，设备轻，软件“轻”，开发周期“轻”。比较明显的就是苹果目前的轻周期，平均每10个月左右就会有新的产品发布，尽管带来了一些小小的问题，不过整体却推进了硬件“轻”更新周期。不管过快的更新会带来什么，也不管究竟之后还有什么新花样，这样的生活似乎就是“轻”节奏，“轻”发展。</p><p>然后一切“轻”化，“微”博，“轻”博客（目前不太流行）。这样的轻，避开了繁杂，抛弃了华章藻饰，人们每一言一语是更加的“生活”，而不是浮躁而华丽的抒情散文，微博使得彼此之间的交流更加纯粹，不“化妆”，不“打扮”，就是最自然最美的素颜。微博的交流也想比较更大幅度的跨越了一个界限，公开的短信，公开的自由，我觉得这是微博比社交网络更有优势的一点。</p><p>我想在最后谈谈“轻”软件，所谓“轻”软件就是小软件，在软件这个概念尚未形成之前就有了，不过此“轻”非彼“轻”；这个“轻”蕴含着高效，短周期，低成本，但是并不意味着功能差，相反，恰恰是由于他的作用领域，也更加体现了他在“轻”时代的“重”量级地位；试想作为大部分非专业编辑，非专业版式设计的我们，对于一个字处理软件有多大的需求，是否真的有时间还要对一个到手的文档费时费力去排版，那么一个1G的优秀编辑器对于我们来说是多么的“低效”，或许5M的轻型便携设备文档软件就足够，那么至此就可以理解“轻”时代的“轻”需求了吧。</p><p>当然这个时代刚刚才开始了几年，多说无益，何况也没能从专业角度去看待，只是说我浅薄的看法对于这个时代是积极的。“轻”时代的意义重大，并且已经在多个领域起到了重要作用，或许很有可能是下一个时代“超集成”时代的铺垫与基础呢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开篇，其实我也不是具体知道什么是轻时代，不能对“轻”下具体的定义，“轻”时代也是我个人浅薄的看法。但是这是着实存在于我们身边的并且已经渗透于我们生活之中的。当互联网跨入Web 2.0 时开始，博客得到普及，社交网络应运而生，我们的通讯手段，社交深度与广度都发生着颠覆性的变
      
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="移动互联网" scheme="http://izhen.me/tags/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>IDEALNOVA Tester V0.16 Beta</title>
    <link href="http://izhen.me/2011/06/29/idealnova_tester/"/>
    <id>http://izhen.me/2011/06/29/idealnova_tester/</id>
    <published>2011-06-28T21:26:07.000Z</published>
    <updated>2018-09-23T08:35:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>大概是两年前，也就是2009年高一下学期的暑假，我开发了这个测试器，初衷是因为cena不兼容win vista/7,而且当时的也找不着好使的，就随便写了个仅仅够测试时间的这个测试器，后来逐步完善了一点点的功能，所以在此就发布这个版本的可执行程序和源代码。当然这是个开源软件，或者说小程序吧。</p><a id="more"></a><p>使用时务必要设定一大堆配置，非常抱歉这个程序使用起来还不是很便利，具体都在使用手册里说明了，而这个文件的还有程序的地址就在这个博客主页右边栏的</p><p>这个<a href="https://izhen.me/lab/timetester.zip">链接</a>里可以找到。这里就重点说说程序的输入输出格式吧:</p><p><img src="/image/idealnova/necklace.png" alt="项链工厂"></p><p>如图这是noi2007的项链工厂，因为程序设计的原因，输入输出务必使用文件，输入输出名也务必是test.in/test.out。</p><p>下面是运行效果：</p><p><img src="/image/idealnova/tester016.png" alt="Tester"></p><p>=============================== 我是分割线 ================================</p><p><del>我开通了这个网站的邮局，所以如果没有附件的话，仅仅是为了同我交流，可以发送邮件到<a href="mailto:idealchild@idealnova.net" target="_blank" rel="noopener">idealchild@idealnova.net</a></del></p><p><img src="/image/idealnova/mail-1024x537.png" alt="Mailbox"></p><p>就是这样的界面，也没什么功能。</p><p>P.S.对于测试器来说，THU的胡伟栋曾开发了伟栋清橙测试器，使用方便，大家可以去试试看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是两年前，也就是2009年高一下学期的暑假，我开发了这个测试器，初衷是因为cena不兼容win vista/7,而且当时的也找不着好使的，就随便写了个仅仅够测试时间的这个测试器，后来逐步完善了一点点的功能，所以在此就发布这个版本的可执行程序和源代码。当然这是个开源软件，或者说小程序吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="OI" scheme="http://izhen.me/tags/OI/"/>
    
      <category term="tester" scheme="http://izhen.me/tags/tester/"/>
    
      <category term="c++" scheme="http://izhen.me/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>好了，履行了约定移植完成</title>
    <link href="http://izhen.me/2011/06/28/migration/"/>
    <id>http://izhen.me/2011/06/28/migration/</id>
    <published>2011-06-28T07:07:43.000Z</published>
    <updated>2018-09-23T08:54:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要是把我原来的博客（百度空间）上的一些还好的解题报告给移植了过来。</p><a id="more"></a><p>很多没用的都删掉了，如果你想要我相对完整的usaco题解，前四章（截止到2011-7）可以联系我。</p><p>现在的日志开始同步更新了。</p><p><img src="/image/idealnova/blog.jpg" alt="Wordpress Blog"></p><p>============================= 不久前的分割线 ==================================</p><p>突然回忆起2010在北京的10天，那是我高中最快乐的日子。。。认识了小旻，打打，小凯。。。留下很多带不走的回忆。</p><p>我的计算机也换了三代，这也是有深远意义的，还记得第一次学习编程用的那台含超线程技术的P4 2.4GHz的TCL计算机，以及令人难以忘怀的极品飞车：地下车会，那是极品飞车目前为止最好的一作了。学习Basic，还有邀请我的好朋友来我家玩游戏都是使用这台机子。用了5年。</p><p>第二台也就是我的上一台DELL，处理器是：Intel Core 2 Q6600。学习Pascal，C++就是用的这台了，也是我真正步入OI领域时使用的机子。主要的记忆也许就是一堆一堆的代码了。。。</p><p>现在手上这台是：Sony VAIO SD，处理器是i系列。</p><p>其实对于编程者来说，机子都是我们最好的朋友，有时并不只是简单的工具，她所凝聚的或许还有更多，诸如曾经的拼搏回忆，诸如儿时的游戏时光，诸如曾经陪伴你的心酸。。。</p><p>就到这里了吧，从今往后就要有新的开始了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是把我原来的博客（百度空间）上的一些还好的解题报告给移植了过来。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="blog" scheme="http://izhen.me/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>ABOUT ME</title>
    <link href="http://izhen.me/2011/06/18/about_me/"/>
    <id>http://izhen.me/2011/06/18/about_me/</id>
    <published>2011-06-18T04:56:56.000Z</published>
    <updated>2018-09-23T09:05:25.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="BASIC-INFORMATION"><a href="#BASIC-INFORMATION" class="headerlink" title="BASIC INFORMATION"></a>BASIC INFORMATION</h4><p>ID ：IDEALNOVA<br>星座：白羊<br>身材：偏骷髅<br>语种：中文，英文，C++，Pascal，Basic……<br>QQ：1225212168<br>年龄：92年生人</p><a id="more"></a><p>I LIKE THE THINGS LIKE THESE…传说中的美味，c++，汇编，java，肉类，鱼类，应用数学，近代物理，游戏，最终幻想，极品飞车，算法，数据结构，朴素，网络流，线段树，平衡树，各种堆，配对堆，二项堆，斐波那契堆，动态规划，状态压缩，单调队列，平行四边形不等式，缩图，计算几何，单纯型，dinic，ISAP，费用流，多重DP，数论，图灵模型，冯氏模型，最短路，搜索，迭代加深，懒惰计算，康拓展开，做美梦，高等数学，离散数学，拓扑，复分析，微电子，计算机硬件，高科技，sony，IBM，intel，谷歌，养生。。。</p><p>I DISLIKE THE THINGS LIKE THESE…咸的食物，没有水，各种猥琐字符串，各种猥琐代码题，无端的虚伪，无端的自私，被发现。。。，无聊的课，失去自由，生活在水深火热之中，做噩梦，受伤。。。，各种潮湿，各种细菌，通宵，各种吧，各种歌舞厅，痛苦回忆。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;BASIC-INFORMATION&quot;&gt;&lt;a href=&quot;#BASIC-INFORMATION&quot; class=&quot;headerlink&quot; title=&quot;BASIC INFORMATION&quot;&gt;&lt;/a&gt;BASIC INFORMATION&lt;/h4&gt;&lt;p&gt;ID ：IDEALNOVA&lt;br&gt;星座：白羊&lt;br&gt;身材：偏骷髅&lt;br&gt;语种：中文，英文，C++，Pascal，Basic……&lt;br&gt;QQ：1225212168&lt;br&gt;年龄：92年生人&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="me" scheme="http://izhen.me/tags/me/"/>
    
  </entry>
  
  <entry>
    <title>备案成功</title>
    <link href="http://izhen.me/2011/04/23/backup/"/>
    <id>http://izhen.me/2011/04/23/backup/</id>
    <published>2011-04-22T21:45:00.000Z</published>
    <updated>2018-09-23T09:04:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天工信部的通信管理局终于发来ICP备案成功的消息（之前失败了一次。。。），时间是2011-6-8-17:25:18</p><p>以此为纪念，我宣布本Blog正式建立</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天工信部的通信管理局终于发来ICP备案成功的消息（之前失败了一次。。。），时间是2011-6-8-17:25:18&lt;/p&gt;
&lt;p&gt;以此为纪念，我宣布本Blog正式建立&lt;/p&gt;

      
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="备案" scheme="http://izhen.me/tags/%E5%A4%87%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>APIO2007风铃</title>
    <link href="http://izhen.me/2010/06/26/APIO2007/"/>
    <id>http://izhen.me/2010/06/26/APIO2007/</id>
    <published>2010-06-25T21:38:37.000Z</published>
    <updated>2018-09-23T15:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>本<a href="https://www.luogu.org/problemnew/show/P3621" target="_blank" rel="noopener">题目</a>的程序实现并不困难，算法整体也相当容易，主要的坎坷就是考虑问题的全面性。事实上，题目的很多限定让程序的实现更接近DP，所以我们可以借助树状DP的思想来分析题目。首先我们按照程序实现的顺序逐一分析：</p><a id="more"></a><ol><li>不合法：分析题目，最大层次只能差1，因而这是一个完全二叉树，所以凡是不满足的均要输出-1；当左右子树的节点深度差均为1时，也不可能满足，输出-1.</li><li>在合法的前提下：计数需要几种情况：<ol><li>右子树的节点深度差值为1，则向右迭代转化为子问题，不计数。</li><li>左子树的最小深度浅于右子树的最大深度，向左迭代，计数。</li><li>不满足2的情况下，如果左子树自身的深度不一样，向左迭代，不计数。<br>以上3条就包含所有情况了。</li></ol></li><li>对于深度，只需记录一个子树的最浅和最深即可，用DFS可以很简单的得到。</li></ol><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p><img src="/image/idealnova/apio2007.jpg" alt="APIO 2007 - 风铃"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> dp[BIG][<span class="number">2</span>],dep[BIG][<span class="number">2</span>],n,tot,ult;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deep</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> lev)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lev&gt;ult) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(index==<span class="number">0</span>) &#123;</span><br><span class="line">    dep[index][<span class="number">0</span>]=dep[index][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!deep(dp[index][<span class="number">0</span>],lev+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(!deep(dp[index][<span class="number">1</span>],lev+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> l=dp[index][<span class="number">0</span>],r=dp[index][<span class="number">1</span>];</span><br><span class="line">  dep[index][<span class="number">0</span>]=MAX(dep[l][<span class="number">0</span>],dep[r][<span class="number">0</span>])+<span class="number">1</span>;</span><br><span class="line">  dep[index][<span class="number">1</span>]=MIN(dep[l][<span class="number">1</span>],dep[r][<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">  <span class="comment">//如果不成立</span></span><br><span class="line">  <span class="keyword">if</span>(dep[dp[index][<span class="number">0</span>]][<span class="number">0</span>]-dep[dp[index][<span class="number">0</span>]][<span class="number">1</span>]&gt;<span class="number">0</span> &amp;&amp; dep[dp[index][<span class="number">1</span>]][<span class="number">0</span>]-dep[dp[index][<span class="number">1</span>]][<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    tot=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//左子树需要旋转</span></span><br><span class="line">  <span class="keyword">if</span>(dep[dp[index][<span class="number">0</span>]][<span class="number">1</span>] &lt; dep[dp[index][<span class="number">1</span>]][<span class="number">0</span>])&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    <span class="keyword">if</span>(!work(dp[index][<span class="number">0</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dep[dp[index][<span class="number">0</span>]][<span class="number">1</span>] &lt; dep[dp[index][<span class="number">0</span>]][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span>(!work(dp[index][<span class="number">0</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//右子树需要旋转</span></span><br><span class="line">  <span class="keyword">if</span>(dep[dp[index][<span class="number">1</span>]][<span class="number">1</span>] &lt; dep[dp[index][<span class="number">1</span>]][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span>(!work(dp[index][<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;dp[i][<span class="number">0</span>]&gt;&gt;dp[i][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(dp[i][<span class="number">0</span>]==<span class="number">-1</span>) dp[i][<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">if</span>(dp[i][<span class="number">1</span>]==<span class="number">-1</span>) dp[i][<span class="number">1</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ult=(<span class="keyword">int</span>)log2(n)+<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(!deep(<span class="number">1</span>,<span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(dep[<span class="number">1</span>][<span class="number">0</span>]-dep[<span class="number">1</span>][<span class="number">1</span>]&gt;<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> work(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt; tot &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>考虑要全面。</p><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>Middle Up(提高+/省选-)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;本&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3621&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目&lt;/a&gt;的程序实现并不困难，算法整体也相当容易，主要的坎坷就是考虑问题的全面性。事实上，题目的很多限定让程序的实现更接近DP，所以我们可以借助树状DP的思想来分析题目。首先我们按照程序实现的顺序逐一分析：&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="DP" scheme="http://izhen.me/tags/DP/"/>
    
      <category term="Tree" scheme="http://izhen.me/tags/Tree/"/>
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>NOI2008志愿者招募</title>
    <link href="http://izhen.me/2010/04/27/NOI2008/"/>
    <id>http://izhen.me/2010/04/27/NOI2008/</id>
    <published>2010-04-26T21:39:37.000Z</published>
    <updated>2018-09-24T05:55:11.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p><a href="https://www.luogu.org/problemnew/show/P3980" target="_blank" rel="noopener">题目</a>可以使用费用流建模 (费用流得实现细节就不说了 )，下面是一个常用的建模方式：首先按照天数从源到汇依次建立 S-&gt;1-&gt;2……N-&gt;N+1-&gt;T。也就是多加入一个点。他们的费用均为0，如图所示，第N天的流量就是 (MAX-第 N天的需求量 )。然后如果有一种雇员从 (x到 y)可以服务，那么连接 (x到 y+1),流量是 MAX,费用为雇佣花费。这样建模的大致思路大家应该已经明白：按照时间发展顺序，顺流而下。当我们选用一个雇员时，若覆盖 [x,y]天，那么自然就是连边 [x,y+1]只有这样才能保证当前的流量可以允许这些天都得到服务。那么为什么对呢？首先最大流一定是 MAX.因为这是最小割，而任何割集都不会小于这个割，所以就拿第一天来说，如果第一天最后求得的流量恰好是： (MAX-N[1])，一定有N[1] 的流量通过别的途径走了，而且对于第一天这个节点的最大流不可能超过 (MAX-N[1]),也就是说别的途径至少会有 N[1]个流量，而别的流量就是延伸出的包含费用的流，就是雇佣花费。也就符合了题目要求：第 1天的雇佣下限是 N[1].由此限制流量来满足题目要求。这样的方法利用的是补集的思想。</p><a id="more"></a><p><img src="/image/idealnova/noi2008.png" alt="费用流模型"></p><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p><img src="/image/idealnova/noi2008.jpg" alt="NOI 2008 - 志愿者招募"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG 40005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> x,y,cap,cost;</span><br><span class="line">    edge *next,*target;</span><br><span class="line">    edge()&#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c,<span class="keyword">int</span> co,edge *n):x(x),y(y),cap(c),cost(co),next(n),target(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>,<span class="keyword">void</span> *ptr)</span></span>&#123;<span class="keyword">return</span> ptr;&#125;</span><br><span class="line">&#125;*EDGE[BIG];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> source=BIG<span class="number">-2</span>,sink=BIG<span class="number">-1</span>,<span class="built_in">queue</span>[BIG],lev[BIG],dist[BIG],MAXTOT,n,m,num;</span><br><span class="line">edge *Stack[BIG],*Path[BIG];</span><br><span class="line"><span class="keyword">bool</span> qin[BIG];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">FindMincost</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tail=<span class="number">1</span>,head=<span class="number">0</span>,now=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(qin,<span class="number">0</span>,<span class="keyword">sizeof</span>(qin));</span><br><span class="line">    <span class="built_in">memset</span>(lev,<span class="number">-1</span>,<span class="keyword">sizeof</span>(lev));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) dist[i]=MAX;</span><br><span class="line">dist[sink]=MAX;</span><br><span class="line">    lev[source]=<span class="number">0</span>;</span><br><span class="line">    dist[source]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>[tail]=source;</span><br><span class="line">    qin[source]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head&lt;tail)&#123;</span><br><span class="line">        now=<span class="built_in">queue</span>[++head];</span><br><span class="line">        qin[now]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(edge *e=EDGE[now];e;e=e-&gt;next)</span><br><span class="line">        <span class="keyword">if</span>(e-&gt;cap!=<span class="number">0</span> &amp;&amp; dist[now]+e-&gt;cost&lt;dist[e-&gt;y])&#123;</span><br><span class="line">            dist[e-&gt;y]=dist[now]+e-&gt;cost;</span><br><span class="line">            lev[e-&gt;y]=lev[now]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!qin[e-&gt;y]) &#123;<span class="built_in">queue</span>[++tail]=e-&gt;y;qin[e-&gt;y]=<span class="number">1</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dist[sink]!=MAX);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FindMaxFlow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> Lpath=<span class="number">1</span>,record,delta,top=source;</span><br><span class="line">    <span class="built_in">memcpy</span>(Stack,EDGE,<span class="keyword">sizeof</span>(EDGE));</span><br><span class="line">    <span class="keyword">while</span>(top&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sink==top)&#123;</span><br><span class="line">            delta=MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;Lpath;i++)</span><br><span class="line">            <span class="keyword">if</span>(delta&gt;Path[i]-&gt;cap)&#123;</span><br><span class="line">                delta=Path[i]-&gt;cap;</span><br><span class="line">                record=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;Lpath;i++)&#123;</span><br><span class="line">                Path[i]-&gt;cap-=delta;</span><br><span class="line">                Path[i]-&gt;target-&gt;cap+=delta;</span><br><span class="line">                MAXTOT+=Path[i]-&gt;cost*delta;</span><br><span class="line">            &#125;</span><br><span class="line">            Lpath=record;</span><br><span class="line">            top=Path[Lpath]-&gt;x;</span><br><span class="line">        &#125;</span><br><span class="line">        edge *temE;</span><br><span class="line">        <span class="keyword">for</span>(temE=Stack[top];temE;temE=temE-&gt;next)</span><br><span class="line">            <span class="keyword">if</span>(temE-&gt;cap!=<span class="number">0</span> &amp;&amp; lev[top]+<span class="number">1</span>==lev[temE-&gt;y] &amp;&amp; dist[top]+temE-&gt;cost==dist[temE-&gt;y]) <span class="keyword">break</span>;</span><br><span class="line">        Stack[top]=temE;</span><br><span class="line">        <span class="keyword">if</span>(temE)&#123;</span><br><span class="line">            Path[Lpath++]=temE;</span><br><span class="line">            top=temE-&gt;y;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            lev[top]=<span class="number">-1</span>;</span><br><span class="line">            dist[top]=MAX;</span><br><span class="line">            <span class="keyword">if</span>(Lpath==<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">            top=Path[--Lpath]-&gt;x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BuildEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> cap,<span class="keyword">int</span> cost)</span></span>&#123;</span><br><span class="line">    edge *tempEDGE=<span class="keyword">new</span> edge[<span class="number">3</span>];</span><br><span class="line">    EDGE[x]=<span class="keyword">new</span>((<span class="keyword">void</span> *)tempEDGE++) edge(x,y,cap,cost,EDGE[x]);</span><br><span class="line">    EDGE[y]=<span class="keyword">new</span>((<span class="keyword">void</span> *)tempEDGE++) edge(y,x,<span class="number">0</span>,-cost,EDGE[y]);</span><br><span class="line">    EDGE[x]-&gt;target=EDGE[y];</span><br><span class="line">    EDGE[y]-&gt;target=EDGE[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    BuildEdge(source,<span class="number">1</span>,MAX,<span class="number">0</span>);</span><br><span class="line">    BuildEdge(n+<span class="number">1</span>,sink,MAX,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">        BuildEdge(i,i+<span class="number">1</span>,MAX-num,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;num;</span><br><span class="line">        BuildEdge(x,y+<span class="number">1</span>,MAX,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(FindMincost())FindMaxFlow();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; MAXTOT &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>MAX的下界：Sigma(需求量[i]) (1&lt;=i&lt;=n); 就是每天的需求量之和。</p><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>Hard down(NOI)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3980&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目&lt;/a&gt;可以使用费用流建模 (费用流得实现细节就不说了 )，下面是一个常用的建模方式：首先按照天数从源到汇依次建立 S-&amp;gt;1-&amp;gt;2……N-&amp;gt;N+1-&amp;gt;T。也就是多加入一个点。他们的费用均为0，如图所示，第N天的流量就是 (MAX-第 N天的需求量 )。然后如果有一种雇员从 (x到 y)可以服务，那么连接 (x到 y+1),流量是 MAX,费用为雇佣花费。这样建模的大致思路大家应该已经明白：按照时间发展顺序，顺流而下。当我们选用一个雇员时，若覆盖 [x,y]天，那么自然就是连边 [x,y+1]只有这样才能保证当前的流量可以允许这些天都得到服务。那么为什么对呢？首先最大流一定是 MAX.因为这是最小割，而任何割集都不会小于这个割，所以就拿第一天来说，如果第一天最后求得的流量恰好是： (MAX-N[1])，一定有N[1] 的流量通过别的途径走了，而且对于第一天这个节点的最大流不可能超过 (MAX-N[1]),也就是说别的途径至少会有 N[1]个流量，而别的流量就是延伸出的包含费用的流，就是雇佣花费。也就符合了题目要求：第 1天的雇佣下限是 N[1].由此限制流量来满足题目要求。这样的方法利用的是补集的思想。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="Graph" scheme="http://izhen.me/tags/Graph/"/>
    
      <category term="NetFlow" scheme="http://izhen.me/tags/NetFlow/"/>
    
      <category term="费用流" scheme="http://izhen.me/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
      <category term="NOI" scheme="http://izhen.me/tags/NOI/"/>
    
  </entry>
  
  <entry>
    <title>NOI2006最大获利-最大权闭合子图</title>
    <link href="http://izhen.me/2010/04/25/NOI2006/"/>
    <id>http://izhen.me/2010/04/25/NOI2006/</id>
    <published>2010-04-24T21:39:37.000Z</published>
    <updated>2018-09-24T05:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>首先按照<a href="https://www.luogu.org/problemnew/show/P4174" target="_blank" rel="noopener">题目</a>要求先建立二分图：左边是用户点，右边是通讯站，并给他们附上权值为正无穷。然后右边的点向超级汇连边，权值为中转站的花费。超级源向左边的点连边，权值是获利。然后求出最大流。这个最大流的含义是：因为最大流 = 最小割。中间部分的边容量是正无穷不会被割开，而只会割开源与汇的边，也就是（不打算纳入获利的值 + 建一部分通讯站的费用），因为是最小割，所以保证这样的耗费最小，也就是说这是我们不需要的值。因此最终结果是：可获利的总权值 -最大流。</p><a id="more"></a><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p><img src="/image/idealnova/noi2006.jpg" alt="NOI 2006 - 最大获利"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG 400005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 99999999</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,cap;</span><br><span class="line">    edge *next,*target;</span><br><span class="line">    edge()&#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> cap,edge *next):x(x),y(y),cap(cap),next(next),target(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>,<span class="keyword">void</span> *ptr)</span></span>&#123;<span class="keyword">return</span> ptr;&#125;</span><br><span class="line">&#125;*EDGE[BIG];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> source=BIG<span class="number">-2</span>,sink=BIG<span class="number">-1</span>,<span class="built_in">queue</span>[BIG],Dist[BIG],n,m,MAXTOT;</span><br><span class="line">edge *Stack[BIG],*Path[BIG];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">LabelFlowDist</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> tail=<span class="number">1</span>,head=<span class="number">0</span>,now;</span><br><span class="line">    <span class="built_in">memset</span>(Dist,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Dist));</span><br><span class="line">    Dist[source]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>[tail]=source;</span><br><span class="line">    <span class="keyword">while</span>(head&lt;tail)&#123;</span><br><span class="line">        now=<span class="built_in">queue</span>[++head];</span><br><span class="line">        <span class="keyword">for</span>(edge *e=EDGE[now];e;e=e-&gt;next)</span><br><span class="line">        <span class="keyword">if</span>(e-&gt;cap!=<span class="number">0</span> &amp;&amp; Dist[e-&gt;y]==<span class="number">-1</span>)&#123;</span><br><span class="line">            Dist[e-&gt;y]=Dist[e-&gt;x]+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">queue</span>[++tail]=e-&gt;y;</span><br><span class="line">            <span class="keyword">if</span>(e-&gt;y==sink) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FindMaxFlow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> top=source,record,delta,Lpath=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(Stack,EDGE,<span class="keyword">sizeof</span>(EDGE));</span><br><span class="line">    <span class="keyword">while</span>(top&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sink==top)&#123;</span><br><span class="line">            delta=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;Lpath;i++)</span><br><span class="line">            <span class="keyword">if</span>(delta&gt;Path[i]-&gt;cap)&#123;</span><br><span class="line">                delta=Path[i]-&gt;cap;</span><br><span class="line">                record=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;Lpath;i++)&#123;</span><br><span class="line">                Path[i]-&gt;cap-=delta;</span><br><span class="line">                Path[i]-&gt;target-&gt;cap+=delta;</span><br><span class="line">            &#125;</span><br><span class="line">            Lpath=record;</span><br><span class="line">            top=Path[Lpath]-&gt;x;</span><br><span class="line">            MAXTOT+=delta;</span><br><span class="line">        &#125;</span><br><span class="line">        edge *temE;</span><br><span class="line">        <span class="keyword">for</span>(temE=Stack[top];temE;temE=temE-&gt;next)</span><br><span class="line">            <span class="keyword">if</span>(temE-&gt;cap!=<span class="number">0</span> &amp;&amp; Dist[temE-&gt;y]==Dist[top]+<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        Stack[top]=temE;</span><br><span class="line">        <span class="keyword">if</span>(temE)&#123;</span><br><span class="line">            Path[Lpath++]=temE;</span><br><span class="line">            top=temE-&gt;y;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Dist[top]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(Lpath==<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">            top=Path[--Lpath]-&gt;x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">long</span> A,B,num,TOTAL=<span class="number">0</span>,M;</span><br><span class="line">    edge *tempEDGE=<span class="keyword">new</span> edge[BIG*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">        EDGE[i]=<span class="keyword">new</span>((<span class="keyword">void</span>*)tempEDGE++) edge(i,sink,num,EDGE[i]);</span><br><span class="line">        EDGE[sink]=<span class="keyword">new</span>((<span class="keyword">void</span>*)tempEDGE++) edge(sink,i,<span class="number">0</span>,EDGE[sink]);</span><br><span class="line">        EDGE[i]-&gt;target=EDGE[sink];</span><br><span class="line">        EDGE[sink]-&gt;target=EDGE[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A&gt;&gt;B&gt;&gt;num;</span><br><span class="line">        TOTAL+=num;</span><br><span class="line">        M=i+n;</span><br><span class="line">        EDGE[source]=<span class="keyword">new</span>((<span class="keyword">void</span>*)tempEDGE++) edge(source,M,num,EDGE[source]);</span><br><span class="line">        EDGE[M]=<span class="keyword">new</span>((<span class="keyword">void</span>*)tempEDGE++) edge(M,source,<span class="number">0</span>,EDGE[M]);</span><br><span class="line">        EDGE[M]-&gt;target=EDGE[source];</span><br><span class="line">        EDGE[source]-&gt;target=EDGE[M];</span><br><span class="line">        EDGE[M]=<span class="keyword">new</span>((<span class="keyword">void</span>*)tempEDGE++) edge(M,A,MAX,EDGE[M]);</span><br><span class="line">        EDGE[A]=<span class="keyword">new</span>((<span class="keyword">void</span>*)tempEDGE++) edge(A,M,<span class="number">0</span>,EDGE[A]);</span><br><span class="line">        EDGE[M]-&gt;target=EDGE[A];</span><br><span class="line">        EDGE[A]-&gt;target=EDGE[M];</span><br><span class="line">        EDGE[M]=<span class="keyword">new</span>((<span class="keyword">void</span>*)tempEDGE++) edge(M,B,MAX,EDGE[M]);</span><br><span class="line">        EDGE[B]=<span class="keyword">new</span>((<span class="keyword">void</span>*)tempEDGE++) edge(B,M,<span class="number">0</span>,EDGE[B]);</span><br><span class="line">        EDGE[M]-&gt;target=EDGE[B];</span><br><span class="line">        EDGE[B]-&gt;target=EDGE[M];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(LabelFlowDist()) FindMaxFlow();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;TOTAL-MAXTOT&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>Middle Up(NOI)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;首先按照&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4174&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目&lt;/a&gt;要求先建立二分图：左边是用户点，右边是通讯站，并给他们附上权值为正无穷。然后右边的点向超级汇连边，权值为中转站的花费。超级源向左边的点连边，权值是获利。然后求出最大流。这个最大流的含义是：因为最大流 = 最小割。中间部分的边容量是正无穷不会被割开，而只会割开源与汇的边，也就是（不打算纳入获利的值 + 建一部分通讯站的费用），因为是最小割，所以保证这样的耗费最小，也就是说这是我们不需要的值。因此最终结果是：可获利的总权值 -最大流。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="Graph" scheme="http://izhen.me/tags/Graph/"/>
    
      <category term="NetFlow" scheme="http://izhen.me/tags/NetFlow/"/>
    
      <category term="费用流" scheme="http://izhen.me/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
      <category term="NOI" scheme="http://izhen.me/tags/NOI/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.3.5 Game1</title>
    <link href="http://izhen.me/2010/04/18/usaco_335/"/>
    <id>http://izhen.me/2010/04/18/usaco_335/</id>
    <published>2010-04-18T15:39:27.000Z</published>
    <updated>2018-09-30T06:24:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>首次遇到博弈问题，分析问题给定一个序列{num1,num2,num3……numN}两个人分别从左右以最佳策略取值，找到第一个人的可能最大值。那么我们把问题划分得小一点得知，当前的最佳策略相当于分别选择左右两边的数字加上剩下的决策序列中的最大的。因此具备最优子结构，可以拆分为小问题解决。又因为只有两个人所以知道了一个人的状态就一定知道另一个人的。用DP[i][j]表示区间 [i,j]第一个人的最佳策略。边界条件 DP[i][i]=num[i];状态转移方程:DP[i][j]=MAX{num[i]+sum[i+1][j]-DP[i+1][j],num[j]+sum[i][j-1]-DP[i][j-1]}; 根据分析不难理解本方程。不过需要从小的区间往大的区间计算。</p><p>关于原理：因为当第一个人选择最左边时从(左+1)向后它就作为后手了，而第二个人作为先手，因此从(左+1)向后第二个人是先手，他此时的决策相当于第一个人，根据方程的意义，第一个人在余下序列的最值就是从(左+1)向后的总合，减去第二个人作为先手的最优决策。(^o^)</p><a id="more"></a><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>Compiling…<br>Compile: OK<br>Executing…<br>   Test 1: TEST OK [0.000 secs, 2968 KB]<br>   Test 2: TEST OK [0.011 secs, 2968 KB]<br>   Test 3: TEST OK [0.000 secs, 2968 KB]<br>   Test 4: TEST OK [0.032 secs, 2968 KB]<br>   Test 5: TEST OK [0.000 secs, 2968 KB]<br>   Test 6: TEST OK [0.000 secs, 2968 KB]<br>   Test 7: TEST OK [0.011 secs, 2968 KB]<br>   Test 8: TEST OK [0.011 secs, 2968 KB]<br>   Test 9: TEST OK [0.022 secs, 2968 KB]<br>   Test 10: TEST OK [0.000 secs, 2968 KB]<br>   Test 11: TEST OK [0.000 secs, 2968 KB]<br>   Test 12: TEST OK [0.011 secs, 2968 KB]<br>   Test 13: TEST OK [0.000 secs, 2968 KB]<br>   Test 14: TEST OK [0.022 secs, 2968 KB]<br>   Test 15: TEST OK [0.011 secs, 2968 KB]<br>   Test 16: TEST OK [0.000 secs, 2968 KB]</p><p>All tests OK.<br>YOUR PROGRAM (‘game1’) WORKED FIRST TIME! That’s fantastic<br>– and a rare thing. Please accept these special automated<br>congratulations.</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span> <span class="params">(<span class="string">"game1.out"</span>,ios::out)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span> <span class="params">(<span class="string">"game1.in"</span>,ios::in)</span></span>;</span><br><span class="line"><span class="keyword">long</span> sum[<span class="number">101</span>],n,dp[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fin&gt;&gt;dp[i][i];</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+dp[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-k;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=i+k;j++)</span><br><span class="line">                dp[i][j]=MAX(sum[j]-sum[i<span class="number">-1</span>]-dp[i+<span class="number">1</span>][j],sum[j]-sum[i<span class="number">-1</span>]-dp[i][j<span class="number">-1</span>]);</span><br><span class="line">    fout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt; <span class="string">' '</span>&lt;&lt;sum[n]-dp[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本文是百度空间的移植，附：全部<a href="https://github.com/i-zhen/USACO-training" target="_blank" rel="noopener">USACO题目解答</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;首次遇到博弈问题，分析问题给定一个序列{num1,num2,num3……numN}两个人分别从左右以最佳策略取值，找到第一个人的可能最大值。那么我们把问题划分得小一点得知，当前的最佳策略相当于分别选择左右两边的数字加上剩下的决策序列中的最大的。因此具备最优子结构，可以拆分为小问题解决。又因为只有两个人所以知道了一个人的状态就一定知道另一个人的。用DP[i][j]表示区间 [i,j]第一个人的最佳策略。边界条件 DP[i][i]=num[i];状态转移方程:DP[i][j]=MAX{num[i]+sum[i+1][j]-DP[i+1][j],num[j]+sum[i][j-1]-DP[i][j-1]}; 根据分析不难理解本方程。不过需要从小的区间往大的区间计算。&lt;/p&gt;
&lt;p&gt;关于原理：因为当第一个人选择最左边时从(左+1)向后它就作为后手了，而第二个人作为先手，因此从(左+1)向后第二个人是先手，他此时的决策相当于第一个人，根据方程的意义，第一个人在余下序列的最值就是从(左+1)向后的总合，减去第二个人作为先手的最优决策。(^o^)&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="DP" scheme="http://izhen.me/tags/DP/"/>
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="Game Theory" scheme="http://izhen.me/tags/Game-Theory/"/>
    
  </entry>
  
  <entry>
    <title>USACO 4.3.2 Prime3</title>
    <link href="http://izhen.me/2010/04/06/usaco_432/"/>
    <id>http://izhen.me/2010/04/06/usaco_432/</id>
    <published>2010-04-06T15:39:27.000Z</published>
    <updated>2018-09-30T06:23:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>这是一个比较优秀的枚举搜索题目。所用策略：构造 + 二分 + 枚举 + 剪枝。</p><p>其实题目本身不难，我的方法是：先构造出所有要用到的素数，然后在这个已经压缩的状态空间中枚举。因为素数构造好了，所以检索一个数字是否是素数时可以直接二分。搜索时先要搜对角线，然后有两个顺序去继续搜索： A，由内到外； B，由外到内。事实上对于这道题目，可以进行最大限度的剪枝才是好的顺序，所以综合考虑 B是更好的选择。</p><a id="more"></a><p><img src="/image/idealnova/432.jpg" alt="USACO 4.3.2"></p><p>剪枝策略：(以下剪枝缺一不可)</p><ol><li>素数与加和判断。 </li><li>起始不为 0的判断。 </li><li>末尾为奇判断。</li></ol><p>总结，事实上我这样做并不能加快程序的速度，唯一的优点是空间小(对于 C++)，以及编程的难度小(虽然长，但是很好写，至少循环层次很少)。另外我做了A顺序的程序，第三个点就达到13s！如有兴趣参观我的第一个程序可以联系我。</p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>Compiling…<br>Compile: OK<br>Executing…<br>   Test 1: TEST OK [0.119 secs, 2972 KB]<br>   Test 2: TEST OK [0.140 secs, 2972 KB]<br>   Test 3: TEST OK [0.151 secs, 2972 KB]<br>   Test 4: TEST OK [0.238 secs, 2972 KB]<br>   Test 5: TEST OK [0.227 secs, 2972 KB]<br>   Test 6: TEST OK [0.637 secs, 2972 KB]<br>   Test 7: TEST OK [0.637 secs, 2972 KB]<br>   Test 8: TEST OK [0.799 secs, 2972 KB]<br>   Test 9: TEST OK [1.220 secs, 2972 KB]<br>   Test 10: TEST OK [1.696 secs, 2972 KB] //我感觉我的程序是以时间换空间 = =|||<br>All tests OK.</p><p>Your program (‘prime3’) produced all correct answers! This is your<br>submission #3 for this problem. Congratulations!</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG 1005</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> LIE = <span class="literal">true</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">6</span>],val;</span><br><span class="line">&#125;pri[BIG];</span><br><span class="line"><span class="keyword">int</span> K1,Lenp,TOTAL,FIRST,ranc[<span class="number">6</span>][<span class="number">6</span>],RANC[BIG][<span class="number">6</span>][<span class="number">6</span>],outtot,multi[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">10000</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">checkprime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;prime)</span></span>&#123; <span class="comment">//二分法查找</span></span><br><span class="line">    <span class="keyword">if</span>(!(prime&amp;<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">1</span>,right=Lenp,mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prime&gt;pri[mid].val)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">            mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">            mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(prime==pri[left].val) <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> &amp;lie, <span class="keyword">const</span> <span class="keyword">int</span> &amp;pos,<span class="keyword">const</span> <span class="keyword">int</span> &amp;len)</span></span>&#123; <span class="comment">//求和函数</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(lie) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) sum+=ranc[i][pos];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) sum+=ranc[pos][i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> &amp;lie, <span class="keyword">const</span> <span class="keyword">int</span> &amp;pos)</span></span>&#123; <span class="comment">//求数字的函数</span></span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(lie) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) num+=ranc[i][pos]*multi[<span class="number">6</span>-i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) num+=ranc[pos][i]*multi[<span class="number">6</span>-i];</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> &amp;lie, <span class="keyword">const</span> <span class="keyword">int</span> &amp;wh,<span class="keyword">const</span> <span class="keyword">int</span> &amp;pos)</span></span>&#123; <span class="comment">//求数字的函数</span></span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(lie) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) num+=RANC[wh][i][pos]*multi[<span class="number">6</span>-i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) num+=RANC[wh][pos][i]*multi[<span class="number">6</span>-i];</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lastcheck</span><span class="params">()</span></span>&#123; <span class="comment">//可行性判断，并生成最终方案</span></span><br><span class="line">    <span class="keyword">int</span> TOT2,TOT3,TOT4,TOT5,TOT6;</span><br><span class="line">    TOT3=add(!LIE,<span class="number">2</span>,<span class="number">5</span>)-ranc[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    TOT4=add(!LIE,<span class="number">4</span>,<span class="number">5</span>)-ranc[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>(TOT3&gt;TOTAL || TOT4&gt;TOTAL ) <span class="keyword">return</span>;</span><br><span class="line">    ranc[<span class="number">2</span>][<span class="number">3</span>]=TOTAL-TOT3;ranc[<span class="number">4</span>][<span class="number">3</span>]=TOTAL-TOT4;</span><br><span class="line">    TOT2=multiply(LIE,<span class="number">3</span>);TOT4=multiply(!LIE,<span class="number">2</span>);</span><br><span class="line">    TOT5=multiply(!LIE,<span class="number">3</span>);TOT6=multiply(!LIE,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(!checkprime(TOT2) || !checkprime(TOT5) || !</span><br><span class="line">        checkprime(TOT4) || !checkprime(TOT6)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(RANC[++outtot],ranc, <span class="keyword">sizeof</span>(ranc));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">midpane2</span><span class="params">(<span class="keyword">int</span> lev)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lev&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        lastcheck();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(lev)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>):</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Lenp;i++)</span><br><span class="line">                <span class="keyword">if</span>(pri[i].num[<span class="number">1</span>]==ranc[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; pri[i].num[<span class="number">5</span>]==ranc[<span class="number">5</span>][<span class="number">1</span>]</span><br><span class="line">                &amp;&amp; pri[i].num[<span class="number">2</span>] &amp;&amp; pri[i].num[<span class="number">3</span>] &amp;&amp; pri[i].num[<span class="number">4</span>])&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i1=<span class="number">2</span>;i1&lt;=<span class="number">4</span>;i1++) ranc[i1][<span class="number">1</span>]=pri[i].num[i1];</span><br><span class="line">                    <span class="keyword">if</span>(!midpane2(lev+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>):</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Lenp;i++)</span><br><span class="line">                <span class="keyword">if</span>(pri[i].num[<span class="number">1</span>]==ranc[<span class="number">1</span>][<span class="number">5</span>] &amp;&amp; pri[i].num[<span class="number">5</span>]==ranc[<span class="number">5</span>][<span class="number">5</span>]</span><br><span class="line">                &amp;&amp; (pri[i].num[<span class="number">2</span>]&amp;<span class="number">1</span>) &amp;&amp; (pri[i].num[<span class="number">3</span>]&amp;<span class="number">1</span>) &amp;&amp; (pri[i].num[<span class="number">4</span>]&amp;<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i1=<span class="number">2</span>;i1&lt;=<span class="number">4</span>;i1++) ranc[i1][<span class="number">5</span>]=pri[i].num[i1];</span><br><span class="line">                    <span class="keyword">if</span>(!midpane2(lev+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">midpane1</span><span class="params">(<span class="keyword">int</span> lev)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lev&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> TOT1,TOT2; <span class="comment">//以下是可行性剪枝</span></span><br><span class="line">        TOT1=add(LIE,<span class="number">2</span>,<span class="number">5</span>)-ranc[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">        TOT2=add(LIE,<span class="number">4</span>,<span class="number">5</span>)-ranc[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">if</span>(TOT1&gt;TOTAL || TOT2&gt;TOTAL) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ranc[<span class="number">3</span>][<span class="number">2</span>]=TOTAL-TOT1;ranc[<span class="number">3</span>][<span class="number">4</span>]=TOTAL-TOT2;</span><br><span class="line">        TOT1=multiply(LIE,<span class="number">2</span>);TOT2=multiply(LIE,<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(!checkprime(TOT1) || !checkprime(TOT2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        midpane2(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(lev)&#123;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Lenp;i++)</span><br><span class="line">                <span class="keyword">if</span>(pri[i].num[<span class="number">1</span>]==ranc[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; pri[i].num[<span class="number">5</span>]==ranc[<span class="number">1</span>][<span class="number">5</span>]</span><br><span class="line">                &amp;&amp; pri[i].num[<span class="number">2</span>] &amp;&amp; pri[i].num[<span class="number">3</span>] &amp;&amp; pri[i].num[<span class="number">4</span>])&#123; <span class="comment">//对于开头是否是0要剪枝</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i1=<span class="number">2</span>;i1&lt;=<span class="number">4</span>;i1++) ranc[<span class="number">1</span>][i1]=pri[i].num[i1];</span><br><span class="line">                    <span class="keyword">if</span>(!midpane1(lev+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>):</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Lenp;i++)</span><br><span class="line">                <span class="keyword">if</span>(pri[i].num[<span class="number">1</span>]==ranc[<span class="number">5</span>][<span class="number">1</span>] &amp;&amp; pri[i].num[<span class="number">5</span>]==ranc[<span class="number">5</span>][<span class="number">5</span>]</span><br><span class="line">                &amp;&amp; (pri[i].num[<span class="number">2</span>]&amp;<span class="number">1</span>) &amp;&amp; (pri[i].num[<span class="number">3</span>]&amp;<span class="number">1</span>) &amp;&amp; (pri[i].num[<span class="number">4</span>]&amp;<span class="number">1</span>))&#123; <span class="comment">//末尾的剪枝：判断是不是奇数</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i1=<span class="number">2</span>;i1&lt;=<span class="number">4</span>;i1++) ranc[<span class="number">5</span>][i1]=pri[i].num[i1];</span><br><span class="line">                    <span class="keyword">if</span>(!midpane1(lev+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">crosspane</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Lenp;i++)</span><br><span class="line">        <span class="keyword">if</span>(pri[i].num[<span class="number">1</span>]==FIRST)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i1=<span class="number">1</span>;i1&lt;=<span class="number">5</span>;i1++) ranc[i1][i1]=pri[i].num[i1];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Lenp;j++)</span><br><span class="line">                <span class="keyword">if</span>(pri[j].num[<span class="number">3</span>]==ranc[<span class="number">3</span>][<span class="number">3</span>])&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j1=<span class="number">1</span>;j1&lt;=<span class="number">5</span>;j1++) ranc[j1][<span class="number">6</span>-j1]=pri[j].num[<span class="number">6</span>-j1]; <span class="comment">//以下是可行性剪枝，对于当前总和超过TOTAL的要剪掉</span></span><br><span class="line">                    <span class="keyword">if</span>(ranc[<span class="number">1</span>][<span class="number">1</span>]+ranc[<span class="number">1</span>][<span class="number">5</span>]&gt;TOTAL || ranc[<span class="number">1</span>][<span class="number">1</span>]+ranc[<span class="number">5</span>][<span class="number">1</span>]&gt;TOTAL || ranc[<span class="number">5</span>][<span class="number">1</span>]+ranc[<span class="number">5</span>][<span class="number">5</span>]&gt;TOTAL || ranc[<span class="number">1</span>][<span class="number">5</span>]+ranc[<span class="number">5</span>][<span class="number">5</span>]&gt;TOTAL ||</span><br><span class="line">                       ranc[<span class="number">2</span>][<span class="number">2</span>]+ranc[<span class="number">2</span>][<span class="number">4</span>]&gt;TOTAL || ranc[<span class="number">2</span>][<span class="number">2</span>]+ranc[<span class="number">4</span>][<span class="number">2</span>]&gt;TOTAL || ranc[<span class="number">4</span>][<span class="number">2</span>]+ranc[<span class="number">4</span>][<span class="number">4</span>]&gt;TOTAL || ranc[<span class="number">4</span>][<span class="number">4</span>]+ranc[<span class="number">4</span>][<span class="number">2</span>]&gt;TOTAL)</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                    midpane1(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;A, <span class="keyword">const</span> <span class="keyword">int</span> &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ma,mb;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        ma=multiply(!LIE,A,i);</span><br><span class="line">        mb=multiply(!LIE,B,i);</span><br><span class="line">        <span class="keyword">if</span>(ma&lt;mb) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(ma==mb) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span>(ma&gt;mb) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ranc[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;outtot;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=outtot-i;j++)</span><br><span class="line">            <span class="keyword">if</span>(cmp(j,j+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(ranc,RANC[j], <span class="keyword">sizeof</span>(RANC[j]));</span><br><span class="line">                <span class="built_in">memcpy</span>(RANC[j],RANC[j+<span class="number">1</span>], <span class="keyword">sizeof</span>(RANC[j+<span class="number">1</span>]));</span><br><span class="line">                <span class="built_in">memcpy</span>(RANC[j+<span class="number">1</span>],ranc, <span class="keyword">sizeof</span>(ranc));</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"prime3.in"</span>, <span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"prime3.out"</span>, <span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;TOTAL,&amp;FIRST);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10001</span>;i&lt;=<span class="number">99997</span>;i+=<span class="number">2</span>)&#123; <span class="comment">//提前构造出满足条件的素数</span></span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(i);j++) <span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;flag=<span class="literal">true</span> ;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">int</span> total=<span class="number">0</span>,k=i,num[<span class="number">6</span>],pos=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                num[<span class="number">6</span>-(++pos)]=k%<span class="number">10</span>;</span><br><span class="line">                total+=num[<span class="number">6</span>-pos];</span><br><span class="line">                k/=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(total==TOTAL)&#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(pri[++Lenp].num,num, <span class="keyword">sizeof</span>(num));</span><br><span class="line">                pri[Lenp].val=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    crosspane();</span><br><span class="line">    sort(); <span class="comment">//冒泡排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=outtot;k&gt;=<span class="number">1</span>;k--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)</span><br><span class="line">                <span class="built_in">printf</span>( <span class="string">"%d"</span>,RANC[k][i][j]);</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k!=<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!outtot) <span class="built_in">printf</span>( <span class="string">"NONE\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本文是百度空间的移植，附：全部<a href="https://github.com/i-zhen/USACO-training" target="_blank" rel="noopener">USACO题目解答</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;这是一个比较优秀的枚举搜索题目。所用策略：构造 + 二分 + 枚举 + 剪枝。&lt;/p&gt;
&lt;p&gt;其实题目本身不难，我的方法是：先构造出所有要用到的素数，然后在这个已经压缩的状态空间中枚举。因为素数构造好了，所以检索一个数字是否是素数时可以直接二分。搜索时先要搜对角线，然后有两个顺序去继续搜索： A，由内到外； B，由外到内。事实上对于这道题目，可以进行最大限度的剪枝才是好的顺序，所以综合考虑 B是更好的选择。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="DFS" scheme="http://izhen.me/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>NOI2003木棒游戏</title>
    <link href="http://izhen.me/2010/03/01/noi2003/"/>
    <id>http://izhen.me/2010/03/01/noi2003/</id>
    <published>2010-02-28T21:38:37.000Z</published>
    <updated>2018-09-23T17:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>我是使用朴素的方法做的(高深的我不会)，首先找到火柴棒间的对应关系，比如移动一根火柴可以将8变为0，等等，然后分为两种情况枚举：</p><ol><li>本身变动</li><li>两个数字一起变动</li></ol><p>当然这样枚举必定要TLE，所以先把整个式子提取出来(所以程序很长 ,其实后来我也有点看不懂了。。。)，这样变动数字进行计算的时候就不用每次把整个式子都算了</p><a id="more"></a><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p><img src="/image/idealnova/noi2003.jpg" alt="NOI 2003"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fin cin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fout cout</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> shizi[<span class="number">1001</span>],fh[<span class="number">600</span>],num[<span class="number">600</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> rel1[<span class="number">10</span>][<span class="number">10</span>],rel2[<span class="number">10</span>][<span class="number">10</span>],rel3[<span class="number">10</span>][<span class="number">10</span>],fuh1=<span class="literal">false</span>,fuh2=<span class="literal">false</span>;</span><br><span class="line">int64 cnum[<span class="number">600</span>],cheng[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">10000</span>,<span class="number">100000</span>,<span class="number">1000000</span>,<span class="number">10000000</span>,<span class="number">100000000</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len,f,mid1,tsz[<span class="number">1001</span>][<span class="number">2</span>];<span class="comment">//tsz is the num's position.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       int64 fl=cnum[<span class="number">1</span>],fr=cnum[mid1];</span><br><span class="line">       <span class="keyword">if</span>(fuh1) fl=-fl;</span><br><span class="line">       <span class="keyword">if</span>(fuh2) fr=-fr;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=mid1<span class="number">-1</span>;i++)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span>(fh[i<span class="number">-1</span>]==<span class="string">'+'</span>)</span><br><span class="line">           fl+=cnum[i];</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           fl-=cnum[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=mid1;i&lt;=len;i++)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span>(i<span class="number">-1</span>&lt;=f)</span><br><span class="line">         <span class="keyword">if</span>(fh[i<span class="number">-1</span>]==<span class="string">'+'</span>)</span><br><span class="line">           fr+=cnum[i+<span class="number">1</span>];</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           fr-=cnum[i+<span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (fr==fl) </span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       int64 temp=<span class="number">0</span>,tj1=<span class="number">0</span>,tem2=<span class="number">0</span>,li=<span class="built_in">strlen</span>(shizi),tj2=<span class="number">0</span>,ttem2=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">char</span> tem,ttem;</span><br><span class="line">       <span class="comment">//state 1</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;li;i++)</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">isdigit</span>(shizi[i]))</span><br><span class="line">       &#123;</span><br><span class="line">           temp=shizi[i]-<span class="string">'0'</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">           <span class="keyword">if</span>(rel1[temp][j])</span><br><span class="line">           &#123;</span><br><span class="line">             tem=num[tsz[i][<span class="number">0</span>]][tsz[i][<span class="number">1</span>]];</span><br><span class="line">             num[tsz[i][<span class="number">0</span>]][tsz[i][<span class="number">1</span>]]=j+<span class="string">'0'</span>;</span><br><span class="line">             tj1=<span class="built_in">strlen</span>(num[tsz[i][<span class="number">0</span>]]);</span><br><span class="line">             tem2=cnum[tsz[i][<span class="number">0</span>]];</span><br><span class="line">             cnum[tsz[i][<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;tj1;k++)</span><br><span class="line">               cnum[tsz[i][<span class="number">0</span>]]+=(num[tsz[i][<span class="number">0</span>]][k]-<span class="string">'0'</span>)*(cheng[tj1-k]);</span><br><span class="line">             <span class="keyword">if</span>(check()) </span><br><span class="line">             &#123;</span><br><span class="line">               shizi[i]=j+<span class="string">'0'</span>;</span><br><span class="line">               fout&lt;&lt;shizi&lt;&lt;<span class="string">'#'</span>;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             num[tsz[i][<span class="number">0</span>]][tsz[i][<span class="number">1</span>]]=tem;</span><br><span class="line">             cnum[tsz[i][<span class="number">0</span>]]=tem2;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//state 2</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;li;i++)</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">isdigit</span>(shizi[i]))</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;li;j++)</span><br><span class="line">         <span class="keyword">if</span>((<span class="built_in">isdigit</span>(shizi[j]))&amp;&amp;(i!=j))</span><br><span class="line">         &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i1=<span class="number">0</span>;i1&lt;=<span class="number">9</span>;i1++)</span><br><span class="line">           <span class="keyword">if</span>(rel2[shizi[i]-<span class="string">'0'</span>][i1])</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j1=<span class="number">0</span>;j1&lt;=<span class="number">9</span>;j1++)</span><br><span class="line">             <span class="keyword">if</span>(rel3[shizi[j]-<span class="string">'0'</span>][j1])</span><br><span class="line">             &#123;</span><br><span class="line">             tem=num[tsz[i][<span class="number">0</span>]][tsz[i][<span class="number">1</span>]];</span><br><span class="line">             num[tsz[i][<span class="number">0</span>]][tsz[i][<span class="number">1</span>]]=i1+<span class="string">'0'</span>;</span><br><span class="line">             tj1=<span class="built_in">strlen</span>(num[tsz[i][<span class="number">0</span>]]);</span><br><span class="line">             tem2=cnum[tsz[i][<span class="number">0</span>]];</span><br><span class="line">             cnum[tsz[i][<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;tj1;k++)</span><br><span class="line">               cnum[tsz[i][<span class="number">0</span>]]+=(num[tsz[i][<span class="number">0</span>]][k]-<span class="string">'0'</span>)*(cheng[tj1-k]);</span><br><span class="line">             ttem=num[tsz[j][<span class="number">0</span>]][tsz[j][<span class="number">1</span>]];</span><br><span class="line">             num[tsz[j][<span class="number">0</span>]][tsz[j][<span class="number">1</span>]]=j1+<span class="string">'0'</span>;</span><br><span class="line">             tj2=<span class="built_in">strlen</span>(num[tsz[j][<span class="number">0</span>]]);</span><br><span class="line">             ttem2=cnum[tsz[j][<span class="number">0</span>]];</span><br><span class="line">             cnum[tsz[j][<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;tj2;k++)</span><br><span class="line">               cnum[tsz[j][<span class="number">0</span>]]+=(num[tsz[j][<span class="number">0</span>]][k]-<span class="string">'0'</span>)*(cheng[tj2-k]);</span><br><span class="line">             <span class="keyword">if</span>(check()) </span><br><span class="line">             &#123;</span><br><span class="line">               shizi[i]=i1+<span class="string">'0'</span>;</span><br><span class="line">               shizi[j]=j1+<span class="string">'0'</span>;</span><br><span class="line">               fout&lt;&lt;shizi&lt;&lt;<span class="string">'#'</span>;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             num[tsz[i][<span class="number">0</span>]][tsz[i][<span class="number">1</span>]]=tem;</span><br><span class="line">             cnum[tsz[i][<span class="number">0</span>]]=tem2;</span><br><span class="line">             num[tsz[j][<span class="number">0</span>]][tsz[j][<span class="number">1</span>]]=ttem;</span><br><span class="line">             <span class="keyword">if</span>(tsz[i][<span class="number">0</span>]!=tsz[j][<span class="number">0</span>])<span class="comment">//important</span></span><br><span class="line">               cnum[tsz[j][<span class="number">0</span>]]=ttem2; </span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="comment">//special</span></span><br><span class="line">       fout&lt;&lt;<span class="string">"No"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       fin.getline(shizi,<span class="number">1000</span>,<span class="string">'#'</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">         &#123;</span><br><span class="line">           rel1[i][j]=<span class="literal">false</span>;</span><br><span class="line">           rel2[i][j]=<span class="literal">false</span>;</span><br><span class="line">           rel3[i][j]=<span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(i&lt;<span class="built_in">strlen</span>(shizi)) </span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span>(i!=<span class="number">0</span>) i++;</span><br><span class="line">         <span class="keyword">if</span>((i==<span class="number">0</span>)&amp;&amp;(!<span class="built_in">isdigit</span>(shizi[<span class="number">0</span>]))) </span><br><span class="line">         &#123;</span><br><span class="line">           fuh1=<span class="literal">true</span>;</span><br><span class="line">           i++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">isdigit</span>(shizi[i]))</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">           len++;</span><br><span class="line">           <span class="keyword">while</span> (<span class="built_in">isdigit</span>(shizi[i]))</span><br><span class="line">           &#123;</span><br><span class="line">             tsz[i][<span class="number">0</span>]=len;</span><br><span class="line">             tsz[i][<span class="number">1</span>]=j;</span><br><span class="line">             num[len][j]=shizi[i];</span><br><span class="line">             i++;</span><br><span class="line">             j++;</span><br><span class="line">           &#125;</span><br><span class="line">           j=<span class="built_in">strlen</span>(num[len]);</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;k++)</span><br><span class="line">             cnum[len]+=(num[len][k]-<span class="string">'0'</span>)*(cheng[j-k]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(shizi[i]==<span class="string">'='</span>) </span><br><span class="line">         &#123;</span><br><span class="line">           mid1=len+<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span>(shizi[i+<span class="number">1</span>]==<span class="string">'-'</span>) </span><br><span class="line">           &#123;</span><br><span class="line">             fuh2=<span class="literal">true</span>;</span><br><span class="line">             i++;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">           <span class="keyword">if</span>(<span class="built_in">isgraph</span>(shizi[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                  f++;</span><br><span class="line">                  fh[f]=shizi[i];</span><br><span class="line">                &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//state 1</span></span><br><span class="line">       rel1[<span class="number">0</span>][<span class="number">6</span>]=<span class="literal">true</span>;rel1[<span class="number">6</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">       rel1[<span class="number">0</span>][<span class="number">9</span>]=<span class="literal">true</span>;rel1[<span class="number">9</span>][<span class="number">0</span>]=<span class="literal">true</span>;       </span><br><span class="line">       rel1[<span class="number">9</span>][<span class="number">6</span>]=<span class="literal">true</span>;rel1[<span class="number">6</span>][<span class="number">9</span>]=<span class="literal">true</span>;</span><br><span class="line">       rel1[<span class="number">3</span>][<span class="number">2</span>]=<span class="literal">true</span>;rel1[<span class="number">2</span>][<span class="number">3</span>]=<span class="literal">true</span>;</span><br><span class="line">       rel1[<span class="number">3</span>][<span class="number">5</span>]=<span class="literal">true</span>;rel1[<span class="number">5</span>][<span class="number">3</span>]=<span class="literal">true</span>;</span><br><span class="line">       <span class="comment">//state 2</span></span><br><span class="line">       rel2[<span class="number">0</span>][<span class="number">8</span>]=<span class="literal">true</span>;rel3[<span class="number">8</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">       rel2[<span class="number">9</span>][<span class="number">8</span>]=<span class="literal">true</span>;rel3[<span class="number">8</span>][<span class="number">9</span>]=<span class="literal">true</span>;</span><br><span class="line">       rel2[<span class="number">6</span>][<span class="number">8</span>]=<span class="literal">true</span>;rel3[<span class="number">8</span>][<span class="number">6</span>]=<span class="literal">true</span>;</span><br><span class="line">       rel2[<span class="number">5</span>][<span class="number">6</span>]=<span class="literal">true</span>;rel3[<span class="number">6</span>][<span class="number">5</span>]=<span class="literal">true</span>;</span><br><span class="line">       rel2[<span class="number">1</span>][<span class="number">7</span>]=<span class="literal">true</span>;rel3[<span class="number">7</span>][<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">       rel2[<span class="number">3</span>][<span class="number">9</span>]=<span class="literal">true</span>;rel3[<span class="number">9</span>][<span class="number">3</span>]=<span class="literal">true</span>;</span><br><span class="line">       rel2[<span class="number">5</span>][<span class="number">9</span>]=<span class="literal">true</span>;rel3[<span class="number">9</span>][<span class="number">5</span>]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>注意优化。本题目只要稍加思索可以想到两种比较好的优化方式(均为数学分析优化)，不过以我现在的水平还不行，况且我对着比较bug的测试数据调了很长时间才把负数问题解决(测试数据的答案没有换行 (&gt;-&lt;)导致我一直以为我不对)，恳请大牛不吝赐教。</p><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>Medium (NOI the 1st)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;我是使用朴素的方法做的(高深的我不会)，首先找到火柴棒间的对应关系，比如移动一根火柴可以将8变为0，等等，然后分为两种情况枚举：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本身变动&lt;/li&gt;
&lt;li&gt;两个数字一起变动&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然这样枚举必定要TLE，所以先把整个式子提取出来(所以程序很长 ,其实后来我也有点看不懂了。。。)，这样变动数字进行计算的时候就不用每次把整个式子都算了&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="代码题" scheme="http://izhen.me/tags/%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.4.1 Fence</title>
    <link href="http://izhen.me/2010/02/25/usaco_341/"/>
    <id>http://izhen.me/2010/02/25/usaco_341/</id>
    <published>2010-02-25T15:39:27.000Z</published>
    <updated>2018-09-30T06:18:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>第一个计算几何问题，计算几何问题必须要“踏踏实实”的来，但是也有优化。对于本题目，我使用的是2分法。(我只想到了这个方法，听说还有强大的类似线段树的方法)。首先第一问：使用叉积判断任意两条线段是否绝对相交，若有则输出“NOFENCE”并结束。重点是第二问。观察下图。我们可以很清楚的知道，如果一条线段可以被观察到，他的视野一定不为0，因此，我们只要先找到待观察线段的中点，并与观察点连线就能得到一条新的线段(中位线)。并用新的线段与其它所有线段进行绝对相交判断。同时还要考虑非绝对相交，被点挡住的情况。如果有中位线满足不与所有点相交，那么他一定可以被看到。否则2分。边界条件是两个端点挨在一起了，说明没有满足。这时就要考虑控制精度了。一旦精度过高就会超时。反之就会漏解。(0.005就不错(^o^))具体的实现请看程序。</p><p>提一句输出：我们按顺序2分，这样在输出序列里的就是有序的，只是当最后的结点坐标一样时要按输入文件的顺序输出。而只有当第(N-1)与第N个同时要输出时才会不满足(至于为什么不多作解释)。这时先输出N，再输出(N-1)</p><a id="more"></a><p><img src="/image/idealnova/341.png" alt="USACO 3.4.1"></p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>Compiling…<br>Compile: OK<br>Executing…<br>   Test 1: TEST OK [0.011 secs, 2940 KB]<br>   Test 2: TEST OK [0.011 secs, 2940 KB]<br>   Test 3: TEST OK [0.000 secs, 2940 KB]<br>   Test 4: TEST OK [0.022 secs, 2940 KB]<br>   Test 5: TEST OK [0.000 secs, 2940 KB]<br>   Test 6: TEST OK [0.054 secs, 2940 KB]<br>   Test 7: TEST OK [0.216 secs, 2940 KB]<br>   Test 8: TEST OK [0.194 secs, 2940 KB]<br>   Test 9: TEST OK [0.194 secs, 2940 KB]<br>   Test 10: TEST OK [0.270 secs, 2940 KB]<br>   Test 11: TEST OK [0.000 secs, 2940 KB]<br>   Test 12: TEST OK [0.011 secs, 2940 KB]<br>All tests OK.<br>Your program (‘fence4’) produced all correct answers! This is your<br>submission #3 for this problem. Congratulations!</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span> <span class="params">(<span class="string">"fence4.out"</span>,ios::out)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span> <span class="params">(<span class="string">"fence4.in"</span>,ios::in)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> JD = <span class="number">0.005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">&#125;point[<span class="number">201</span>],see;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">    Point start,end;</span><br><span class="line">&#125;line[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">long</span> n,len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> cansee[<span class="number">201</span>],reg[<span class="number">201</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">crossproduct</span><span class="params">(Point start,Point U,Point V)</span></span>&#123;<span class="comment">//计算叉积</span></span><br><span class="line">    <span class="keyword">double</span> Ux=U.x-start.x,Uy=U.y-start.y,Vx=V.x-start.x,Vy=V.y-start.y;</span><br><span class="line">    <span class="keyword">return</span> (Ux*Vy-Uy*Vx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cancross</span><span class="params">(Line A,Line B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> A1=crossproduct(A.start,A.end,B.start),A2=crossproduct(A.start,A.end,B.end),</span><br><span class="line">        B1=crossproduct(B.start,B.end,A.start),B2=crossproduct(B.start,B.end,A.end);</span><br><span class="line">    <span class="keyword">if</span>(A1==<span class="number">0</span> || A2==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//被点挡住,A为中位线时,以A为轴,有0就表明被点挡住了.</span></span><br><span class="line">    <span class="keyword">if</span>(A1*A2&lt;<span class="number">0</span> &amp;&amp; B2*B1&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//严格相交</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> Line &amp;mid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!reg[i])</span><br><span class="line">        <span class="keyword">if</span>(cancross(mid,line[i])!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">watch</span><span class="params">(Point start,Point end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sqrt</span>(((start.x-end.x)*(start.x-end.x))+((start.y-end.y)*(start.y-end.y)))&lt;JD) <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    Line mid;<span class="comment">//中位线</span></span><br><span class="line">    <span class="keyword">bool</span> temp= <span class="literal">false</span>;</span><br><span class="line">    mid.end.x=(start.x+end.x)/<span class="number">2</span>;</span><br><span class="line">    mid.end.y=(end.y+start.y)/<span class="number">2</span>;</span><br><span class="line">    mid.start.x=see.x;</span><br><span class="line">    mid.start.y=see.y;</span><br><span class="line">    <span class="keyword">if</span>(check(mid)) <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        temp=watch(start,mid.end);</span><br><span class="line">        <span class="keyword">if</span>(!temp) temp=watch(mid.end,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fin&gt;&gt;n&gt;&gt;see.x&gt;&gt;see.y;</span><br><span class="line">    fin&gt;&gt;point[<span class="number">1</span>].x&gt;&gt;point[<span class="number">1</span>].y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200</span>;i++) cansee[i]= <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fin&gt;&gt;point[i].x&gt;&gt;point[i].y;</span><br><span class="line">        line[i<span class="number">-1</span>].start=point[i<span class="number">-1</span>];</span><br><span class="line">        line[i<span class="number">-1</span>].end=point[i];</span><br><span class="line">    &#125;</span><br><span class="line">    line[n].start=point[<span class="number">1</span>];</span><br><span class="line">    line[n].end=point[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(cancross(line[i],line[j])==<span class="number">1</span>)&#123;fout&lt;&lt;<span class="string">"NOFENCE"</span>&lt;&lt;<span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(crossproduct(see,line[i].start,line[i].end)==<span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//cut</span></span><br><span class="line">        reg[i]= <span class="literal">true</span>;<span class="comment">//不要跟自己比较</span></span><br><span class="line">        <span class="keyword">if</span>(watch(line[i].start,line[i].end))&#123;len++; cansee[i]=<span class="literal">true</span>;&#125;</span><br><span class="line">        reg[i]= <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fout&lt;&lt;len&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(cansee[n]&amp;&amp;cansee[n<span class="number">-1</span>])&#123; <span class="comment">//如果最后两个都合法,交换</span></span><br><span class="line">        Line temp=line[n];</span><br><span class="line">        line[n]=line[n<span class="number">-1</span>];</span><br><span class="line">        line[n<span class="number">-1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(cansee[i])</span><br><span class="line">        fout&lt;&lt;line[i].start.x&lt;&lt; <span class="string">' '</span>&lt;&lt;line[i].start.y&lt;&lt;<span class="string">' '</span> &lt;&lt;line[i].end.x&lt;&lt;<span class="string">' '</span>&lt;&lt;line[i].end.y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本文是百度空间的移植，附：全部<a href="https://github.com/i-zhen/USACO-training" target="_blank" rel="noopener">USACO题目解答</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;第一个计算几何问题，计算几何问题必须要“踏踏实实”的来，但是也有优化。对于本题目，我使用的是2分法。(我只想到了这个方法，听说还有强大的类似线段树的方法)。首先第一问：使用叉积判断任意两条线段是否绝对相交，若有则输出“NOFENCE”并结束。重点是第二问。观察下图。我们可以很清楚的知道，如果一条线段可以被观察到，他的视野一定不为0，因此，我们只要先找到待观察线段的中点，并与观察点连线就能得到一条新的线段(中位线)。并用新的线段与其它所有线段进行绝对相交判断。同时还要考虑非绝对相交，被点挡住的情况。如果有中位线满足不与所有点相交，那么他一定可以被看到。否则2分。边界条件是两个端点挨在一起了，说明没有满足。这时就要考虑控制精度了。一旦精度过高就会超时。反之就会漏解。(0.005就不错(^o^))具体的实现请看程序。&lt;/p&gt;
&lt;p&gt;提一句输出：我们按顺序2分，这样在输出序列里的就是有序的，只是当最后的结点坐标一样时要按输入文件的顺序输出。而只有当第(N-1)与第N个同时要输出时才会不满足(至于为什么不多作解释)。这时先输出N，再输出(N-1)&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="计算几何" scheme="http://izhen.me/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>POJ2299树状数组</title>
    <link href="http://izhen.me/2010/02/23/poj2299/"/>
    <id>http://izhen.me/2010/02/23/poj2299/</id>
    <published>2010-02-22T21:38:37.000Z</published>
    <updated>2018-09-24T05:28:39.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>求逆序对，这类问题解法很多，首先想想为何不直接快排然后统计交换次数。</p><p>这里介绍一种树状数组的解法：因为数字本身很大，我们要进行一次离散化。离散化就是每个只要保存他们的相对位置即可，这样能极大压缩树状数组的空间从而避免MLE。<br>例如：2 4 1 10 可以被离散化为 2 3 1 4。</p><p>先对一个镜像数列排序，之后从有序的数列中二分查找每个数组的位置，用位置替换原本的值即可，离散化时间复杂度：O(NlogN)。<br>之后顺理成章的用树状数组统计即可。</p><a id="more"></a><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p><img src="/image/idealnova/poj4.jpg" alt="POJ2299"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a)&gt;(b)?1:-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG 500003</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line">int64 n,tot,pai[BIG],num[BIG],sum[BIG],ln,rn,mid;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> int64 <span class="title">lowbit</span><span class="params">(int64 x)</span></span>&#123;<span class="keyword">return</span> (x &amp; ((x<span class="number">-1</span>)^x));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>  <span class="title">change</span><span class="params">(int64 k,int64 delta)</span></span>&#123;</span><br><span class="line">       <span class="keyword">while</span>(k&lt;=n)&#123;</span><br><span class="line">         sum[k]+=delta;</span><br><span class="line">         k+=lowbit(k);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> int64 <span class="title">getsum</span><span class="params">(int64 k)</span></span>&#123;</span><br><span class="line">       <span class="keyword">long</span> total=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">         total+=sum[k];</span><br><span class="line">         k-=lowbit(k);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span>&#123;</span><br><span class="line">     int64 p=*(int64*)a,q=*(int64* )b;</span><br><span class="line">     <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> MAX(p,q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;pai[i]);</span><br><span class="line">        num[i]=pai[i];</span><br><span class="line">        sum[i]=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tot=<span class="number">0</span>; pai[<span class="number">0</span>]=-BIG;</span><br><span class="line">      qsort(pai,n+<span class="number">1</span>,<span class="keyword">sizeof</span>(int64),cmp);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ln=<span class="number">1</span>;rn=n;</span><br><span class="line">        <span class="keyword">while</span>(ln&lt;rn)&#123;</span><br><span class="line">          mid=(ln+rn+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(num[i]&gt;=pai[mid]) ln=mid;</span><br><span class="line">          <span class="keyword">else</span> rn=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num[i]=ln;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">long</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        tot+=getsum(num[i]<span class="number">-1</span>);</span><br><span class="line">        change(num[i],<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>Middle (省选)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;求逆序对，这类问题解法很多，首先想想为何不直接快排然后统计交换次数。&lt;/p&gt;
&lt;p&gt;这里介绍一种树状数组的解法：因为数字本身很大，我们要进行一次离散化。离散化就是每个只要保存他们的相对位置即可，这样能极大压缩树状数组的空间从而避免MLE。&lt;br&gt;例如：2 4 1 10 可以被离散化为 2 3 1 4。&lt;/p&gt;
&lt;p&gt;先对一个镜像数列排序，之后从有序的数列中二分查找每个数组的位置，用位置替换原本的值即可，离散化时间复杂度：O(NlogN)。&lt;br&gt;之后顺理成章的用树状数组统计即可。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="树状数组" scheme="http://izhen.me/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>POJ3368区间最值-ST算法</title>
    <link href="http://izhen.me/2010/02/22/poj3368/"/>
    <id>http://izhen.me/2010/02/22/poj3368/</id>
    <published>2010-02-21T21:38:37.000Z</published>
    <updated>2018-09-24T05:37:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>这是一道可以使用线段树轻松解决的问题，只要维护总最长区间，从左边开始和右边开始的最长区间三个域即可。</p><p>但是，还有更巧妙的RMQ解法，假如我们只要[1,n]的最长区间，很显然只要预处理一下，把连续的值的频率算出来，就可以很简单的RMQ了，但问题是：如果区间断开了，那么RMQ是否就失效了?对于断开的区间的整体来说必定是这样，但是其中的完整的子段依然保留着RMQ的最优性。</p><p>例如：-1 -1 1 1 1 1 3 10 10 10，预处理后：1 2 1 2 3 4 1 1 2 3，如果查询[5,10]直接ST会算出4，但是应该是3，再仔细观察，因为数列非递减，所以只有左边断开才会影响结果，因此我们只要特殊处理一下左边的连续值即可。然后对剩下的使用ST解决。</p><a id="more"></a><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p><img src="/image/idealnova/poj3.png" alt="POJ3368区间最值"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">long</span> dp[Max][BIG],num[Max],x,y,n,q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%ld"</span>,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%ld"</span>,&amp;q);</span><br><span class="line">        num[<span class="number">0</span>]=-Max;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%ld"</span>,&amp;num[i]); dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(num[i]==num[i<span class="number">-1</span>]) dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=(<span class="keyword">long</span>)log2(n);i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-(<span class="number">1</span>&lt;&lt;i)+<span class="number">1</span>;j++)</span><br><span class="line">                dp[j][i]=MAX(dp[j][i<span class="number">-1</span>],dp[j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))][i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> p=<span class="number">1</span>;p&lt;=q;p++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%ld%ld"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span>(num[x]==num[y]) <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,y-x+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">long</span> l=x,Log;</span><br><span class="line">                <span class="keyword">while</span>(l++ &amp;&amp; (dp[l][<span class="number">0</span>]!=<span class="number">1</span>)) ;</span><br><span class="line">                Log=(<span class="keyword">long</span>)log2(y-l+<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,MAX(l-x,MAX(dp[l][Log],dp[y-(<span class="number">1</span>&lt;&lt;Log)+<span class="number">1</span>][Log])));&#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>Middle Up(Noip the 3rd)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;这是一道可以使用线段树轻松解决的问题，只要维护总最长区间，从左边开始和右边开始的最长区间三个域即可。&lt;/p&gt;
&lt;p&gt;但是，还有更巧妙的RMQ解法，假如我们只要[1,n]的最长区间，很显然只要预处理一下，把连续的值的频率算出来，就可以很简单的RMQ了，但问题是：如果区间断开了，那么RMQ是否就失效了?对于断开的区间的整体来说必定是这样，但是其中的完整的子段依然保留着RMQ的最优性。&lt;/p&gt;
&lt;p&gt;例如：-1 -1 1 1 1 1 3 10 10 10，预处理后：1 2 1 2 3 4 1 1 2 3，如果查询[5,10]直接ST会算出4，但是应该是3，再仔细观察，因为数列非递减，所以只有左边断开才会影响结果，因此我们只要特殊处理一下左边的连续值即可。然后对剩下的使用ST解决。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="ST算法" scheme="http://izhen.me/tags/ST%E7%AE%97%E6%B3%95/"/>
    
      <category term="RMQ问题" scheme="http://izhen.me/tags/RMQ%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>POJ2104归并树</title>
    <link href="http://izhen.me/2010/02/21/poj2104/"/>
    <id>http://izhen.me/2010/02/21/poj2104/</id>
    <published>2010-02-20T21:38:37.000Z</published>
    <updated>2018-09-24T04:51:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>使用线段树的划分结构维护归并排序，线段树是虚的，不需要建立出来。查找时，大体分为三次：首先二分总区间的中值 -&gt; 接着使用已经建好的归并树二分中值在待查区间的排位(需要两个小的二分组成) -&gt; 若与待查排位一致就输出，否则总区间折半继续上述步骤直到找到。</p><p>本题目实现以后，我从一个神人的Blog发现了使用 STL 优化的方法：查待查区间的排位可以用STL。(冬令营上说可以使用)</p><p>我原本的程序：长61Lines | 运行时间::3.4s;<br>使用STL后的程序：长56Lines | 运行时间::2.4s; &lt;– OTL</p><a id="more"></a><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p><img src="/image/idealnova/poj1.png" alt="POJ2104归并树"></p><p><img src="/image/idealnova/poj2.png" alt="POJ2104归并树"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;    // 优化了一下代码 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100001 <span class="comment">//确定区间上界</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG 19     <span class="comment">//确定归并树深度 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> seg[BIG][MAX],val[MAX],m,n,x,y,rank; <span class="comment">//seg,val分别存储归并树 ,原数列.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>                              <span class="comment">// 存储线段树的分割 </span></span><br><span class="line">    <span class="keyword">long</span> left,right,mid;</span><br><span class="line">&#125;tr[<span class="number">2</span>*MAX+MAX/<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">long</span> index,<span class="keyword">long</span> l,<span class="keyword">long</span> r,<span class="keyword">long</span> deep)</span></span>&#123; <span class="comment">//建立归并树</span></span><br><span class="line">     tr[index].left=l;</span><br><span class="line">    tr[index].right=r;</span><br><span class="line">    tr[index].mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        seg[deep][l]=val[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    build(index&lt;&lt;<span class="number">1</span>,l,tr[index].mid,deep+<span class="number">1</span>);</span><br><span class="line">    build((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,tr[index].mid+<span class="number">1</span>,r,deep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ln=l,rn=mid+<span class="number">1</span>,pos=l;</span><br><span class="line">    <span class="keyword">while</span>(ln&lt;=mid &amp;&amp; rn&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(seg[deep+<span class="number">1</span>][ln]&gt;seg[deep+<span class="number">1</span>][rn])</span><br><span class="line">            seg[deep][pos++]=seg[deep+<span class="number">1</span>][rn++];</span><br><span class="line">        <span class="keyword">else</span> seg[deep][pos++]=seg[deep+<span class="number">1</span>][ln++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ln==mid+<span class="number">1</span>) <span class="keyword">while</span>(rn&lt;=r) seg[deep][pos++]=seg[deep+<span class="number">1</span>][rn++];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span>(ln&lt;=mid) seg[deep][pos++]=seg[deep+<span class="number">1</span>][ln++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">bigger</span><span class="params">(<span class="keyword">long</span> index,<span class="keyword">long</span> find,<span class="keyword">long</span> deep)</span></span>&#123; <span class="comment">//返回一个严格排名 (比多少个数大)</span></span><br><span class="line">    <span class="keyword">if</span>(tr[index].left==tr[index].right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(find&gt;seg[deep][tr[index].mid]) <span class="keyword">return</span> tr[index].mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> tr[index].mid;&#125;</span><br><span class="line">    <span class="keyword">if</span>(find&lt;=seg[deep][tr[index].mid]) <span class="keyword">return</span> bigger(index&lt;&lt;<span class="number">1</span>,find,deep);</span><br><span class="line">    <span class="keyword">if</span>(find&gt;seg[deep][tr[index].mid]) <span class="keyword">return</span> bigger((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,find,deep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Rank</span><span class="params">(<span class="keyword">long</span> index,<span class="keyword">long</span> find,<span class="keyword">long</span> deep)</span></span>&#123;   <span class="comment">//二分排名 </span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;=tr[index].left &amp;&amp; tr[index].right&lt;=y)</span><br><span class="line">        <span class="keyword">return</span> bigger(index,find,deep)-tr[index].left;</span><br><span class="line">    <span class="keyword">long</span> Find=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=tr[index].mid) Find+=Rank(index&lt;&lt;<span class="number">1</span>,find,deep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;tr[index].mid) Find+=Rank((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,find,deep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Find;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">()</span></span>&#123;                        <span class="comment">// 二分总区间 </span></span><br><span class="line">    <span class="keyword">long</span> left=<span class="number">1</span>,right=n,mid,rend;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        mid=(left+right+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        rend=Rank(<span class="number">1</span>,seg[<span class="number">1</span>][mid],<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rend&lt;rank) left=mid;</span><br><span class="line">        <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%ld%ld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%ld"</span>,&amp;val[i]);</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%ld%ld%ld"</span>,&amp;x,&amp;y,&amp;rank);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,seg[<span class="number">1</span>][query()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ADVENTop吐槽"><a href="#ADVENTop吐槽" class="headerlink" title="ADVENTop吐槽"></a>ADVENTop吐槽</h4><ol><li>谁能告诉我什么是吐槽?</li><li>从小U牛那里第一次看见本题，从Lilymona牛那里了解了归并树，这也是一道流行题吗?</li><li>一开始我不知怎么着一高兴把程序粘贴到回收站里去了，然后立即条件反射 -&gt; 右键 -&gt; 清空回收站 -&gt; 然后我就囧了</li><li>Windows太Bug了，回收站还能粘贴!!!(&gt;-&lt;)</li><li>STL很厉害呀!</li></ol><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>Middle Up(NOI级别的简单题)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;使用线段树的划分结构维护归并排序，线段树是虚的，不需要建立出来。查找时，大体分为三次：首先二分总区间的中值 -&amp;gt; 接着使用已经建好的归并树二分中值在待查区间的排位(需要两个小的二分组成) -&amp;gt; 若与待查排位一致就输出，否则总区间折半继续上述步骤直到找到。&lt;/p&gt;
&lt;p&gt;本题目实现以后，我从一个神人的Blog发现了使用 STL 优化的方法：查待查区间的排位可以用STL。(冬令营上说可以使用)&lt;/p&gt;
&lt;p&gt;我原本的程序：长61Lines | 运行时间::3.4s;&lt;br&gt;使用STL后的程序：长56Lines | 运行时间::2.4s; &amp;lt;– OTL&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="归并树" scheme="http://izhen.me/tags/%E5%BD%92%E5%B9%B6%E6%A0%91/"/>
    
      <category term="POJ" scheme="http://izhen.me/tags/POJ/"/>
    
  </entry>
  
  <entry>
    <title>NOI2000青蛙过河</title>
    <link href="http://izhen.me/2010/02/15/noi2000/"/>
    <id>http://izhen.me/2010/02/15/noi2000/</id>
    <published>2010-02-14T21:38:37.000Z</published>
    <updated>2018-09-24T05:54:23.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>这道<a href="https://www.luogu.org/problemnew/show/P1244" target="_blank" rel="noopener">题目</a>是一道好题，因为可以从多个角度出发考虑，途径很多。首先，乍一看题貌似是Hanoi塔的模式，只不过增加了特定的限制(不可以向回走)，先分析一个例子：石墩有2个，荷叶3个的情况。这种情况可以有至多16只青蛙过河。首先有4只先到一号石墩，接着另有4个号码较大的到达2号墩，这是很容易做到的，然后让1号墩上的3个小的跳到荷叶上，1号墩剩下那只直接跳到2号，3个荷叶上的再跳到2号。此时2号墩已经饱和了(推一下即可知道)，而1号和荷叶是空的让其饱和，则可再次有7只青蛙，此时已经有15只青蛙。左岸的第16只可以直接跳到右岸，而且可以发现怎样跳过来还可以怎样跳回去，只不过我们不跳到左岸而是右岸，这是对称的。因此可以有16只。</p><p><img src="/image/idealnova/frog.jpg" alt="NOI 2000"></p><p>事实上，我们仔细分析可以发现，只有荷叶的话，那么最多只能有荷叶数加1只青蛙可以过河，因为过河顺序是单向传递的。所以我们如果想使过河数最大可以令青蛙在河中央停留的只数达到最多，这样只有荷叶的话必然是荷叶数加1只青蛙可以渡过。但是存在石墩就不一样了。因为石墩上可以有多只编号严格递减的青蛙。首先荷叶可以作为跳板，并由这些跳板使多只青蛙到达河中的石墩，并且尽量可以积累的多一些。而且河中的石墩是无所谓顺序的，所以我们可以这样来看待问题：</p><p>把左岸，河中央，右岸分为3个阶段。把河中的石墩当作目的地，用样例来说：根据前面的分析，1号石墩可以有4只青蛙，2号同样可以有4只，此时1、2号石墩的青蛙序号严格递减，所以1号的青蛙又可以看作右岸借助荷叶到达2号石墩。2号就有8只。此时因为2号石墩的青蛙数的总数比荷叶石墩的总数还多，所以2号石墩已经饱和。1号已空，再重复之前的工作……如此反复进行：i号石墩总可以包含(i-1)号，即以1号石墩的青蛙作为单位青蛙数s，会有s，2 <em> s，4 </em> s……只，所以总共会有2^h*(k+1)个青蛙可以过河。得到通项公式。</p><a id="more"></a><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p><img src="/image/idealnova/noi2000.jpg" alt="NOI 2003"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> h,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%ld%ld"</span>,&amp;h,&amp;k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,(<span class="number">1</span>&lt;&lt;h)*(k+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果把河中的无用的石墩当作跳板，使得当前的青蛙数目达到最大，会阻碍后面的青蛙的跳跃。</p><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>Middle Up(noi the 1st || noip the 3rd)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;这道&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1244&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目&lt;/a&gt;是一道好题，因为可以从多个角度出发考虑，途径很多。首先，乍一看题貌似是Hanoi塔的模式，只不过增加了特定的限制(不可以向回走)，先分析一个例子：石墩有2个，荷叶3个的情况。这种情况可以有至多16只青蛙过河。首先有4只先到一号石墩，接着另有4个号码较大的到达2号墩，这是很容易做到的，然后让1号墩上的3个小的跳到荷叶上，1号墩剩下那只直接跳到2号，3个荷叶上的再跳到2号。此时2号墩已经饱和了(推一下即可知道)，而1号和荷叶是空的让其饱和，则可再次有7只青蛙，此时已经有15只青蛙。左岸的第16只可以直接跳到右岸，而且可以发现怎样跳过来还可以怎样跳回去，只不过我们不跳到左岸而是右岸，这是对称的。因此可以有16只。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/idealnova/frog.jpg&quot; alt=&quot;NOI 2000&quot;&gt;&lt;/p&gt;
&lt;p&gt;事实上，我们仔细分析可以发现，只有荷叶的话，那么最多只能有荷叶数加1只青蛙可以过河，因为过河顺序是单向传递的。所以我们如果想使过河数最大可以令青蛙在河中央停留的只数达到最多，这样只有荷叶的话必然是荷叶数加1只青蛙可以渡过。但是存在石墩就不一样了。因为石墩上可以有多只编号严格递减的青蛙。首先荷叶可以作为跳板，并由这些跳板使多只青蛙到达河中的石墩，并且尽量可以积累的多一些。而且河中的石墩是无所谓顺序的，所以我们可以这样来看待问题：&lt;/p&gt;
&lt;p&gt;把左岸，河中央，右岸分为3个阶段。把河中的石墩当作目的地，用样例来说：根据前面的分析，1号石墩可以有4只青蛙，2号同样可以有4只，此时1、2号石墩的青蛙序号严格递减，所以1号的青蛙又可以看作右岸借助荷叶到达2号石墩。2号就有8只。此时因为2号石墩的青蛙数的总数比荷叶石墩的总数还多，所以2号石墩已经饱和。1号已空，再重复之前的工作……如此反复进行：i号石墩总可以包含(i-1)号，即以1号石墩的青蛙作为单位青蛙数s，会有s，2 &lt;em&gt; s，4 &lt;/em&gt; s……只，所以总共会有2^h*(k+1)个青蛙可以过河。得到通项公式。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="递推" scheme="http://izhen.me/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>NOI2007项链工厂</title>
    <link href="http://izhen.me/2010/02/08/noi2004/"/>
    <id>http://izhen.me/2010/02/08/noi2004/</id>
    <published>2010-02-07T21:38:37.000Z</published>
    <updated>2018-09-24T05:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>(这道题目好像很流行 (^o^))。分析题目，因为所有操作均是在区间内完成的，因此可以使用线段树，保证维护的摊还时间限定在O(logn)以内，但是本题的难点不在线段树本身，而是对于Flip和 Rotate的维护，这是其一，其二就是如何合并两棵树。针对这个问题，通过分析我们知道，珠子之间的相对位置固定，这样就可以使用偏移量来记录，再用bool的标志记录是否偏转，具体的计算请看我的程序的hash()函数，这样就解决了这两个问题。而子树合并，则要再维护rcol，lcol两个分别代表左右端点的域。这样的好处，相信不用我再说了。</p><a id="more"></a><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p><img src="/image/idealnova/noi2007.jpg" alt="NOI 2007"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fin cin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fout cout</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> MAX=<span class="number">500001</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> lch,rch,left,right,reg,lcol,rcol,mid;</span><br><span class="line">    <span class="keyword">bool</span> mark;</span><br><span class="line">&#125;tree[MAX*<span class="number">5</span>];</span><br><span class="line"><span class="keyword">long</span> tot=<span class="number">1</span>,delta=<span class="number">0</span>,n,color[MAX],q,A,B,C,A1,B1,Count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> flip=<span class="literal">true</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">regtree</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(<span class="keyword">long</span> index)</span></span>&#123;</span><br><span class="line">            <span class="keyword">long</span> lch=tree[index].lch,rch=tree[index].rch;</span><br><span class="line">            tree[index].lcol=tree[lch].lcol;</span><br><span class="line">            tree[index].rcol=tree[rch].rcol;</span><br><span class="line">            tree[index].reg=tree[lch].reg+tree[rch].reg-(tree[lch].rcol==tree[rch].lcol?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(tree[index].reg==<span class="number">1</span>) tree[index].mark=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> tree[index].mark=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">long</span> left,<span class="keyword">long</span> right,<span class="keyword">long</span> index)</span></span>&#123;</span><br><span class="line">            tree[index].left=left;</span><br><span class="line">            tree[index].right=right;</span><br><span class="line">            tree[index].mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            tree[index].mark=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                tree[index].lch=++tot;</span><br><span class="line">                build(left,tree[index].mid,tot);</span><br><span class="line">                tree[index].rch=++tot;</span><br><span class="line">                build(tree[index].mid+<span class="number">1</span>,right,tot);</span><br><span class="line">                refresh(index);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tree[index].lcol=tree[index].rcol=color[left];</span><br><span class="line">                tree[index].reg=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">downset</span><span class="params">(<span class="keyword">long</span> index)</span></span>&#123;</span><br><span class="line">            <span class="keyword">long</span> lch=tree[index].lch,rch=tree[index].rch;</span><br><span class="line">            tree[lch].lcol=tree[rch].lcol=tree[lch].rcol=tree[rch].rcol=tree[index].lcol;</span><br><span class="line">            tree[lch].reg=<span class="number">1</span>;</span><br><span class="line">            tree[rch].reg=<span class="number">1</span>;</span><br><span class="line">            tree[lch].mark=tree[rch].mark=<span class="literal">true</span>;</span><br><span class="line">            tree[index].mark=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">paint</span><span class="params">(<span class="keyword">long</span> left,<span class="keyword">long</span> right,<span class="keyword">long</span> col,<span class="keyword">long</span> index)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!index) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(tree[index].left&gt;=left &amp;&amp; tree[index].right&lt;=right)&#123;</span><br><span class="line">                tree[index].lcol=tree[index].rcol=col;</span><br><span class="line">                tree[index].reg=<span class="number">1</span>;</span><br><span class="line">                tree[index].mark=<span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(tree[index].mark) downset(index);</span><br><span class="line">                <span class="keyword">if</span>(left&lt;=tree[index].mid) paint(left,right,col,tree[index].lch);</span><br><span class="line">                <span class="keyword">if</span>(right&gt;tree[index].mid) paint(left,right,col,tree[index].rch);</span><br><span class="line">                refresh(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="title">cseg</span><span class="params">(<span class="keyword">long</span> left,<span class="keyword">long</span> right,<span class="keyword">long</span> index)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!index) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(tree[index].left&gt;=left &amp;&amp; tree[index].right&lt;=right)&#123;</span><br><span class="line">                <span class="keyword">return</span> tree[index].reg;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">long</span> temp=<span class="number">0</span>,key=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(tree[index].mark) downset(index);</span><br><span class="line">                <span class="keyword">if</span>(left&lt;=tree[index].mid) &#123;key++;temp+=cseg(left,right,tree[index].lch);&#125;</span><br><span class="line">                <span class="keyword">if</span>(right&gt;tree[index].mid) &#123;key++;temp+=cseg(left,right,tree[index].rch);&#125;</span><br><span class="line">                <span class="keyword">return</span> temp-((key==<span class="number">2</span> &amp;&amp; tree[tree[index].lch].rcol==tree[tree[index].rch].lcol)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="title">find</span><span class="params">(<span class="keyword">long</span> pos,<span class="keyword">long</span> index)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tree[index].left&lt;=pos &amp;&amp; pos&lt;=tree[index].right &amp;&amp; tree[index].reg==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> tree[index].lcol;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(tree[index].mark) downset(index);</span><br><span class="line">                <span class="keyword">if</span>(pos&lt;=tree[index].mid &amp;&amp; tree[index].lch) <span class="keyword">return</span> find(pos,tree[index].lch);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pos&gt;tree[index].mid &amp;&amp; tree[index].rch) <span class="keyword">return</span> find(pos,tree[index].rch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;line;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(<span class="keyword">long</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!flip) pos=n-pos+<span class="number">2</span>;</span><br><span class="line">    pos-=delta;</span><br><span class="line">    pos%=n;</span><br><span class="line">    pos=(pos+n)%n;</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>) pos=n;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fin&gt;&gt;n&gt;&gt;Count;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++) fin&gt;&gt;color[i];</span><br><span class="line">    line.build(<span class="number">1</span>,n,tot);</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">3</span>];</span><br><span class="line">    fin&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i1=<span class="number">1</span>;i1&lt;=q;i1++)&#123;</span><br><span class="line">        fin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'R'</span>)&#123;</span><br><span class="line">            fin&gt;&gt;A;</span><br><span class="line">            <span class="keyword">if</span>(flip) delta+=A;</span><br><span class="line">            <span class="keyword">else</span> delta-=A;</span><br><span class="line">            delta%=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'F'</span>) flip=!flip;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'S'</span>)&#123;</span><br><span class="line">            fin&gt;&gt;A&gt;&gt;B;</span><br><span class="line">            A1=A;B1=B;</span><br><span class="line">            <span class="keyword">if</span>(!flip)&#123;A=hash(B1);B=hash(A1);&#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;A=hash(A);B=hash(B);&#125;</span><br><span class="line">            C=line.find(A,<span class="number">1</span>);</span><br><span class="line">            Count=line.find(B,<span class="number">1</span>);</span><br><span class="line">            line.paint(A,A,Count,<span class="number">1</span>);</span><br><span class="line">            line.paint(B,B,C,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'P'</span>)&#123;</span><br><span class="line">            fin&gt;&gt;A&gt;&gt;B&gt;&gt;C;</span><br><span class="line">            A1=A;B1=B;</span><br><span class="line">            <span class="keyword">if</span>(!flip)&#123;A=hash(B1);B=hash(A1);&#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;A=hash(A);B=hash(B);&#125;</span><br><span class="line">            <span class="keyword">if</span>(A&gt;B) &#123;line.paint(A,n,C,<span class="number">1</span>);line.paint(<span class="number">1</span>,B,C,<span class="number">1</span>);&#125;</span><br><span class="line">                <span class="keyword">else</span> line.paint(A,B,C,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'C'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">1</span>]==<span class="string">'S'</span>)&#123;</span><br><span class="line">                Count=<span class="number">0</span>;</span><br><span class="line">                fin&gt;&gt;A&gt;&gt;B;</span><br><span class="line">                A1=A;B1=B;</span><br><span class="line">                <span class="keyword">if</span>(!flip)&#123;A=hash(B1);B=hash(A1);&#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;A=hash(A);B=hash(B);&#125;</span><br><span class="line">                <span class="keyword">if</span>(A&gt;B) &#123;Count+=line.cseg(A,n,<span class="number">1</span>);Count+=line.cseg(<span class="number">1</span>,B,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(tree[<span class="number">1</span>].lcol==tree[<span class="number">1</span>].rcol) Count--;&#125;</span><br><span class="line">                    <span class="keyword">else</span> Count=line.cseg(A,B,<span class="number">1</span>);</span><br><span class="line">                fout&lt;&lt;Count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="keyword">if</span>(tree[<span class="number">1</span>].reg!=<span class="number">1</span>)fout&lt;&lt;tree[<span class="number">1</span>].reg-(tree[<span class="number">1</span>].lcol==tree[<span class="number">1</span>].rcol?<span class="number">1</span>:<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">else</span> fout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;&#125; <span class="comment">// 特殊情况 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>Middle Up (NOI 级别)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;(这道题目好像很流行 (^o^))。分析题目，因为所有操作均是在区间内完成的，因此可以使用线段树，保证维护的摊还时间限定在O(logn)以内，但是本题的难点不在线段树本身，而是对于Flip和 Rotate的维护，这是其一，其二就是如何合并两棵树。针对这个问题，通过分析我们知道，珠子之间的相对位置固定，这样就可以使用偏移量来记录，再用bool的标志记录是否偏转，具体的计算请看我的程序的hash()函数，这样就解决了这两个问题。而子树合并，则要再维护rcol，lcol两个分别代表左右端点的域。这样的好处，相信不用我再说了。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="线段树" scheme="http://izhen.me/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.4.2 Heritage</title>
    <link href="http://izhen.me/2010/02/06/usaco_342/"/>
    <id>http://izhen.me/2010/02/06/usaco_342/</id>
    <published>2010-02-06T15:39:27.000Z</published>
    <updated>2018-09-30T06:19:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>分治策略：首先根据常识凡是中序+前序，中序+后序均可确定唯一二叉树。前序+后序不可确定。因此我们根据中序+前序先构造出二叉树，然后输出即可。构造方法是：因为前序遍历的第一个一定是根，那么接着找到根在中序遍历的位置。在中序遍历中左边的就是左子树。右边的就是右子树。然后下放左右子树和相应的前序遍历接着做，直到没有左右子树为止。(如图)</p><a id="more"></a><p><img src="/image/idealnova/342.png" alt="USACO 3.4.2"></p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>Compiling…<br>Compile: OK<br>Executing…<br>   Test 1: TEST OK [0.000 secs, 2932 KB]<br>   Test 2: TEST OK [0.000 secs, 2932 KB]<br>   Test 3: TEST OK [0.000 secs, 2932 KB]<br>   Test 4: TEST OK [0.011 secs, 2932 KB]<br>   Test 5: TEST OK [0.011 secs, 2932 KB]<br>   Test 6: TEST OK [0.000 secs, 2932 KB]<br>   Test 7: TEST OK [0.011 secs, 2932 KB]<br>   Test 8: TEST OK [0.011 secs, 2932 KB]<br>   Test 9: TEST OK [0.011 secs, 2932 KB]<br>All tests OK.<br>YOUR PROGRAM (‘heritage’) WORKED FIRST TIME! That’s fantastic<br>– and a rare thing. Please accept these special automated<br>congratulations.</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span> <span class="params">(<span class="string">"heritage.out"</span>,ios::out)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span> <span class="params">(<span class="string">"heritage.in"</span>,ios::in)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">String</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> word[<span class="number">27</span>];</span><br><span class="line">&#125;str[<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subteee</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> key;</span><br><span class="line">    <span class="keyword">int</span> lch,rch;</span><br><span class="line">&#125;tree[<span class="number">27</span>];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backout</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123; <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(tree[pos].lch) backout(tree[pos].lch);</span><br><span class="line">    <span class="keyword">if</span>(tree[pos].rch) backout(tree[pos].rch);</span><br><span class="line">    fout&lt;&lt;tree[pos].key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> work[],<span class="keyword">int</span> len, <span class="keyword">int</span> pos,<span class="keyword">int</span> index)</span></span>&#123; <span class="comment">//构造二叉树</span></span><br><span class="line">    tree[index].key=str[<span class="number">0</span>].word[pos];</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">27</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) <span class="keyword">if</span>(work[i]==tree[index].key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) temp[j]=work[j];</span><br><span class="line">            tree[index].lch=++tot;</span><br><span class="line">            find(temp,i,pos+<span class="number">1</span>,tot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++) temp[j-i<span class="number">-1</span>]=work[j];</span><br><span class="line">            tree[index].rch=++tot;</span><br><span class="line">            find(temp,len-i<span class="number">-1</span>,pos+i+<span class="number">1</span>,tot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fin&gt;&gt;str[<span class="number">1</span>].word&gt;&gt;str[<span class="number">0</span>].word;</span><br><span class="line">    str[<span class="number">1</span>].len=<span class="built_in">strlen</span>(str[<span class="number">1</span>].word);</span><br><span class="line">    str[<span class="number">0</span>].len=<span class="built_in">strlen</span>(str[<span class="number">0</span>].word);</span><br><span class="line">    find(str[<span class="number">1</span>].word,str[<span class="number">1</span>].len,<span class="number">0</span>,tot);</span><br><span class="line">    backout(<span class="number">1</span>);</span><br><span class="line">    fout&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本文是百度空间的移植，附：全部<a href="https://github.com/i-zhen/USACO-training" target="_blank" rel="noopener">USACO题目解答</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;分治策略：首先根据常识凡是中序+前序，中序+后序均可确定唯一二叉树。前序+后序不可确定。因此我们根据中序+前序先构造出二叉树，然后输出即可。构造方法是：因为前序遍历的第一个一定是根，那么接着找到根在中序遍历的位置。在中序遍历中左边的就是左子树。右边的就是右子树。然后下放左右子树和相应的前序遍历接着做，直到没有左右子树为止。(如图)&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="Tree" scheme="http://izhen.me/tags/Tree/"/>
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="Ad Hoc" scheme="http://izhen.me/tags/Ad-Hoc/"/>
    
  </entry>
  
  <entry>
    <title>POJ3667线段树</title>
    <link href="http://izhen.me/2010/02/05/poj3667/"/>
    <id>http://izhen.me/2010/02/05/poj3667/</id>
    <published>2010-02-04T21:38:37.000Z</published>
    <updated>2018-09-24T05:41:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>裸的线段树，线段树能解决的问题很多，这道题目是非常典型的线段染色问题。有三种状态，无色（空），满色（有人），杂色。主要考察的也就是实现线段树的惰性，即懒操作。修改颜色时不是一改到底的，在适当粒度的区间做好标记，当出现更细粒度（小于某个区间）的操作时再下放。例如：区间[1,10]标记为客满，同时区间[1,2]标记为空是可以在某些时刻共存的，想想为什么。</p><a id="more"></a><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p><img src="/image/idealnova/poj5.jpg" alt="POJ3667"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> MAX=<span class="number">999999</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">       <span class="keyword">long</span> lch,rch,left,right,lnum,rnum,num,mid,all;</span><br><span class="line">       <span class="keyword">int</span> mark; <span class="comment">//0空，1满，2杂色</span></span><br><span class="line">&#125;tree[<span class="number">400001</span>];</span><br><span class="line"><span class="keyword">long</span> tot=<span class="number">1</span>,n,q;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">regtree</span>&#123;</span></span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">             <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">long</span> left,<span class="keyword">long</span> right,<span class="keyword">long</span> index)</span></span>&#123;</span><br><span class="line">                  tree[index].left=left;</span><br><span class="line">                  tree[index].right=right;</span><br><span class="line">                  tree[index].mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">                  tree[index].all=right-left+<span class="number">1</span>;</span><br><span class="line">                  tree[index].lnum=tree[index].rnum=tree[index].num=tree[index].all;</span><br><span class="line">                  tree[index].mark=<span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                    tree[index].lch=++tot;</span><br><span class="line">                    build(left,tree[index].mid,tot);</span><br><span class="line">                    tree[index].rch=++tot;</span><br><span class="line">                    build(tree[index].mid+<span class="number">1</span>,right,tot);</span><br><span class="line">                  &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">(<span class="keyword">long</span> index)</span></span>&#123;</span><br><span class="line">                  <span class="keyword">long</span> Max=<span class="number">0</span>,lch=tree[index].lch,rch=tree[index].rch;</span><br><span class="line">                  Max=MAX(Max,tree[lch].rnum+tree[rch].lnum);</span><br><span class="line">                  Max=MAX(MAX(Max,tree[lch].num),tree[rch].num);</span><br><span class="line">                  tree[index].num=Max;</span><br><span class="line">                  <span class="keyword">if</span>(tree[lch].lnum&lt;tree[lch].all) tree[index].lnum=tree[lch].lnum;</span><br><span class="line">                  <span class="keyword">else</span> tree[index].lnum=tree[lch].lnum+tree[rch].lnum;</span><br><span class="line">                  <span class="keyword">if</span>(tree[rch].rnum&lt;tree[rch].all) tree[index].rnum=tree[rch].rnum;</span><br><span class="line">                  <span class="keyword">else</span> tree[index].rnum=tree[rch].rnum+tree[lch].rnum;</span><br><span class="line">                  <span class="keyword">if</span>(tree[lch].mark!=tree[rch].mark) tree[index].mark=<span class="number">2</span>;</span><br><span class="line">                  <span class="keyword">else</span> tree[index].mark=tree[lch].mark;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="function"><span class="keyword">void</span> <span class="title">downset</span><span class="params">(<span class="keyword">long</span> index,<span class="keyword">int</span> mark)</span></span>&#123;</span><br><span class="line">                  <span class="keyword">long</span> lch=tree[index].lch,rch=tree[index].rch;</span><br><span class="line">                  <span class="keyword">if</span>(mark==<span class="number">1</span>)&#123;</span><br><span class="line">                    tree[lch].num=tree[lch].lnum=tree[lch].rnum=<span class="number">0</span>;</span><br><span class="line">                    tree[rch].num=tree[rch].lnum=tree[rch].rnum=<span class="number">0</span>;</span><br><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tree[lch].num=tree[lch].lnum=tree[lch].rnum=tree[lch].all;</span><br><span class="line">                    tree[rch].num=tree[rch].lnum=tree[rch].rnum=tree[rch].all;</span><br><span class="line">                  &#125;</span><br><span class="line">                  tree[lch].mark=tree[rch].mark=mark;</span><br><span class="line">                  tree[index].mark=<span class="number">2</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="function"><span class="keyword">long</span> <span class="title">find</span><span class="params">(<span class="keyword">long</span> size,<span class="keyword">long</span> index)</span></span>&#123;</span><br><span class="line">                  <span class="keyword">if</span>(!index) <span class="keyword">return</span> MAX;</span><br><span class="line">                  <span class="keyword">long</span> temp=MAX;</span><br><span class="line">                  <span class="keyword">if</span>(tree[index].lnum&gt;=size) temp=tree[index].left;</span><br><span class="line">                  <span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="keyword">if</span>(tree[tree[index].lch].num&gt;=size) temp=find(size,tree[index].lch);</span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span>(tree[tree[index].lch].rnum+tree[tree[index].rch].lnum&gt;=size)</span><br><span class="line">                            temp=tree[tree[index].lch].right-tree[tree[index].lch].rnum+<span class="number">1</span>;</span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span>(tree[tree[index].rch].num&gt;=size) temp=find(size,tree[index].rch);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> temp;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> left,<span class="keyword">long</span> right,<span class="keyword">long</span> index,<span class="keyword">bool</span> del)</span></span>&#123;</span><br><span class="line">                  <span class="keyword">if</span>(!index) <span class="keyword">return</span>;</span><br><span class="line">                  <span class="keyword">if</span>(tree[index].left&gt;=left &amp;&amp; tree[index].right&lt;=right)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!del) &#123;tree[index].lnum=tree[index].rnum=tree[index].num=<span class="number">0</span>;tree[index].mark=<span class="number">1</span>;&#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;tree[index].lnum=tree[index].rnum=tree[index].num=tree[index].all;tree[index].mark=<span class="number">0</span>;&#125;</span><br><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(tree[index].mark!=<span class="number">2</span>) downset(index,tree[index].mark);</span><br><span class="line">                        <span class="keyword">if</span>(left&lt;=tree[index].mid) insert(left,right,tree[index].lch,del);</span><br><span class="line">                        <span class="keyword">if</span>(right&gt;tree[index].mid) insert(left,right,tree[index].rch,del);</span><br><span class="line">                        refresh(index);</span><br><span class="line">                  &#125;</span><br><span class="line">             &#125;</span><br><span class="line">&#125;line;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    line.build(<span class="number">1</span>,n,tot);</span><br><span class="line">    <span class="keyword">long</span> a,b,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">             <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">             <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">                      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b);</span><br><span class="line">                      <span class="keyword">if</span>(tree[<span class="number">1</span>].num&lt;b) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">                      <span class="keyword">else</span>&#123;</span><br><span class="line">                           c=line.find(b,<span class="number">1</span>);</span><br><span class="line">                           <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,c);</span><br><span class="line">                           line.insert(c,c+b<span class="number">-1</span>,<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;b,&amp;c);</span><br><span class="line">                   line.insert(b,b+c<span class="number">-1</span>,<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">             &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>Middle (省选)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;裸的线段树，线段树能解决的问题很多，这道题目是非常典型的线段染色问题。有三种状态，无色（空），满色（有人），杂色。主要考察的也就是实现线段树的惰性，即懒操作。修改颜色时不是一改到底的，在适当粒度的区间做好标记，当出现更细粒度（小于某个区间）的操作时再下放。例如：区间[1,10]标记为客满，同时区间[1,2]标记为空是可以在某些时刻共存的，想想为什么。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="线段树" scheme="http://izhen.me/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="染色" scheme="http://izhen.me/tags/%E6%9F%93%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>USACO 3.1.4 Rect1</title>
    <link href="http://izhen.me/2010/02/01/usaco_314/"/>
    <id>http://izhen.me/2010/02/01/usaco_314/</id>
    <published>2010-02-01T15:39:27.000Z</published>
    <updated>2018-09-30T06:22:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>刚一读题，第一反应就是朴素染色，但是因为较大的数据，染色法绝对行不通。因为我们没有必要重复覆盖某个点，包括计算面积我们不需要统计，而是直接用坐标计算。所以可以考虑使用面向矩形整体的方法：</p><ol><li>二维线段树或者离散化 + 线段树：这种方法的弊端是要么过于复杂，要么MLE，所以牛刀还是用来屠牛吧</li><li>我具体论述一下矩形切割：首先通过分析我们知道凡是在后面覆盖过的绝对不会被前面的覆盖，因此假设我们覆盖第N个矩形，那么第(N-1)个一定在它的下面，由此知道要倒序染色(1)，这样可以省去很多的操作；而两个矩形相交如何处理呢？我们知道：如果两个矩形相交，他们的交集必定是一个矩形，记录一个矩形只需两个对角坐标，处理方便，所以我们要对每次的覆盖进行切割(2)；</li></ol><a id="more"></a><p><img src="/image/idealnova/314.jpg" alt="USACO 3.1.4"></p><p>如图：中心深蓝色的表示当前已经覆盖的矩形，他的相邻四个A1，A2，A3，A4则是去掉已占据部分后被分割的四个矩形，也就是说凡是去掉交集都可把剩余的(未染色)部分切割成4个新矩形，包括面积为0的矩形。图中黄色的为待占据矩形，因为是倒序染色，所以忽略与已占据部分的交集，也就是说我们只需考虑未染色的部分(3)，记录未染色部分，并与未染色部分进行覆盖判断，因此黄色的与A1部分交集是 1，覆盖后，A部分又可以划分为4个新的矩形B1，B2，B3，B4(B3的面积为0)，可以看出整体是一个分治策略(4)。</p><p>综合以上(1)(2)(3)(4)条，我们对未染色部分进行处理，根据这种思路，可以不用递归，加一个链表记录所有的新的矩形，牺牲空间换取时间，平均时间复杂度O(n^2)。可以秒出。</p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>Compiling…<br>Compile: OK<br>Executing…<br>   Test 1: TEST OK [0.000 secs, 2956 KB]<br>   Test 2: TEST OK [0.000 secs, 2956 KB]<br>   Test 3: TEST OK [0.011 secs, 2956 KB]<br>   Test 4: TEST OK [0.000 secs, 2956 KB]<br>   Test 5: TEST OK [0.011 secs, 2956 KB]<br>   Test 6: TEST OK [0.000 secs, 2956 KB]<br>   Test 7: TEST OK [0.011 secs, 2956 KB]<br>   Test 8: TEST OK [0.011 secs, 2956 KB]<br>   Test 9: TEST OK [0.000 secs, 2956 KB]<br>   Test 10: TEST OK [0.011 secs, 2956 KB]<br>   Test 11: TEST OK [0.011 secs, 2956 KB]<br>All tests OK.<br>Your program (‘rect1’) produced all correct answers! This is your<br>submission #2 for this problem. Congratulations! //坐标确实是本题令我头疼的地方 .</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span> <span class="params">(<span class="string">"rect1.out"</span>,ios::out)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span> <span class="params">(<span class="string">"rect1.in"</span>,ios::in)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> MAX = <span class="number">1001</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">long</span> llx,lly,urx,ury,colour;</span><br><span class="line">&#125;rect[MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link1</span>&#123;</span></span><br><span class="line">  <span class="keyword">long</span> llx,lly,urx,ury;</span><br><span class="line">  link1 *next,*up;</span><br><span class="line">&#125;*head,*tail;</span><br><span class="line"><span class="keyword">long</span> a,b,n,ans[<span class="number">2501</span>];</span><br><span class="line"><span class="keyword">bool</span> quit;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">TMAX</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b)</span> </span>&#123;<span class="keyword">return</span> (a&gt;b?a:b);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">TMIN</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b)</span> </span>&#123;<span class="keyword">return</span> (a&lt;b?a:b);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> llx,<span class="keyword">long</span> lly,<span class="keyword">long</span> urx,<span class="keyword">long</span> ury,link1 *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(llx==urx || lly==ury) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//the area cannot be zero</span></span><br><span class="line">  link1 *temp=<span class="keyword">new</span> link1;</span><br><span class="line">  temp-&gt;llx=llx;</span><br><span class="line">  temp-&gt;lly=lly;</span><br><span class="line">  temp-&gt;urx=urx;</span><br><span class="line">  temp-&gt;ury=ury;</span><br><span class="line">  t-&gt;next=temp;</span><br><span class="line">  temp-&gt;up=t;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  link1 *temp,*ttail;</span><br><span class="line">  <span class="keyword">long</span> s=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) <span class="comment">//倒序染色</span></span><br><span class="line">  &#123;</span><br><span class="line">    temp=head;</span><br><span class="line">    ttail=tail;</span><br><span class="line">quit=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(rect[i].urx&lt;=temp-&gt;llx || temp-&gt;urx&lt;=rect[i].llx || rect[i].ury&lt;=temp-&gt;lly || temp-&gt;ury&lt;=rect[i].lly)</span><br><span class="line">      &#123;<span class="comment">//判断是否有交集</span></span><br><span class="line"><span class="keyword">if</span>(temp==tail) quit=<span class="literal">true</span>;<span class="comment">//quit</span></span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">//扩展</span></span><br><span class="line">      &#123;<span class="comment">//计算交集面积</span></span><br><span class="line">      <span class="keyword">long</span> x1=TMIN(rect[i].urx,temp-&gt;urx),x2=TMAX(rect[i].llx,temp-&gt;llx),</span><br><span class="line">   y1=TMIN(rect[i].ury,temp-&gt;ury),y2=TMAX(rect[i].lly,temp-&gt;lly);</span><br><span class="line">      <span class="keyword">if</span>(rect[i].colour!=<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">      s=(x1-x2)*(y1-y2);</span><br><span class="line">      ans[rect[i].colour]+=s;</span><br><span class="line">      ans[<span class="number">1</span>]-=s;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(rect[i].ury&lt;temp-&gt;ury) <span class="keyword">if</span>(add(temp-&gt;llx,rect[i].ury,temp-&gt;urx,temp-&gt;ury,ttail)) ttail=ttail-&gt;next; <span class="comment">//1</span></span><br><span class="line">      <span class="keyword">if</span>(rect[i].lly&gt;temp-&gt;lly) <span class="keyword">if</span>(add(temp-&gt;llx,temp-&gt;lly,temp-&gt;urx,rect[i].lly,ttail)) ttail=ttail-&gt;next;<span class="comment">//3</span></span><br><span class="line">      <span class="keyword">if</span>(rect[i].llx&gt;temp-&gt;llx) <span class="keyword">if</span>(add(temp-&gt;llx,y2,rect[i].llx,y1,ttail)) ttail=ttail-&gt;next; <span class="comment">//2</span></span><br><span class="line">      <span class="keyword">if</span>(rect[i].urx&lt;temp-&gt;urx) <span class="keyword">if</span>(add(rect[i].urx,y2,temp-&gt;urx,y1,ttail)) ttail=ttail-&gt;next; <span class="comment">//4</span></span><br><span class="line">      link1 *tdelete=temp;<span class="comment">//删除扩展完毕的矩形</span></span><br><span class="line">      <span class="keyword">if</span>(temp==tail) quit=<span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(temp==head) &#123; head=temp-&gt;next;head-&gt;up=<span class="literal">NULL</span>;&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">      temp-&gt;up-&gt;next=temp-&gt;next;</span><br><span class="line">      temp-&gt;next-&gt;up=temp-&gt;up;</span><br><span class="line">      &#125;</span><br><span class="line">      temp=temp-&gt;next;</span><br><span class="line">      <span class="keyword">delete</span> tdelete;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(quit) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tail=ttail;<span class="comment">//refresh</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  fin&gt;&gt;a&gt;&gt;b&gt;&gt;n;</span><br><span class="line">  ans[<span class="number">1</span>]=a*b;</span><br><span class="line">  head=<span class="keyword">new</span> link1;</span><br><span class="line">  head-&gt;llx=<span class="number">0</span>;</span><br><span class="line">  head-&gt;lly=<span class="number">0</span>;</span><br><span class="line">  head-&gt;urx=a;</span><br><span class="line">  head-&gt;ury=b;</span><br><span class="line">  tail=head;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    fin&gt;&gt;rect[i].llx&gt;&gt;rect[i].lly&gt;&gt;rect[i].urx&gt;&gt;rect[i].ury&gt;&gt;rect[i].colour;</span><br><span class="line">  work(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2500</span>;i++)</span><br><span class="line">    <span class="keyword">if</span>(ans[i]!=<span class="number">0</span>) fout&lt;&lt;i&lt;&lt;<span class="string">' '</span>&lt;&lt;ans[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本文是百度空间的移植，附：全部<a href="https://github.com/i-zhen/USACO-training" target="_blank" rel="noopener">USACO题目解答</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;刚一读题，第一反应就是朴素染色，但是因为较大的数据，染色法绝对行不通。因为我们没有必要重复覆盖某个点，包括计算面积我们不需要统计，而是直接用坐标计算。所以可以考虑使用面向矩形整体的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;二维线段树或者离散化 + 线段树：这种方法的弊端是要么过于复杂，要么MLE，所以牛刀还是用来屠牛吧&lt;/li&gt;
&lt;li&gt;我具体论述一下矩形切割：首先通过分析我们知道凡是在后面覆盖过的绝对不会被前面的覆盖，因此假设我们覆盖第N个矩形，那么第(N-1)个一定在它的下面，由此知道要倒序染色(1)，这样可以省去很多的操作；而两个矩形相交如何处理呢？我们知道：如果两个矩形相交，他们的交集必定是一个矩形，记录一个矩形只需两个对角坐标，处理方便，所以我们要对每次的覆盖进行切割(2)；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="矩形切割" scheme="http://izhen.me/tags/%E7%9F%A9%E5%BD%A2%E5%88%87%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>NOI2004郁闷的出纳员</title>
    <link href="http://izhen.me/2010/01/04/noi2007/"/>
    <id>http://izhen.me/2010/01/04/noi2007/</id>
    <published>2010-01-03T21:38:37.000Z</published>
    <updated>2018-09-24T05:59:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>这是一道考察数据结构的题目，理论上使用静态的会更好，不见得动态的就快，但是我是使用Treap AC的。原理很简单，就是需要额外再用一个delta来记录差量，避免Treap退化，所以在加入一个节点时 ，要减去这个差量，最后输出时加上即可。然后’S’、’A’操作只改变delta，剩下的就是实现了。</p><a id="more"></a><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p>自己测试AC，此刻NOI的那个OJ挂了 = =|||</p><p><img src="/image/idealnova/noi2004.png" alt="NOI 2004"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"test.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"test.out"</span>)</span></span>;</span><br><span class="line"><span class="keyword">long</span> n,minx,k,delta=<span class="number">0</span>,tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> weight,value,size;</span><br><span class="line">    node *left,*right;<span class="comment">//不必记录祖先</span></span><br><span class="line">&#125;*root,*son;<span class="comment">//建立超级父亲,超级子孙</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bst</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> node *<span class="title">newnode</span><span class="params">(<span class="keyword">long</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">tot++;</span><br><span class="line">        node *tnode=<span class="keyword">new</span> node;</span><br><span class="line">        tnode-&gt;value=key;</span><br><span class="line">        tnode-&gt;weight=<span class="built_in">abs</span>(rand());</span><br><span class="line">        tnode-&gt;left=son;</span><br><span class="line">        tnode-&gt;right=son;</span><br><span class="line">Refresh(tnode);</span><br><span class="line">        <span class="keyword">return</span> tnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Refresh</span><span class="params">(node *tree)</span></span>&#123;tree-&gt;size=tree-&gt;left-&gt;size+tree-&gt;right-&gt;size+<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> node* <span class="title">leftrotate</span><span class="params">(node *tree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node *T=tree-&gt;right;</span><br><span class="line">        tree-&gt;right=T-&gt;left;</span><br><span class="line">        T-&gt;left=tree;</span><br><span class="line">        Refresh(tree);Refresh(T);</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> node *<span class="title">rightrotate</span><span class="params">(node *tree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node *T=tree-&gt;left;</span><br><span class="line">        tree-&gt;left=T-&gt;right;</span><br><span class="line">        T-&gt;right=tree;</span><br><span class="line">        Refresh(tree);Refresh(T);</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">node *<span class="title">insert</span><span class="params">(node *ins,node *index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ins-&gt;value&lt;=index-&gt;value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(index-&gt;left==son) index-&gt;left=ins;</span><br><span class="line">            <span class="keyword">else</span> index-&gt;left=insert(ins,index-&gt;left);<span class="comment">//更新子节点</span></span><br><span class="line">            <span class="keyword">if</span>(index-&gt;weight&gt;index-&gt;left-&gt;weight) index=rightrotate(index);<span class="comment">//更新父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(index-&gt;right==son) &#123;index-&gt;right=ins;&#125;</span><br><span class="line">            <span class="keyword">else</span> index-&gt;right=insert(ins,index-&gt;right);<span class="comment">//更新子节点</span></span><br><span class="line">            <span class="keyword">if</span>(index-&gt;weight&gt;index-&gt;right-&gt;weight) index=leftrotate(index);<span class="comment">//更新父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        Refresh(index);<span class="comment">//refresh</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">findk</span><span class="params">(<span class="keyword">long</span> rank)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node *temp=root-&gt;left;</span><br><span class="line"><span class="keyword">if</span>(temp-&gt;size&lt;rank) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(rank!=temp-&gt;size-temp-&gt;left-&gt;size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rank&lt;temp-&gt;size-temp-&gt;left-&gt;size) temp=temp-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> &#123;rank-=temp-&gt;size-temp-&gt;left-&gt;size;temp=temp-&gt;left;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tdelete</span><span class="params">(<span class="keyword">long</span> key,node *del)</span><span class="comment">//a whole subtree</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(del-&gt;left!=son)</span><br><span class="line">        <span class="keyword">if</span>(del-&gt;left-&gt;value+delta&lt;key)</span><br><span class="line">&#123;</span><br><span class="line">del-&gt;left=del-&gt;left-&gt;right;</span><br><span class="line">Refresh(del);</span><br><span class="line">tdelete(key,del);</span><br><span class="line">Refresh(del);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;tdelete(key,del-&gt;left);Refresh(del);&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;treap;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="number">0</span>));</span><br><span class="line">    son=<span class="keyword">new</span> node;</span><br><span class="line">    root=<span class="keyword">new</span> node;</span><br><span class="line">    son-&gt;weight=<span class="number">99999999</span>;</span><br><span class="line">    son-&gt;size=<span class="number">0</span>;</span><br><span class="line">    root-&gt;weight=<span class="number">-1</span>;</span><br><span class="line">    root-&gt;left=son;</span><br><span class="line">    root-&gt;right=son;</span><br><span class="line">    root-&gt;value=<span class="number">99999999</span>;</span><br><span class="line">    root-&gt;size=<span class="number">1</span>;</span><br><span class="line">fin&gt;&gt;n&gt;&gt;minx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">fin&gt;&gt;op;</span><br><span class="line"><span class="keyword">switch</span>(op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span>(<span class="string">'I'</span>):</span><br><span class="line">fin&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(k&gt;=minx) treap.insert(treap.newnode(k-delta),root);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span>(<span class="string">'S'</span>):</span><br><span class="line">fin&gt;&gt;k;</span><br><span class="line">delta-=k;</span><br><span class="line">treap.tdelete(minx,root);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span>(<span class="string">'A'</span>):</span><br><span class="line">fin&gt;&gt;k;</span><br><span class="line">delta+=k;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span>(<span class="string">'F'</span>):</span><br><span class="line">fin&gt;&gt;k;</span><br><span class="line">k=treap.findk(k);</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">-1</span>) fout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> fout&lt;&lt;k+delta&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fout&lt;&lt;tot-root-&gt;size+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>Medium (NOI the 1st)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;这是一道考察数据结构的题目，理论上使用静态的会更好，不见得动态的就快，但是我是使用Treap AC的。原理很简单，就是需要额外再用一个delta来记录差量，避免Treap退化，所以在加入一个节点时 ，要减去这个差量，最后输出时加上即可。然后’S’、’A’操作只改变delta，剩下的就是实现了。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="平衡树" scheme="http://izhen.me/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="Treap" scheme="http://izhen.me/tags/Treap/"/>
    
  </entry>
  
  <entry>
    <title>USACO 2.3.3 Cowtour</title>
    <link href="http://izhen.me/2010/01/01/usaco_243/"/>
    <id>http://izhen.me/2010/01/01/usaco_243/</id>
    <published>2010-01-01T15:39:27.000Z</published>
    <updated>2018-09-30T06:25:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>这道题目是图论问题，首先用floyd求出每对点的最短路，然后再找出单独每个点的可连接的最远的点(直径)，接下来就是计算两个分离牧区的直径。首先遍历所有不连通的点对，然后用这两点的距离加上两点原来的直径。如果更小，则更新直到结束。<br>但是还有一种特殊情况：“包含”。如果一个牧场恰好包含另一个，且大的牧场直径比计算出的要长一些，则结果应该是更大的那个才对。(参考图片：红色表示最终连接的结果，蓝色表示大牧场的直径，显然蓝色的才正确)</p><a id="more"></a><p><img src="/image/idealnova/234.jpg" alt="USACO 2.3.4"></p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>Compiling…<br>Compile: OK<br>Executing…<br>   Test 1: TEST OK [0.022 secs, 3108 KB]<br>   Test 2: TEST OK [0.011 secs, 3108 KB]<br>   Test 3: TEST OK [0.000 secs, 3108 KB]<br>   Test 4: TEST OK [0.011 secs, 3108 KB]<br>   Test 5: TEST OK [0.043 secs, 3108 KB]<br>   Test 6: TEST OK [0.032 secs, 3108 KB]<br>   Test 7: TEST OK [0.032 secs, 3108 KB]<br>   Test 8: TEST OK [0.065 secs, 3108 KB]<br>   Test 9: TEST OK [0.054 secs, 3108 KB]<br>All tests OK.<br>YOUR PROGRAM (‘cowtour’) WORKED FIRST TIME! That’s fantastic<br>– and a rare thing. Please accept these special automated<br>congratulations.</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span> <span class="params">(<span class="string">"cowtour.out"</span>,ios::out)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span> <span class="params">(<span class="string">"cowtour.in"</span>,ios::in)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> maxn=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">double</span> <span class="built_in">map</span>[<span class="number">151</span>][<span class="number">151</span>],pos[<span class="number">151</span>][<span class="number">2</span>],dmap[<span class="number">151</span>],dis=maxn,temp;</span><br><span class="line"><span class="keyword">long</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> te;</span><br><span class="line">  fin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fin&gt;&gt;pos[i][<span class="number">0</span>]&gt;&gt;pos[i][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">      fin&gt;&gt;te;</span><br><span class="line">      <span class="keyword">if</span>(te==<span class="string">'1'</span> ) <span class="built_in">map</span>[i][j]=<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(pos[i][<span class="number">0</span>]-pos[j][<span class="number">0</span>],<span class="number">2</span>)+<span class="built_in">pow</span>(pos[i][<span class="number">1</span>]-pos[j][<span class="number">1</span>],<span class="number">2</span>));</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">map</span>[i][j]=maxn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)  <span class="comment">//连通图,floyd</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">             <span class="keyword">if</span>(i!=j) <span class="built_in">map</span>[i][j]=((<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j]&lt;<span class="built_in">map</span>[i][j])?<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j]:<span class="built_in">map</span>[i][j]);</span><br><span class="line">                 </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//自身的最大距离</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">map</span>[i][j]&gt;dmap[i])&amp;&amp;(<span class="built_in">map</span>[i][j]&lt;maxn)) dmap[i]=<span class="built_in">map</span>[i][j];</span><br><span class="line">        <span class="keyword">if</span>(temp&lt;dmap[i]) temp=dmap[i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=n;p++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">1</span>;q&lt;=p;q++)</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">map</span>[p][q]==maxn)&amp;&amp;(p!=q))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">map</span>[p][q]=<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(pos[p][<span class="number">0</span>]-pos[q][<span class="number">0</span>],<span class="number">2</span>)+<span class="built_in">pow</span>(pos[p][<span class="number">1</span>]-pos[q][<span class="number">1</span>],<span class="number">2</span>));</span><br><span class="line">          <span class="keyword">if</span>(dis&gt;(<span class="built_in">map</span>[p][q]+dmap[p]+dmap[q])) dis=<span class="built_in">map</span>[p][q]+dmap[p]+dmap[q];</span><br><span class="line">          <span class="built_in">map</span>[p][q]=maxn;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dis&lt;temp) dis=temp;<span class="comment">//包含关系</span></span><br><span class="line">    fout.precision(<span class="number">6</span>); <span class="comment">//控制精度</span></span><br><span class="line">    fout.setf(ios::fixed); <span class="comment">//输出小数点</span></span><br><span class="line">    fout&lt;&lt;dis&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本文是百度空间的移植，附：全部<a href="https://github.com/i-zhen/USACO-training" target="_blank" rel="noopener">USACO题目解答</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;这道题目是图论问题，首先用floyd求出每对点的最短路，然后再找出单独每个点的可连接的最远的点(直径)，接下来就是计算两个分离牧区的直径。首先遍历所有不连通的点对，然后用这两点的距离加上两点原来的直径。如果更小，则更新直到结束。&lt;br&gt;但是还有一种特殊情况：“包含”。如果一个牧场恰好包含另一个，且大的牧场直径比计算出的要长一些，则结果应该是更大的那个才对。(参考图片：红色表示最终连接的结果，蓝色表示大牧场的直径，显然蓝色的才正确)&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="Graph" scheme="http://izhen.me/tags/Graph/"/>
    
      <category term="Floyd" scheme="http://izhen.me/tags/Floyd/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2001Car的旅行路线</title>
    <link href="http://izhen.me/2010/01/01/noip2001/"/>
    <id>http://izhen.me/2010/01/01/noip2001/</id>
    <published>2009-12-31T21:38:37.000Z</published>
    <updated>2018-09-24T02:46:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>新年第一题：这道题目很值得一说，首先这是一个比较典型的计算几何转化为图论去做，同时也是需要结合两者的不错的题目。大体思想是首先用向量法计算出第4个点，因为第4个点是现有的3个点中的作为现有RT三角形的一个对角点，所以先要确定直角点，用点积为0判定，剩下的很简单了。接着要建模为一张图，然后计算最短路径。大体就是这样。</p><p>关于计算最短路径：我的想法是先求出所有点对的最短路径，然后遍历A市与B市的飞机场选出一个最短的，但是这样似乎麻烦而且时效低，所以我介绍一下官方的强大方法：首先对于A市和B市，把他们的铁路价格都改为0，这样无论选择两个城市中的哪个机场，都不用额外花费铁路价格，把城市封装为一个整体，意味着A、B的机场任意。做一遍Dijkstra即可。</p><a id="more"></a><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p><img src="/image/idealnova/noip2001.jpg" alt="NOIP 2001"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Min(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> MAX = <span class="number">99999999.9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> <span class="comment">//存一个完整的矩形 </span></span><br><span class="line">    <span class="keyword">double</span> pos[<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line">&#125;rect[Max];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="comment">//存储飞机场</span></span><br><span class="line">     <span class="keyword">double</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> mark;</span><br><span class="line">    <span class="keyword">double</span> val;</span><br><span class="line">&#125;plane[<span class="number">4</span>*Max];</span><br><span class="line"><span class="keyword">double</span> dis[<span class="number">4</span>*Max],val[Max],t;</span><br><span class="line"><span class="keyword">int</span> n,s,A,B,now,now2,A1,B1;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">4</span>*Max];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">compute</span><span class="params">(node rect,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123; <span class="comment">//计算点积 </span></span><br><span class="line">    <span class="keyword">double</span> x1,y1,x2,y2;</span><br><span class="line">    x1=rect.pos[a][<span class="number">0</span>]-rect.pos[c][<span class="number">0</span>];</span><br><span class="line">    y1=rect.pos[a][<span class="number">1</span>]-rect.pos[c][<span class="number">1</span>];</span><br><span class="line">    x2=rect.pos[b][<span class="number">0</span>]-rect.pos[c][<span class="number">0</span>];</span><br><span class="line">    y2=rect.pos[b][<span class="number">1</span>]-rect.pos[c][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> x1*x2+y1*y2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(node &amp;rect,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123; <span class="comment">//计算第4个点</span></span><br><span class="line">    rect.pos[<span class="number">4</span>][<span class="number">0</span>]=rect.pos[a][<span class="number">0</span>]+rect.pos[b][<span class="number">0</span>]-rect.pos[c][<span class="number">0</span>];</span><br><span class="line">    rect.pos[<span class="number">4</span>][<span class="number">1</span>]=rect.pos[a][<span class="number">1</span>]+rect.pos[b][<span class="number">1</span>]-rect.pos[c][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">the4th</span><span class="params">(node &amp;rect)</span></span>&#123; <span class="comment">//枚举直角点 </span></span><br><span class="line">    <span class="keyword">if</span>(compute(rect,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        cal(rect,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(compute(rect,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        cal(rect,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(compute(rect,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        cal(rect,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dist</span><span class="params">(Node a,Node b)</span></span>&#123; <span class="comment">//计算距离 </span></span><br><span class="line">    <span class="keyword">double</span> len=<span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">    <span class="keyword">if</span>(a.mark==b.mark)&#123;</span><br><span class="line">       <span class="keyword">if</span>(a.mark==A1 || a.mark==B1) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//important</span></span><br><span class="line">       <span class="keyword">return</span> len*a.val;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> len*t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s&gt;&gt;t&gt;&gt;A&gt;&gt;B;</span><br><span class="line">    A1=A;B1=B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++) dis[i]=MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++) <span class="built_in">cin</span>&gt;&gt;rect[i].pos[j][<span class="number">0</span>]&gt;&gt;rect[i].pos[j][<span class="number">1</span>];</span><br><span class="line">        the4th(rect[i]);</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;val[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">4</span>;k++)&#123; <span class="comment">//建成图</span></span><br><span class="line">            plane[<span class="number">4</span>*(i<span class="number">-1</span>)+k].x=rect[i].pos[k][<span class="number">0</span>]; </span><br><span class="line">            plane[<span class="number">4</span>*(i<span class="number">-1</span>)+k].y=rect[i].pos[k][<span class="number">1</span>];</span><br><span class="line">            plane[<span class="number">4</span>*(i<span class="number">-1</span>)+k].mark=i; <span class="comment">//标记属于哪个城市</span></span><br><span class="line">            plane[<span class="number">4</span>*(i<span class="number">-1</span>)+k].val=val[i]; <span class="comment">// 铁路费用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A*=<span class="number">4</span>;B*=<span class="number">4</span>; <span class="comment">//选择 A,B市的最后一个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>*s;i++) <span class="comment">//dijkstra</span></span><br><span class="line">        dis[i]=dist(plane[i],plane[A]);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">double</span> MIN=MAX;</span><br><span class="line">        now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s*<span class="number">4</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[i] &amp;&amp; MIN&gt;dis[i])&#123;</span><br><span class="line">                MIN=dis[i];</span><br><span class="line">                now=i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(now!=<span class="number">0</span>)&#123;</span><br><span class="line">            vis[now]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s*<span class="number">4</span>;i++)</span><br><span class="line">                <span class="keyword">if</span>(!vis[i]) dis[i]=Min(dis[i],dis[now]+dist(plane[now],plane[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(now!=<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(<span class="number">1</span>)&lt;&lt;dis[B]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>Middle Up(Noip the 4th)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;新年第一题：这道题目很值得一说，首先这是一个比较典型的计算几何转化为图论去做，同时也是需要结合两者的不错的题目。大体思想是首先用向量法计算出第4个点，因为第4个点是现有的3个点中的作为现有RT三角形的一个对角点，所以先要确定直角点，用点积为0判定，剩下的很简单了。接着要建模为一张图，然后计算最短路径。大体就是这样。&lt;/p&gt;
&lt;p&gt;关于计算最短路径：我的想法是先求出所有点对的最短路径，然后遍历A市与B市的飞机场选出一个最短的，但是这样似乎麻烦而且时效低，所以我介绍一下官方的强大方法：首先对于A市和B市，把他们的铁路价格都改为0，这样无论选择两个城市中的哪个机场，都不用额外花费铁路价格，把城市封装为一个整体，意味着A、B的机场任意。做一遍Dijkstra即可。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="计算几何" scheme="http://izhen.me/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
      <category term="图论" scheme="http://izhen.me/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CSAPC09 质均数</title>
    <link href="http://izhen.me/2009/11/09/CSAPC09/"/>
    <id>http://izhen.me/2009/11/09/CSAPC09/</id>
    <published>2009-11-08T21:38:37.000Z</published>
    <updated>2018-09-23T16:51:25.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><ol><li>直接找规律，第一个是5，第二个就是下一个质数7，以此类推……</li><li>发现关系后用规律去做：关系是任何一个质数(&gt;=5)都可以被两个质数相加除以2得到。(仅为猜想，没有证明)，然后就直接有了一个直接找规律</li></ol><a id="more"></a><h4 id="运行情况"><a href="#运行情况" class="headerlink" title="运行情况"></a>运行情况</h4><p><img src="/image/idealnova/csapc09.jpg" alt="CSAPC 09"></p><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> n,num[<span class="number">4</span>],maxn,num1[<span class="number">451</span>];</span><br><span class="line"><span class="keyword">bool</span> prime[<span class="number">1000001</span>];<span class="comment">//肯定有猛人交一个450字元的表, 其实构造素数也不会超时 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="built_in">cin</span>&gt;&gt;num[i];<span class="keyword">if</span>(num[i]&gt;maxn) maxn=num[i];&#125;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">2</span>;i&lt;=<span class="number">50000</span>;i++)<span class="comment">//我就懒得优化了 ,直接枚举!!!</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(!prime[i])</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">long</span> j=<span class="number">2</span>;j&lt;=<span class="number">100000</span>;j++)</span><br><span class="line">      <span class="keyword">if</span>(j*i&lt;=<span class="number">1000000</span>)</span><br><span class="line">        prime[j*i]=<span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">5</span>;i&lt;=<span class="number">1000000</span>;i++)</span><br><span class="line">    <span class="keyword">if</span>(!prime[i])</span><br><span class="line">    &#123;</span><br><span class="line">      k++;</span><br><span class="line">      <span class="keyword">if</span>(k&lt;=maxn)</span><br><span class="line">        num1[k]=i;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;num1[num[i]]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果我没有看错ZeroJudge给的难度是3，其实应该改为1.因为我大概迟到了一个小时考试，再加上一试考的不好，所以就做了这道(当时一看就知道这题好做)，然后就离场了。另外我比较感兴趣的是第3题，有时间写个题解</p><h4 id="难易等级"><a href="#难易等级" class="headerlink" title="难易等级"></a>难易等级</h4><p>So Easy(Noip the 1st)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;直接找规律，第一个是5，第二个就是下一个质数7，以此类推……&lt;/li&gt;
&lt;li&gt;发现关系后用规律去做：关系是任何一个质数(&amp;gt;=5)都可以被两个质数相加除以2得到。(仅为猜想，没有证明)，然后就直接有了一个直接找规律&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="C++" scheme="http://izhen.me/tags/C/"/>
    
      <category term="Ad Hoc" scheme="http://izhen.me/tags/Ad-Hoc/"/>
    
  </entry>
  
  <entry>
    <title>双星物语II</title>
    <link href="http://izhen.me/2009/08/04/ZEWII/"/>
    <id>http://izhen.me/2009/08/04/ZEWII/</id>
    <published>2009-08-04T14:22:45.000Z</published>
    <updated>2018-09-23T10:12:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/idealnova/zwei1.jpg" alt="ZWEI 2"></p><p>此时此刻,双星2终于破关,好辛苦!!!(我很菜)<br>感觉极其磨，剧情还可以，不知还有哪个OIer，玩这个游戏。<br>eeeeeeeeeeeeeeeeee………..</p><a id="more"></a><p><img src="/image/idealnova/zwei2.jpg" alt="ZWEI 1"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/image/idealnova/zwei1.jpg&quot; alt=&quot;ZWEI 2&quot;&gt;&lt;/p&gt;
&lt;p&gt;此时此刻,双星2终于破关,好辛苦!!!(我很菜)&lt;br&gt;感觉极其磨，剧情还可以，不知还有哪个OIer，玩这个游戏。&lt;br&gt;eeeeeeeeeeeeeeeeee………..&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="game" scheme="http://izhen.me/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>KUBUNTU</title>
    <link href="http://izhen.me/2009/05/04/KUBUNTU/"/>
    <id>http://izhen.me/2009/05/04/KUBUNTU/</id>
    <published>2009-05-04T13:04:36.000Z</published>
    <updated>2018-09-23T10:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>新的赛季开始了，拥有了新的环境：新的ubuntu 9.04 kde(kubuntu)很爽</p><a id="more"></a><p><img src="/image/idealnova/k1.jpeg" alt="Kubuntu"></p><p>(^-^)，KDE 4.2</p><p><img src="/image/idealnova/k2.jpeg" alt="Kubuntu"></p><p>感觉kde比gnome的界面爽多了，更加专业，不过面临的缺陷就是：流传已久的稳定性问题，但是这阻挡不了我的选择道路，特别是某些小工具gnome比不了，kde也更加方便。</p><p>编程足够了，目前还是喜欢p,c,cpp通吃的<a href="https://sourceforge.net/p/mannaide/wiki/Home/" target="_blank" rel="noopener">Manna IDE</a>(我国改版:guide),尽管调试有bug。还好，k与g偶尔交互着使用（当k不稳定时，总不能次次重启吧，对PC不好.</p><p>不过稳定性,还是windows好些,毕竟是商业的，END.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新的赛季开始了，拥有了新的环境：新的ubuntu 9.04 kde(kubuntu)很爽&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="linux" scheme="http://izhen.me/tags/linux/"/>
    
      <category term="KDE" scheme="http://izhen.me/tags/KDE/"/>
    
  </entry>
  
  <entry>
    <title>USACO 2.3.4 Money</title>
    <link href="http://izhen.me/2009/04/27/usaco_234/"/>
    <id>http://izhen.me/2009/04/27/usaco_234/</id>
    <published>2009-04-27T09:59:40.000Z</published>
    <updated>2018-09-23T14:04:58.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>这道题目有必要解释一下我写的DP，a[j]=a[j]+a[j-k] (0&lt;=j&lt;=n)，其中k为当前面值，思想是这样的：f[j]是用j面值可组成钱的方案数，事实上就是先降维后记忆化搜索的背包，原来的方程是：f[i,j]=f[i-1,j]+f[i,j-k]因为选中k后还可以再次选择(01背包只能选一次)所以第二个式子是i而不是i-1。</p><a id="more"></a><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>Compiling…<br>Compile: OK</p><p>Executing…<br>   Test 1: TEST OK [0.000 secs, 288 KB]<br>   Test 2: TEST OK [0.011 secs, 288 KB]<br>   Test 3: TEST OK [0.000 secs, 284 KB]<br>   Test 4: TEST OK [0.000 secs, 284 KB]<br>   Test 5: TEST OK [0.000 secs, 288 KB]<br>   Test 6: TEST OK [0.000 secs, 284 KB]<br>   Test 7: TEST OK [0.000 secs, 284 KB]<br>   Test 8: TEST OK [0.000 secs, 284 KB]<br>   Test 9: TEST OK [0.011 secs, 284 KB]<br>   Test 10: TEST OK [0.000 secs, 288 KB]<br>   Test 11: TEST OK [0.000 secs, 284 KB]<br>   Test 12: TEST OK [0.000 secs, 288 KB]<br>   Test 13: TEST OK [0.000 secs, 288 KB]</p><p>All tests OK.<br>Your program (‘money’) produced all correct answers!  This is your<br>submission #1 for this problem.  Congratulations!</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> money;</span><br><span class="line"><span class="keyword">var</span> v,n,i,j,k:integer;</span><br><span class="line">  a:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10000</span>]<span class="keyword">of</span> int64;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  assign(input,<span class="string">'money.in'</span>);</span><br><span class="line">  reset(input);</span><br><span class="line">  assign(output,<span class="string">'money.out'</span>);</span><br><span class="line">  rewrite(output);</span><br><span class="line">  readln(v,n);</span><br><span class="line">  a[<span class="number">0</span>]:=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> v <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">read</span>(k);</span><br><span class="line">    <span class="keyword">for</span> j:=k <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">      a[j]:=a[j]+a[j-k];</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">  writeln(a[n]);</span><br><span class="line">  close(input);</span><br><span class="line">  close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本文是原新浪博客的移植，附：全部<a href="https://github.com/i-zhen/USACO-training" target="_blank" rel="noopener">USACO题目解答</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;这道题目有必要解释一下我写的DP，a[j]=a[j]+a[j-k] (0&amp;lt;=j&amp;lt;=n)，其中k为当前面值，思想是这样的：f[j]是用j面值可组成钱的方案数，事实上就是先降维后记忆化搜索的背包，原来的方程是：f[i,j]=f[i-1,j]+f[i,j-k]因为选中k后还可以再次选择(01背包只能选一次)所以第二个式子是i而不是i-1。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="DP" scheme="http://izhen.me/tags/DP/"/>
    
      <category term="Pascal" scheme="http://izhen.me/tags/Pascal/"/>
    
  </entry>
  
  <entry>
    <title>USACO 2.3.5 Concom</title>
    <link href="http://izhen.me/2009/04/26/usaco_235/"/>
    <id>http://izhen.me/2009/04/26/usaco_235/</id>
    <published>2009-04-25T17:57:26.000Z</published>
    <updated>2018-09-23T14:01:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题过了，但是这道题就不贴时间和程序的全部了，因为我原来用超级复杂的邻接表做的，最后的一个数据没有过(第9个)，后来发现邻接矩阵这么简单，于是此刻我充分感受到了KISS原则的宝贵，毕竟usaco的第二章不会考到多么精尖的算法，与其用2、3个小时编写一个0s的程序，倒不如用40min写一个0.1s的程序的性价比高！！！</p><a id="more"></a><p>邻接矩阵:</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">DFS</span> <span class="params">(s:byte)</span>;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  i:byte;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> vis[s] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">  vis[s]:=true;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    inc(cx[i],con[s,i]);</span><br><span class="line">    <span class="keyword">if</span> cx[i]&gt;<span class="number">50</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      own[i]:=true;</span><br><span class="line">      DFS(i);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>邻接表:</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs1</span><span class="params">(x,y:integer)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j:integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">if</span> b[x]=false <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line"> b[x]:=false;</span><br><span class="line"> <span class="keyword">if</span> x&lt;&gt;y <span class="keyword">then</span></span><br><span class="line"> <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> a[x].next <span class="keyword">do</span></span><br><span class="line">   <span class="keyword">if</span> (a[x].jie[i]=y) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">begin</span> a[x].flag[a[x].jie[i]]:=true; <span class="keyword">end</span>;</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> a[x].next <span class="keyword">do</span></span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> a[y].next <span class="keyword">do</span></span><br><span class="line">     <span class="keyword">if</span> (a[y].jie[j]=a[x].jie[i])<span class="keyword">and</span>(<span class="keyword">not</span> a[x].flag[i]) <span class="keyword">then</span></span><br><span class="line">     <span class="keyword">begin</span></span><br><span class="line">      a[y].jdata[j]:=a[x].jdata[i]+a[y].jdata[j];</span><br><span class="line">      a[x].flag[i]:=true;</span><br><span class="line">     <span class="keyword">end</span>;</span><br><span class="line">   <span class="keyword">end</span>;</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> a[x].next <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> a[x].flag[i])<span class="keyword">and</span>(a[x].jie[i]&lt;&gt;y)<span class="keyword">then</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">     inc(a[y].next);</span><br><span class="line">     a[y].jie[a[y].next]:=a[x].jie[i];</span><br><span class="line">     a[y].jdata[a[y].next]:=a[x].jdata[i];</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"> <span class="keyword">end</span>;</span><br><span class="line"> <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> a[x].next <span class="keyword">do</span></span><br><span class="line"> <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> (a[x].jie[i]&lt;&gt;y)<span class="keyword">and</span> b[a[x].jie[i]] <span class="keyword">and</span> (a[x].jdata[i]&gt;<span class="number">50</span>)</span><br><span class="line">   <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">    dfs1(a[x].jie[i],y);</span><br><span class="line">   <span class="keyword">end</span>;</span><br><span class="line"> <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>差距很大吧，不但如此，矩阵不必排序，而表则还另需排序，就算是我练习编程吧。RP……</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本文是原新浪博客的移植，附：全部<a href="https://github.com/i-zhen/USACO-training" target="_blank" rel="noopener">USACO题目解答</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题过了，但是这道题就不贴时间和程序的全部了，因为我原来用超级复杂的邻接表做的，最后的一个数据没有过(第9个)，后来发现邻接矩阵这么简单，于是此刻我充分感受到了KISS原则的宝贵，毕竟usaco的第二章不会考到多么精尖的算法，与其用2、3个小时编写一个0s的程序，倒不如用40min写一个0.1s的程序的性价比高！！！&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="Graph" scheme="http://izhen.me/tags/Graph/"/>
    
      <category term="Pascal" scheme="http://izhen.me/tags/Pascal/"/>
    
  </entry>
  
  <entry>
    <title>USACO 2.3.3 Zerosum</title>
    <link href="http://izhen.me/2009/04/24/usaco_233/"/>
    <id>http://izhen.me/2009/04/24/usaco_233/</id>
    <published>2009-04-24T15:29:27.000Z</published>
    <updated>2018-09-23T14:17:59.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>本题不难，但是由于没有好的算术方案，所以编的时间长，又因为pascal递归不稳定，所以调试时间长，提交了三次</p><a id="more"></a><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>Compiling…<br>Compile: OK</p><p>Executing…<br>   Test 1: TEST OK [0.000 secs, 204 KB]<br>   Test 2: TEST OK [0.000 secs, 204 KB]<br>   Test 3: TEST OK [0.000 secs, 208 KB]<br>   Test 4: TEST OK [0.000 secs, 208 KB]<br>   Test 5: TEST OK [0.000 secs, 204 KB]<br>   Test 6: TEST OK [0.011 secs, 208 KB]<br>   Test 7: TEST OK [0.011 secs, 208 KB]</p><p>All tests OK.<br>Your program (‘zerosum’) produced all correct answers!  This is your<br>submission #3 for this problem.  Congratulations!</p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> test;</span><br><span class="line"><span class="keyword">type</span> node=<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">8</span>]<span class="keyword">of</span> integer;</span><br><span class="line"><span class="keyword">var</span> n:<span class="number">3</span>..<span class="number">9</span>;</span><br><span class="line">         a:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">9</span>]<span class="keyword">of</span> integer;</span><br><span class="line">         b1:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">9</span>]<span class="keyword">of</span> integer;</span><br><span class="line">         total:longint;</span><br><span class="line">         b:node;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">print</span><span class="params">(c:node)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">         <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">         <span class="keyword">begin</span></span><br><span class="line">                   <span class="keyword">case</span> c[i-<span class="number">1</span>] <span class="keyword">of</span></span><br><span class="line">                   <span class="number">1</span>:<span class="keyword">begin</span></span><br><span class="line">                            <span class="keyword">write</span>(a[i-<span class="number">1</span>],<span class="string">' '</span>);</span><br><span class="line">                            <span class="keyword">end</span>;</span><br><span class="line">                   <span class="number">2</span>:<span class="keyword">begin</span></span><br><span class="line">                            <span class="keyword">write</span>(a[i-<span class="number">1</span>],<span class="string">'+'</span>);</span><br><span class="line">                            <span class="keyword">end</span>;</span><br><span class="line">                   <span class="number">3</span>:<span class="keyword">begin</span></span><br><span class="line">                            <span class="keyword">write</span>(a[i-<span class="number">1</span>],<span class="string">'-'</span>);</span><br><span class="line">                            <span class="keyword">end</span>;</span><br><span class="line">                   <span class="keyword">end</span>;</span><br><span class="line">         <span class="keyword">end</span>;</span><br><span class="line">         writeln(a[n]);</span><br><span class="line">         <span class="comment">&#123;for i:=1 to n-1 do</span></span><br><span class="line"><span class="comment">                   write(c[i],' ');</span></span><br><span class="line"><span class="comment">         writeln;&#125;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">pd</span><span class="params">(c:node)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,temp,temp2:integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">         fillchar(b1,sizeof(b1),<span class="number">0</span>);</span><br><span class="line">         total:=<span class="number">0</span>;temp:=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">         <span class="keyword">begin</span></span><br><span class="line">                   <span class="keyword">if</span> c[i]=<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">                   <span class="keyword">begin</span></span><br><span class="line">                            <span class="keyword">if</span> c[i-<span class="number">1</span>]=<span class="number">1</span> <span class="keyword">then</span> total:=total*<span class="number">10</span>+a[i+<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> c[i-<span class="number">1</span>]&lt;&gt;<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                     total:=a[i];</span><br><span class="line">                                     total:=total*<span class="number">10</span>+a[i+<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">end</span>;</span><br><span class="line">                            <span class="keyword">if</span> c[i+<span class="number">1</span>]&lt;&gt;<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">                            <span class="keyword">begin</span> inc(temp);b1[temp]:=total;<span class="keyword">end</span>;</span><br><span class="line">                   <span class="keyword">end</span>;</span><br><span class="line">         <span class="keyword">end</span>;</span><br><span class="line">         temp:=<span class="number">1</span>;temp2:=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span> c[<span class="number">1</span>]=<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">begin</span> total:=b1[<span class="number">1</span>];inc(temp2);<span class="keyword">end</span></span><br><span class="line">                   <span class="keyword">else</span> total:=a[<span class="number">1</span>];</span><br><span class="line">         <span class="keyword">while</span> temp&lt;n <span class="keyword">do</span></span><br><span class="line">         <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> c[temp]&lt;&gt;<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">                   <span class="keyword">begin</span></span><br><span class="line">                   <span class="keyword">if</span> c[temp+<span class="number">1</span>]&lt;&gt;<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">                            <span class="keyword">case</span> c[temp] <span class="keyword">of</span></span><br><span class="line">                                     <span class="number">2</span>:total:=total+a[temp+<span class="number">1</span>];</span><br><span class="line">                                     <span class="number">3</span>:total:=total-a[temp+<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                     inc(temp2);</span><br><span class="line">                                     <span class="keyword">case</span> c[temp] <span class="keyword">of</span></span><br><span class="line">                                     <span class="number">2</span>:total:=total+b1[temp2];</span><br><span class="line">                                     <span class="number">3</span>:total:=total-b1[temp2];</span><br><span class="line">                                     <span class="keyword">end</span>;</span><br><span class="line">                                     <span class="keyword">for</span> i:=temp+<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">                                               <span class="keyword">if</span> i&lt;&gt;<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">                                               <span class="keyword">begin</span></span><br><span class="line">                                                        temp:=i;</span><br><span class="line">                                                        <span class="keyword">break</span>;</span><br><span class="line">                                               <span class="keyword">end</span>;</span><br><span class="line">                            <span class="keyword">end</span>;</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">                inc(temp);</span><br><span class="line">         <span class="keyword">end</span>;</span><br><span class="line">         <span class="keyword">if</span> total=<span class="number">0</span> <span class="keyword">then</span> print(c)</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">exit</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">dfs</span><span class="params">(x:integer;b:node)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">         <span class="keyword">if</span> (x=n) <span class="keyword">then</span></span><br><span class="line">         <span class="keyword">begin</span></span><br><span class="line">                   pd(b);</span><br><span class="line">                   <span class="keyword">exit</span>;</span><br><span class="line">         <span class="keyword">end</span>;</span><br><span class="line">         <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> <span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">         <span class="keyword">begin</span></span><br><span class="line">                   b[x]:=i;</span><br><span class="line">                   <span class="keyword">if</span> x+<span class="number">1</span>&lt;=n <span class="keyword">then</span> dfs(x+<span class="number">1</span>,b);</span><br><span class="line">         <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">init</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">         readln(n);</span><br><span class="line">         fillchar(a,sizeof(a),<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">                   a[i]:=i;</span><br><span class="line">         b[<span class="number">0</span>]:=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  assign(input,<span class="string">'zerosum.in'</span>);</span><br><span class="line">  reset(input);</span><br><span class="line">  assign(output,<span class="string">'zerosum.out'</span>);</span><br><span class="line">  rewrite(output);</span><br><span class="line">  init;</span><br><span class="line">  dfs(<span class="number">1</span>,b);</span><br><span class="line">  close(input);</span><br><span class="line">  close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本文是原新浪博客的移植，附：全部<a href="https://github.com/i-zhen/USACO-training" target="_blank" rel="noopener">USACO题目解答</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;本题不难，但是由于没有好的算术方案，所以编的时间长，又因为pascal递归不稳定，所以调试时间长，提交了三次&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="Pascal" scheme="http://izhen.me/tags/Pascal/"/>
    
      <category term="DFS" scheme="http://izhen.me/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>USACO 2.3.1 Prefix</title>
    <link href="http://izhen.me/2009/04/24/usaco_231/"/>
    <id>http://izhen.me/2009/04/24/usaco_231/</id>
    <published>2009-04-23T16:19:58.000Z</published>
    <updated>2018-09-23T13:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>这个程序是有史以来我编得最认真的usaco题目，虽然这个程序很慢，甚至在主程序部分使用了一点歪招？！但是这是使用递归思想的，非指针的Trie!没有优化，所以在贴上这个程序后，再贴一个正规一点的。</p><a id="more"></a><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p> Compiling…<br> Compile: OK Executing…<br> Test 1: TEST OK [0.000 secs, 6792 KB]<br> Test 2: TEST OK [0.000 secs, 6796 KB]<br> Test 3: TEST OK [0.000 secs, 6828 KB]<br> Test 4: TEST OK [0.000 secs, 6824 KB]<br> Test 5: TEST OK [0.032 secs, 6828 KB]<br> Test 6: TEST OK [0.670 secs, 6828 KB]<br> All tests OK. </p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> prefix;</span><br><span class="line"><span class="keyword">type</span> node=<span class="keyword">record</span>    </span><br><span class="line">        data:char;</span><br><span class="line">        son:integer;</span><br><span class="line">        jl:boolean;</span><br><span class="line">        er:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">1800</span>]<span class="keyword">of</span> integer;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span> ji,total,root,max,k:longint;</span><br><span class="line">        zd:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">1800</span>]<span class="keyword">of</span> node;</span><br><span class="line">        y1:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">200</span>]<span class="keyword">of</span> <span class="keyword">string</span>;</span><br><span class="line">        ls:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">200000</span>]<span class="keyword">of</span> boolean;</span><br><span class="line">        s:ansistring;</span><br><span class="line">        flag:boolean;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">find</span><span class="params">(x:<span class="keyword">string</span>;wz,c:integer)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> zd[wz].son <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> zd[zd[wz].er[i]].data=x[c] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> c+<span class="number">1</span>&lt;=length(x) <span class="keyword">then</span> find(x,zd[wz].er[i],c+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> zd[zd[wz].er[i]].jl <span class="keyword">then</span> flag:=true;</span><br><span class="line">                    <span class="keyword">exit</span>;</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(x:<span class="keyword">string</span>;y,z:integer)</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:integer;</span><br><span class="line">        f:boolean;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    f:=true;</span><br><span class="line">    <span class="keyword">if</span> zd[y].son=<span class="number">0</span> <span class="keyword">then</span> </span><br><span class="line">        <span class="keyword">begin</span> </span><br><span class="line">            inc(total);</span><br><span class="line">            inc(zd[y].son);</span><br><span class="line">            zd[y].er[zd[y].son]:=total;</span><br><span class="line">            zd[total].data:=x[z];</span><br><span class="line">            <span class="keyword">if</span> (z+<span class="number">1</span>)&lt;=length(x) <span class="keyword">then</span> </span><br><span class="line">                insert(x,total,z+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span> zd[total].jl:=true;<span class="keyword">exit</span>;<span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> zd[y].son <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> zd[zd[y].er[i]].data=x[z] <span class="keyword">then</span> </span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (z+<span class="number">1</span>)&lt;=length(x) <span class="keyword">then</span> </span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    insert(x,zd[y].er[i],z+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">exit</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span> zd[total].jl:=true;<span class="keyword">exit</span>;<span class="keyword">end</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span> f:=false;<span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> f <span class="keyword">then</span> </span><br><span class="line">        <span class="keyword">begin</span> </span><br><span class="line">            inc(total);</span><br><span class="line">            inc(zd[y].son);</span><br><span class="line">            zd[y].er[zd[y].son]:=total;</span><br><span class="line">            zd[total].data:=x[z];</span><br><span class="line">            <span class="keyword">if</span> (z+<span class="number">1</span>)&lt;=length(x) <span class="keyword">then</span> </span><br><span class="line">                insert(x,total,z+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span> zd[total].jl:=true;<span class="keyword">exit</span>;<span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">init</span>;</span></span><br><span class="line"><span class="keyword">var</span> i:longint;</span><br><span class="line">    te:char;</span><br><span class="line">    temp:ansistring;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    root:=<span class="number">1</span>;</span><br><span class="line">    zd[root].data:=<span class="string">' '</span>;</span><br><span class="line">    zd[root].son:=<span class="number">0</span>;</span><br><span class="line">    total:=<span class="number">1</span>;</span><br><span class="line">    ji:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> eoln(input) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">read</span>(te);</span><br><span class="line">            <span class="keyword">if</span> te&lt;&gt;<span class="string">'.'</span> <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span> (te=<span class="string">' '</span>) <span class="keyword">then</span></span><br><span class="line">                    inc(ji)</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> te <span class="keyword">in</span> [<span class="string">'A'</span>..<span class="string">'Z'</span>] <span class="keyword">then</span></span><br><span class="line">                    y1[ji]:=y1[ji]+te;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">if</span> eoln(input) <span class="keyword">then</span> inc(ji);</span><br><span class="line">        readln;</span><br><span class="line">    <span class="keyword">until</span> te=<span class="string">'.'</span>;</span><br><span class="line">    max:=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> ji <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        insert(y1[i],root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> length(y1[i])&gt;max <span class="keyword">then</span> max:=length(y1[i]);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    s:=<span class="string">''</span>;</span><br><span class="line">    k:=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> eof(input) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        readln(temp);</span><br><span class="line">        k:=k+length(temp);</span><br><span class="line">        s:=s+temp;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">main</span>;</span></span><br><span class="line"><span class="keyword">var</span> i,j,q,head,tail:longint;</span><br><span class="line">    st:<span class="keyword">string</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> k&gt;<span class="number">100000</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        head:=k <span class="keyword">div</span> <span class="number">2</span>;</span><br><span class="line">        tail:=k;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        head:=<span class="number">1</span>;</span><br><span class="line">        tail:=k;</span><br><span class="line">    <span class="keyword">end</span>;<span class="comment">//由于怕通不过，所以这里计算了一下数学期望，大于100000的数据折半处理。当然前一半在适当情况还是要算的。记得noip2008火柴棒等式我就使用了这种思想。 </span></span><br><span class="line">    <span class="keyword">for</span> i:=head <span class="keyword">to</span> tail <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        st:=<span class="string">''</span>;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> max <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            flag:=false;</span><br><span class="line">            st:=st+s[i+j-<span class="number">1</span>];</span><br><span class="line">            find(st,root,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> flag <span class="keyword">then</span> </span><br><span class="line">                <span class="keyword">for</span> q:=i <span class="keyword">to</span> i+j-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">                    ls[q]:=true;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=head <span class="keyword">to</span> tail <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ls[i] <span class="keyword">then</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            writeln(i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">exit</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> ls[k] <span class="keyword">then</span> writeln(k);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'prefix.in'</span>);</span><br><span class="line">    reset(input);</span><br><span class="line">    assign(output,<span class="string">'prefix.out'</span>);</span><br><span class="line">    rewrite(output);</span><br><span class="line">    init;</span><br><span class="line">    main;</span><br><span class="line">    close(input);</span><br><span class="line">    close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>另外一种字符串匹配的做法：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> prefix;</span><br><span class="line"><span class="keyword">const</span> cht=[<span class="string">'A'</span>..<span class="string">'Z'</span>];</span><br><span class="line"><span class="keyword">var</span> i,j,n,t:longint;</span><br><span class="line">    tmp:char;</span><br><span class="line">    temp,s:ansistring;</span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">200</span>]<span class="keyword">of</span> <span class="keyword">string</span>[<span class="number">10</span>];</span><br><span class="line">    f:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">200000</span>]<span class="keyword">of</span> boolean;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> assign(input,<span class="string">'prefix.in'</span>);</span><br><span class="line"> reset(input);</span><br><span class="line"> assign(output,<span class="string">'prefix.out'</span>);</span><br><span class="line"> rewrite(output);</span><br><span class="line"> t:=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> tmp&lt;&gt;<span class="string">'.'</span>  <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">read</span>(tmp);</span><br><span class="line">   <span class="keyword">if</span> tmp <span class="keyword">in</span> cht <span class="keyword">then</span></span><br><span class="line">    a[t]:=a[t]+tmp</span><br><span class="line">   <span class="keyword">else</span> inc(t);</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"> <span class="keyword">while</span> <span class="keyword">not</span> eof <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">   readln(temp);</span><br><span class="line">   s:=s+temp;</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"> dec(t);</span><br><span class="line"> n:=length(s);</span><br><span class="line"> f[<span class="number">0</span>]:=true;</span><br><span class="line"> <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> t <span class="keyword">do</span></span><br><span class="line">   <span class="keyword">if</span> length(a[j])&lt;=i <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> copy(s,i-length(a[j])+<span class="number">1</span>,length(a[j]))=a[j] <span class="keyword">then</span></span><br><span class="line">     <span class="keyword">if</span> f[i-length(a[j])] <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">       f[i]:=true;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">end</span>;</span><br><span class="line"> <span class="keyword">for</span> i:=n <span class="keyword">downto</span> <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> f[i] <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">    writeln(i);</span><br><span class="line">    halt;</span><br><span class="line">   <span class="keyword">end</span>;</span><br><span class="line"> close(input);</span><br><span class="line"> close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本文是原新浪博客的移植，附：全部<a href="https://github.com/i-zhen/USACO-training" target="_blank" rel="noopener">USACO题目解答</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h4&gt;&lt;p&gt;这个程序是有史以来我编得最认真的usaco题目，虽然这个程序很慢，甚至在主程序部分使用了一点歪招？！但是这是使用递归思想的，非指针的Trie!没有优化，所以在贴上这个程序后，再贴一个正规一点的。&lt;/p&gt;
    
    </summary>
    
      <category term="Solve" scheme="http://izhen.me/categories/Solve/"/>
    
    
      <category term="Pascal" scheme="http://izhen.me/tags/Pascal/"/>
    
      <category term="Trie" scheme="http://izhen.me/tags/Trie/"/>
    
      <category term="String Pattern Match" scheme="http://izhen.me/tags/String-Pattern-Match/"/>
    
  </entry>
  
  <entry>
    <title>哲理</title>
    <link href="http://izhen.me/2009/04/19/philosophy/"/>
    <id>http://izhen.me/2009/04/19/philosophy/</id>
    <published>2009-04-18T16:12:53.000Z</published>
    <updated>2020-01-26T13:04:58.081Z</updated>
    
    <content type="html"><![CDATA[<p>以下是我业余时(中考前，2008年)写下的,先贴一小部分,并不都是我写的,有的是总结的:</p><a id="more"></a><ol><li>千万不要放弃眼前所做的,哪怕它再不可能完成,只要未到最后时刻,它总有可能</li><li>就算要相信自己的潜力,但是唯有全力以赴,才会有收获,而不是凭空幻想</li><li>全力以赴是成功的根基之一,毅力则是全力以赴的前提</li><li>要对自己的选择及所作所为负责</li><li>要多动脑子,尽量用自己的大脑去想问题,直到还是想不出,再去请教</li><li>作为一名赛车手的精神是:在看不到方格旗挥动时绝不停下;作为一名OIer的精神是:在无数次WA之后仍能坚定的按下F5</li><li>一定要把你认为重要的事先做完,万不可推拖,否则你就再也没有时间去做了</li><li>当你在想“该是……”的时候，可能结果是“不该是……”所以惟有探究下去，方可寻求出真理</li><li>有梦想，并要有能力去实现</li><li>失去了眼前的小利益，不会失去将来的大利益，所以要在学会努力争取的同时学会放弃</li><li>你的宝贵东西可能有一天不属于立了，但是唯有真情，无论在何时都不会被泯灭</li><li>学习的目标不是为了学习，而是为了改变与完善</li><li>如何掌握取舍的关键在于你对问题及对未来的影响的认知程度</li><li>当你真的在乎得到或舍弃某样东西时，你就不会犹豫不决了</li><li>占有不代表真正意义上的拥有</li><li>学习自然科学或者文学的途径，前者是利用积累不断创新，后者是利用创新不断积累</li><li>(*)定期地给自己复位归零，清除心灵的污染，才能更好的享受工作与生活</li><li>若问我喜欢什么,答：“时间”。 若问我位什么喜欢时间，答：“因为它是永恒的”</li><li>当你安守于现阶段的发达时，你的灾难将不远了。因为你不知道这是你方法得当，努力争取的良果，所以这时的你最脆弱。请马上清醒，认真总结</li><li>既不要妄自尊大过分自负，也不要妄自菲薄，全盘否定自己</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是我业余时(中考前，2008年)写下的,先贴一小部分,并不都是我写的,有的是总结的:&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="OI" scheme="http://izhen.me/tags/OI/"/>
    
      <category term="中考" scheme="http://izhen.me/tags/%E4%B8%AD%E8%80%83/"/>
    
      <category term="2008" scheme="http://izhen.me/tags/2008/"/>
    
  </entry>
  
  <entry>
    <title>理念</title>
    <link href="http://izhen.me/2009/04/11/first_province_team/"/>
    <id>http://izhen.me/2009/04/11/first_province_team/</id>
    <published>2009-04-11T04:10:10.000Z</published>
    <updated>2018-09-23T09:28:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>天行键，君子以自强不息；地势坤，君子以厚德载物!</p><p>马上就要有大的挑战，学习功课闲暇时还要抽时间刷题，刷题闲暇时还要玩游戏，玩游戏闲暇时还要努力睡觉，睡觉闲暇时还要发博，厄……连锁的链式反应就是可怕，没办法，好多事其实是一件事，慢慢做，不怕做不完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;天行键，君子以自强不息；地势坤，君子以厚德载物!&lt;/p&gt;
&lt;p&gt;马上就要有大的挑战，学习功课闲暇时还要抽时间刷题，刷题闲暇时还要玩游戏，玩游戏闲暇时还要努力睡觉，睡觉闲暇时还要发博，厄……连锁的链式反应就是可怕，没办法，好多事其实是一件事，慢慢做，不怕做不完&lt;/p&gt;

      
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="OI" scheme="http://izhen.me/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>NOI四金得主的信(致吴文虎教授)</title>
    <link href="http://izhen.me/2009/03/13/noi_4_gold/"/>
    <id>http://izhen.me/2009/03/13/noi_4_gold/</id>
    <published>2009-03-13T14:37:04.000Z</published>
    <updated>2018-09-23T09:21:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>何林同学是湖南省长沙市雅礼中学的应届毕业生，从小学开始学习计算机编程，初一进入NOI湖南省队，曾荣获NOI金牌4块，银牌1块，4次进入国家集训队，2003年在美国举行的第15届IOI上荣获金牌。</p><a id="more"></a><p>下面是中国计算机学会秘书长、NOI竞赛委员会主席杜子德教授与NOI科学委员会主席、清华大学吴文虎教授针对这封信的对话：</p><p>=============================================================================================</p><p>吴老师：</p><p>看了何林给您写的信，非常感动。</p><p>不知道像何林这样的学生的成长和我们NOI以及您有多大关系，但敢肯定是有极大的关系的。像他这样的孩子刚入大学就如此懂事真是让人赞叹，他似乎已经悟出一些人生的真谛了。这些东西是他自己在实践中，经过自己思考得出的，不是谁灌输的，但和我们提供的环境有关。这样的孩子上哪个学校都不会太差，希望更多孩子像何林这样懂事。</p><p>建议在一个范围内公开这封信，让其他老师和学生也读读。<br>夏安！</p><p>子德<br>6月27日</p><p>=============================================================================================</p><p>Zide，您好！</p><p>赞成你的意见。NOI 是素质教育的大课堂，也是立志和形成健康人格的一个育人场所。正因为如此，学会所提供的环境才有意义，NOI 活动才有魅力，老师们才能体会投入这项工作的价值。您和我一样，盼望着 NOI 的孩子们快快长大，青出于兰而更胜于蓝。<br>祝好！</p><p>吴文虎</p><p>=============================================================================================</p><p>尊敬的吴老师：</p><p>您好！<br>我是湖南长沙雅礼中学的何林。不知道近来身体是否安好？</p><p>初一在澳门的NOI还历历在目：因为输入文件名的错误丢了一整道题目的分，12岁的我在测试现场哭了起来。五年过去了，何林已经不是那个为了一时得失动辄流泪的小男孩，而您依然还在为了信息学和计算机科学的普及孜孜不倦的工作。</p><p>我一直都很明白、也很感激您对我的关心。您对我的感情一方面是出于一个学者、师长对孩子的关心，另一方面则是出于对信息学这一门学科的关心——因为我是一个从初一就开始接受系统编程训练的学生；我的发展具有很强的典型性和可研究性。这也是我对您最尊敬的地方，您做任何事情给我的感觉都是：既质朴简单、又深刻；看起来都是细微的小事、其实都是从大处着眼、胸怀宇宙。这些从您在各种活动上的讲话就能窥见一斑。</p><p>如果有人问我，这五年的信息学生涯教会了我什么，我不会说“我会用平衡二叉树”、也不会说“我学懂了动态规划”。我不管学到多少，总还有很多没学到；即便是学会了的东西，长时间不用也会遗忘。我认为我真正学到的是习惯、态度和方法。我学会了批判性的看问题、我学会了用开阔的胸怀去接受所有不同的想法、我学会了分析问题、总结问题、乃至提出问题的一系列方法和经验。这些才是无价之宝，是一辈子在任何地方任何时候都不会丢的宝贝。</p><p>我认为信息学竞赛是很成功很有必要的。社会上、教育界有不少人偏激的反对信息学甚至是奥林匹克竞赛，说竞赛影响全面发展、竞赛培养出书呆子。其实我认为，一个不知道“碳碳双键”的人可以在一个小时之内学会这个知识点，但是一个没有良好学习习惯和态度的人无论掌握多少知识都会在长期竞争中被淘汰下去。高考培养出来的学生都是很全面很扎实的，但是我个人感觉这种“全面”是一种假象。虽然高考出来的人中有很多的确是出类拔萃的英才，但是更多的是抓了一船鱼却没有找到钓鱼勾的渔夫。</p><p>在我看来信息学竞赛的确还是有一些不太好的地方。比如竞赛的成绩很大程度还是取决于做题量；题海战术还是屡试不爽；真正思路新颖的选手经常无法胜出。从实际上来看，根据我的了解，比如石润婷、倪兆中这样到了大学表现杰出的选手都没有入选国家队。我作为一个学生没有什么好的解决方案，只是粗浅的说说自己的看法而已。</p><p>经过五年信息学竞赛的洗礼，我成熟了很多，也非常感谢吴老师和清华大学对我的这么多年的谆谆教诲。以上算是我的一个总结和感受吧。</p><p>我即将进入人生一个新的阶段——大学。摆在我面前的有两个选择：清华和耶鲁。在这两所学校之间作出选择是痛苦的。我最后选择了后者，在此向吴老师汇报一下我的想法。</p><p>从本科的专业上来说，清华的计算机系综合是要强过耶鲁大学的。但是耶鲁大学有一个很大的优势：他们的学生能够、也必须选择除专业课外的大量其他学科。比如经济学、心理学、语言学都是对任何学生开放的；而且所有的学生都被要求在不同的领域选择足够的学分。我觉得在本科阶段能够接触尽量多的学科对于一个人长远的发展会更有好处；听说在后期的一些顶尖的科学研究中，心理学、语言学、甚至音乐等都起到决定性的作用。</p><p>耶鲁大学的这种做法和美国的大部分本科都类似。这种大而全的做法有一点牺牲专业课的时间；所以我感觉四年下来清华学生的专业课扎实程度肯定要强得多。但是美国的这种做法却铸就了不少的大师，所以很有可能较宽的知识面对于后期的研究发展更有好处。具体哪种方法更好还有争论，所以我也很难说我选择耶鲁就一定是正确的。</p><p>不过从信息学的角度来说，以前的学生大多进入了清华大学学习；这些学生毕业后有的去了美国、有的留在了清华。不同的人走不同的路子；有的路子培养出来的人出息更大。但是具体哪些路子更适合中国可能需要数十年的长期观察才能得出答案。得出答案之前，我认为国家应该鼓励多元化——各种不同的路子都有人去闯，全凭兴趣而言。最后总能有一拨人成就大事业、开创大场面。不管怎么样，多元化的受益者肯定是国家和这个整体。</p><p>另一方面，以前信息学竞赛选手中，高中毕业就出国的是少数。我作为“拓荒者”之一，也能够更全面的检验我们NOI培养出来的选手到底素质怎么样、到底有没有发展的潜力。</p><p>综合上面的考虑，我最后选择了耶鲁。对我个人，耶鲁可能是一个好的选择；对NOI、对我的祖国，耶鲁绝对不是一个坏的选择。</p><p>五年来我听着吴老师的谆谆教导长大，也为吴老师的人格和智慧所折服。清华的很多学生，比如周源、金恺都是我非常好的朋友；我的心是紧紧和清华系在一起的。虽然我没有机会进入清华的本科学习了，但是我仍然会努力去理解清华的精神、把它融入到我的灵魂之中，以清华为启明星引导我未来的学习和个人发展。</p><p>虽然当我说“对不起，我不能进入清华学习”的时候有一点伤心和犹豫，但是我还是感到开心和充满希望的。</p><p>人们都说教师的职责是言传；我觉得教师更重要的职责是身教。从这个意义上来说吴老师永远都是我的师长，是我人生轨迹中最闪亮的一颗明星。感谢您吴老师！</p><p>此致<br>敬礼<br>2005年6月17日<br>何林</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;何林同学是湖南省长沙市雅礼中学的应届毕业生，从小学开始学习计算机编程，初一进入NOI湖南省队，曾荣获NOI金牌4块，银牌1块，4次进入国家集训队，2003年在美国举行的第15届IOI上荣获金牌。&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://izhen.me/categories/Blog/"/>
    
    
      <category term="OI" scheme="http://izhen.me/tags/OI/"/>
    
      <category term="留学" scheme="http://izhen.me/tags/%E7%95%99%E5%AD%A6/"/>
    
      <category term="耶鲁" scheme="http://izhen.me/tags/%E8%80%B6%E9%B2%81/"/>
    
  </entry>
  
</feed>
